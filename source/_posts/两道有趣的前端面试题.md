---
title: 两道有趣的前端面试题
date: 2017-04-17
---
> 在知乎上看到了两道有趣且知识点非常丰富的JavaScript面试题，所以引用过来并分析，做个记录。 

<!--more-->
## 一、for循环内的输出"变形记"
#### 1、原型
```
for (var i = 0; i < 5; i++) {
  console.log(i);
}
```
这个不用说了，最简单的输出。会直接输出0，1，2，3，4

#### 2、变形1
```
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000 * i);
}
```
哈！考到我们看过很多遍的闭包问题了。结果是 先输出5，然后 每隔1s输出一个5。最后显示5个5。做个简单解释：因为闭包，for循环没有块级作用域。在函数执行时，for循环早已完成。console里接受的i全都是5。但1000*i里i是正常被赋值的。所以 都会被放入时间队列中，而且时间每隔1s
。

那么我们如何将输出变成0，1，2，3，4呢？在循环里加个自执行函数就行了。看下面
#### 3、解决方法（变形2）
```
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i);
}
```
这个就是我们的解决方案了。详细解释可以看  [JavaScript之理解闭包](http://www.jianshu.com/p/66951b1fcc77) 这篇文章。

#### 4、变形3
如果把这个自执行函数里的 i 拿掉呢？  代码变成下面这样:
```
for (var i = 0; i < 5; i++) {
  (function() {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i);
}
```
这样的话， i 没有被内部引用，也就变回去了。自执行函数也就没了意义。输出和变形1一样。

#### 5、变形4
我们把自执行函数放到里面去呢？ 代码变成这样:
```
for (var i = 0; i < 5; i++) {
  setTimeout((function(i) {
    console.log(i);
  })(i), i * 1000);
}
```
嗯？ 这样就有点意思了，考察了setTimeout的知识。setTimeout的第一个参数只接受字符串或函数。而这里却给了一个自执行函数，而且没有return。那么可以等价为setTimeout(undefined, ...) 。那么自执行函数就会立即执行了。setTimeout()等于没起到作用，所以应该是直接输出0，1，2，3，4。

#### 6、变形5 (Promise)
```
setTimeout(function() {
  console.log(1)
}, 0);
new Promise(function executor(resolve) {
  console.log(2);
  for( var i=0 ; i<10000 ; i++ ) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function() {
  console.log(4);
});
console.log(5);
```
这段代码会输出什么呢？
结果是：2，3，5，4，1

这题在考察我们JavaScript的运行机制。慢慢分析：
1. setTimeout 内代码执行被挂起，稍后执行。
2. Promise 内的代码是自执行的，所以2，3先被输出。然后resolve 也被挂起。
3. 然后输出里面的5，接下来就是比较4和1谁先输出。
4. 这一点我们需要了解事件循环(event loop), Promise.then 和 setTimeout 都是异步任务，那究竟谁先执行？
5. Promise.then的callback被添加到microtasks queue中; setTimeout的callback被添加到 tack(macro-task) queue 中。代码执行到当前task的end。执行microtasks的代码，输出4。
6. 到下一个task，执行setTimeout中代码输出1

可能我解释的不大清楚，大家可以看这篇博文，解释[Promise.then和setTimeout的异步](https://github.com/creeperyang/blog/issues/21)

而关于macrotask 和 microtask 的机制，可以看我写的这篇博文 [戳这](http://blog.josephong.me/2017/03/02/JavaScript%E4%B9%8B%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2/)。

这个面试题的知乎原地址：[Excuse me？这个前端面试在搞事！](https://zhuanlan.zhihu.com/p/25407758)

-----------------------------------------
## 二、模拟实现ES5中原生bind函数

### bind函数究竟是什么？
bind函数常与call，apply一起讨论出现。它们都是用于绑定this值指向的。与另外两个不同的是bind会创建一个新函数。而不是像其它两个一样立即执行。更多的信息可以上[MDN_bind](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)查看。

### 初级实现

了解了以上内容，我们来实现一个初级的bind函数Polyfill:

```
Function.prototype.nbind = function (context) {
    var me = this;
    var argsArray = Array.prototype.slice.call(arguments);
    return function () {
        return me.apply(context, argsArray.slice(1))
    }
}

this.x = 9; 
var module = {
  x: 81,
  getX: function() { return this.x; }
};
var retrieveX = module.getX;
var boundGetX = retrieveX.nbind(module);
console.log(boundGetX()); // 81
```
我们先简要解读一下：
基本原理是使用apply进行模拟。函数体内的this，就是需要绑定this的实例函数，或者说是原函数。最后我们使用apply来进行参数（context）绑定，并返回。
同时，将第一个参数（context）以外的其他参数，作为提供给原函数的预设参数，这也是基本的“颗粒化（curring）”基础。

### 中级实现
上面的代码只模拟bind的基础功能，当我们想要实现预设传参的功能时，上面的代码无法做到，需要再进一步模拟:

```
Function.prototype.nbind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(context, finalArgs);
    }
}

function list() {
  return Array.prototype.slice.call(arguments);
}

var list1 = list(1, 2, 3); // [1, 2, 3]

// Create a function with a preset leading argument
var leadingThirtysevenList = list.nbind(undefined, 37);

var list2 = leadingThirtysevenList(); // [37]
var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]
```
上面这个例子，在初级实现中是得不到正确结果的，在中级模拟可以得到。这里我们我们的第二参数变成finalArgs而不直接是args。在函数内部，我们用concat连接了预设参数和现在参数。
### Ployfill
然而bind函数还有第三个特性，绑定函数适用于用new操作符 new 去构造一个由目标函数创建的新的实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。然而, 原先提供的那些参数仍然会被前置到构造函数调用的前面。

而这个特性在**中级实现**中无法实现，进一步模拟。也是MDN给出的Ployfill：

```
Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    var F = function () {};
    F.prototype = this.prototype;
    var bound = function () {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.contact(innerArgs);
        return me.apply(this instanceof F ? this : context || this, finalArgs);
    }
    bound.prototype = new F();
    return bound;
}
```

知乎原文地址：[从一道面试题的进阶，到“我可能看了假源码”](https://zhuanlan.zhihu.com/p/25379434)

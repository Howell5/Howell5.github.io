{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/even/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/even/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.eot","path":"fonts/chancery/apple-chancery-webfont.eot","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.ttf","path":"fonts/chancery/apple-chancery-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff","path":"fonts/chancery/apple-chancery-webfont.woff","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff2","path":"fonts/chancery/apple-chancery-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/even/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/even/source/js/src/even.js","path":"js/src/even.js","modified":0,"renderable":1},{"_id":"themes/even/source/js/src/search.js","path":"js/src/search.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_loading.gif","path":"lib/fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/blank.gif","path":"lib/fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_loading@2x.gif","path":"lib/fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_overlay.png","path":"lib/fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite.png","path":"lib/fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite@2x.png","path":"lib/fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.css","path":"lib/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.pack.js","path":"lib/fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.js","path":"lib/fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/slideout/slideout.min.js","path":"lib/slideout/slideout.min.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/slideout/slideout.js","path":"lib/slideout/slideout.js","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.svg","path":"fonts/chancery/apple-chancery-webfont.svg","modified":0,"renderable":1},{"_id":"themes/even/source/image/reward/alipay.png","path":"image/reward/alipay.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/jquery/jquery-3.1.1.min.js","path":"lib/jquery/jquery-3.1.1.min.js","modified":0,"renderable":1},{"_id":"themes/even/source/image/reward/wechat.png","path":"image/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/fancybox_buttons.png","path":"lib/fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-media.js","path":"lib/fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"d7af42e5a0d49c8963f8f906d6b63bb187a11185","modified":1492873768000},{"_id":"themes/even/.eslintrc","hash":"af17814aa6d4f488f9c09a727652a7efc1552c03","modified":1492873157000},{"_id":"themes/even/.gitignore","hash":"1d54f4b6fe44e61eae3d29e95de4b2618a6619aa","modified":1492873157000},{"_id":"themes/even/README.md","hash":"820b6d6301574d77db992bdc4b7fd327640c8e29","modified":1492873157000},{"_id":"themes/even/_config.yml","hash":"25576cbf69d06fc1840be677df85af3c5e3468a4","modified":1492873470000},{"_id":"themes/even/LICENSE","hash":"6fd796a4c624297885ceed920ac7130a96f29a85","modified":1492873157000},{"_id":"themes/even/package.json","hash":"d689e42e7364bded66e2df142a5febedaae4be25","modified":1492873157000},{"_id":"source/_posts/CSS系列之Flexbox布局.md","hash":"244d34abe4c92de12993408cd3ff5541b9e079e3","modified":1490797355000},{"_id":"source/_posts/CSS系列之双飞翼布局.md","hash":"aa0a8a6fc85461347162390250ea90bb75bdd65d","modified":1478790921000},{"_id":"source/_posts/CSS系列之从box-sizing的值谈盒模型.md","hash":"4f675647037b6df4db322a8258b6942227723bd7","modified":1492873761000},{"_id":"source/_posts/CSS系列之圣杯布局.md","hash":"ec430f4031d2c386be2eae2de328e8551c706547","modified":1478790926000},{"_id":"source/_posts/Coursera全栈课程学习笔记.md","hash":"8b55a00744cd27124df21dbe227880b66002e4e8","modified":1490797558000},{"_id":"source/_posts/JavaScript之深入理解this.md","hash":"2df2109daa0c39080f38da7412a170a30efb43b2","modified":1490797445000},{"_id":"source/_posts/JavaScript之理解作用域.md","hash":"7d5534ee0ac403a57255f5115ac40cb0efe1f535","modified":1490797470000},{"_id":"source/_posts/CSS系列之选择器.md","hash":"9b40f3567329e7fc9f2e8e11f854c39271a5fde4","modified":1490797424000},{"_id":"source/_posts/JavaScript基本数据结构.md","hash":"69cfd3cffdef3a880913c3c3caa62856e1ce5516","modified":1492874312000},{"_id":"source/_posts/JavaScript详解跨域.md","hash":"83a96810df46039dac535251fbe66a800f810c2c","modified":1492873786000},{"_id":"source/_posts/JavaScript之理解闭包.md","hash":"555e623846b5673ece8d80fc67ff5e1252f5b35e","modified":1490797496000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1492871676000},{"_id":"source/_posts/css系列之常见布局.md","hash":"9b03e7c9b995af831d8b9fb05c33178fb1d162a3","modified":1490543498000},{"_id":"source/_posts/简历.md","hash":"0dec0e65c0104b1afb852bbb7e0894096eeb3739","modified":1492874074000},{"_id":"source/_posts/移动web学习笔记.md","hash":"9e6c20f36f1f742ce5448f58837f637d9576e7bd","modified":1490797282000},{"_id":"themes/even/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1492873157000},{"_id":"themes/even/.git/config","hash":"5ef1223485809abf438784735be8518631c5a612","modified":1492873157000},{"_id":"themes/even/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1492873149000},{"_id":"themes/even/.git/index","hash":"0a0d70ba593db61c96d82132d162a633b4029816","modified":1492873157000},{"_id":"themes/even/.git/packed-refs","hash":"9c3b84d7d50942ee072fe6082b1bb77c85fdc8b5","modified":1492873157000},{"_id":"themes/even/languages/en.yml","hash":"e5eebf05f48a53020ee798cac58b0c3e7f0a95f2","modified":1492873157000},{"_id":"themes/even/languages/zh-cn.yml","hash":"9fca22d97f9381afc187e9b14d9f8de5c0f5d9c5","modified":1492873157000},{"_id":"themes/even/layout/_layout.swig","hash":"011a510b0977c40bda922d5969d39071f0e8ae99","modified":1492873157000},{"_id":"themes/even/languages/default.yml","hash":"eeaa1cf150c669c08f4b70336c819b8a8eac1d0b","modified":1492873157000},{"_id":"themes/even/layout/archive.swig","hash":"30971263c38e67bffb6fdd90d458f6c82a75c05d","modified":1492873157000},{"_id":"themes/even/layout/categories.swig","hash":"dc244e0ee1fc34f43d5b195b9c1f6ef6d3ad2d0d","modified":1492873157000},{"_id":"themes/even/layout/index.swig","hash":"f3341b5f4af1eab0930a1d078b3022bbe0a59232","modified":1492873157000},{"_id":"themes/even/layout/page.swig","hash":"3a767206198efb3eb487d7061107212c2171106c","modified":1492873157000},{"_id":"themes/even/layout/post.swig","hash":"a0ed82a3aa04d3554dd654a3cf6194644ae1574c","modified":1492873157000},{"_id":"themes/even/layout/tags.swig","hash":"ae9500008d0b445d1962a34cdb59fde3106ed33a","modified":1492873157000},{"_id":"themes/even/source/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1492873157000},{"_id":"themes/even/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1492873149000},{"_id":"themes/even/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1492873149000},{"_id":"themes/even/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1492873149000},{"_id":"themes/even/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1492873149000},{"_id":"themes/even/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1492873149000},{"_id":"themes/even/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1492873149000},{"_id":"themes/even/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1492873149000},{"_id":"themes/even/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1492873149000},{"_id":"themes/even/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1492873149000},{"_id":"themes/even/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1492873149000},{"_id":"themes/even/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1492873149000},{"_id":"themes/even/.git/logs/HEAD","hash":"248d4b2c0a34480f8823e2a06e46bf581066951a","modified":1492873157000},{"_id":"themes/even/layout/_script/analytics.swig","hash":"24ba4a8adcaf09c9ede76405ee732385595d8e39","modified":1492873157000},{"_id":"themes/even/layout/_script/comments.swig","hash":"eee7b4860b1ec25226cf0d46f2f54cfc13562359","modified":1492873157000},{"_id":"themes/even/layout/_script/config.swig","hash":"7f2a1da26b780079214457d85136ffffaf36092f","modified":1492873157000},{"_id":"themes/even/layout/_script/libs.swig","hash":"67940ae28766608a3d6f287ecc95fa05db49f243","modified":1492873157000},{"_id":"themes/even/layout/_script/search.swig","hash":"02c3361c9b8645e00be01f51b49b562d9e51858f","modified":1492873157000},{"_id":"themes/even/layout/_script/theme.swig","hash":"cb81a0a6a6d5264cc6451dda3dd3a96101f89b1d","modified":1492873157000},{"_id":"themes/even/layout/_partial/comments.swig","hash":"0f2d637b275d3ff70f78fb22d7d58ab73300dd4b","modified":1492873157000},{"_id":"themes/even/layout/_partial/footer.swig","hash":"248a60fe0122daf3706a291e4313f629de29384f","modified":1492873157000},{"_id":"themes/even/layout/_partial/head.swig","hash":"5497cb03439d90b4ba7148bbc1e9d303539bb388","modified":1492873157000},{"_id":"themes/even/layout/_partial/header.swig","hash":"01972309c0804558c5b5476fa219ce000330f244","modified":1492873157000},{"_id":"themes/even/layout/_partial/pagination.swig","hash":"3843e523b9a7a1c5973d0c2de05cc88467733e09","modified":1492873157000},{"_id":"themes/even/layout/_partial/slideout.swig","hash":"d046aa352c8e3f298c21ce537bd3dffc63e33abc","modified":1492873157000},{"_id":"themes/even/source/css/_base.scss","hash":"d03265b755abb63f8189750b20321c6aef7b7d7d","modified":1492873157000},{"_id":"themes/even/source/css/_variables.scss","hash":"5d8885a70b5247e535f0970b5805458e6b1608a9","modified":1492873157000},{"_id":"themes/even/source/css/style.scss","hash":"6c57b95c4f936c7cc2a7047150b163919038168e","modified":1492873157000},{"_id":"themes/even/layout/_macro/post.swig","hash":"8473af4d9d48beb4107a78521779b66d86f09ebe","modified":1492873157000},{"_id":"themes/even/layout/_macro/archive.swig","hash":"09cde870c8392d93d4bde0862f2f53a87b196ad4","modified":1492873157000},{"_id":"themes/even/.git/refs/heads/master","hash":"3d23013ca00d5150a891d59dd25c3649be6e83ff","modified":1492873157000},{"_id":"themes/even/layout/_script/_analytics/baidu-analytics.swig","hash":"5d62309b16071f1b6952891ec8e1f1d42e38a088","modified":1492873157000},{"_id":"themes/even/layout/_script/_analytics/google-analytics.swig","hash":"f44684799386fbd4af6e5994b0c14c85eeff060c","modified":1492873157000},{"_id":"themes/even/layout/_script/_comments/netease.swig","hash":"6dec861157b158b017b2270b7457c33bc158f029","modified":1492873157000},{"_id":"themes/even/layout/_script/_comments/duoshou.swig","hash":"34986ff3b065a6aaba981ece010afde182dd97f9","modified":1492873157000},{"_id":"themes/even/layout/_script/_comments/disqus.swig","hash":"0502145777d65515249680d3e4611f249e3d9ff8","modified":1492873157000},{"_id":"themes/even/layout/_partial/_footer/social.swig","hash":"65368d0a5108fecc072eaea3b1fb04c597941729","modified":1492873157000},{"_id":"themes/even/layout/_partial/_head/meta.swig","hash":"4692e4aa4675e069f886b7ee49bd610c00f3e3bd","modified":1492873157000},{"_id":"themes/even/layout/_partial/_post/copyright.swig","hash":"dbd57ececb200ee220189f51cc748023b96592d8","modified":1492873157000},{"_id":"themes/even/layout/_partial/_post/reward.swig","hash":"faf64b5461970fda72863e9779f3f024cb493658","modified":1492873157000},{"_id":"themes/even/layout/_partial/_post/toc.swig","hash":"fc21e5b9ebaca219678d85b8c5e4b3ee013fca25","modified":1492873157000},{"_id":"themes/even/source/css/_common/_animation.scss","hash":"f32d2444f0ab4dcb8b811ae1bccae6073f21a988","modified":1492873157000},{"_id":"themes/even/source/css/_common/_normalize.scss","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1492873157000},{"_id":"themes/even/source/css/_common/_utils.scss","hash":"21dfd8cfdb574504b97896a282044d93d972e338","modified":1492873157000},{"_id":"themes/even/source/css/_custom/_custom.scss","hash":"d0873cd8554d515282a6792fcc3f5bd4a256b7a6","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_archive.scss","hash":"019ee950e5da4395c867b950c8da06d03310b3db","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_categories.scss","hash":"96f47000d25ef4e0e948f8f43fa4e2983ff0d746","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_back-to-top.scss","hash":"c6f586ac04a9a0f3633dadf5c66be9e0c4027f1d","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_footer.scss","hash":"76f3a72440be8aa1e93d8ddc5ea958777d1545ab","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_header.scss","hash":"4a3e92feef33bed0021f1a65a801c24ee7d5946f","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_iconfont.scss","hash":"2a68735df51cf6b1c9559e70814ac311804cd8eb","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_mobile.scss","hash":"0d1c60bd92f8e5db01e7843934251152ec4d6d44","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_pagination.scss","hash":"b24db39534e180ebcebba2e81d91d9f1d534eea1","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_post.scss","hash":"7d03216b1fb5007ecc33412cacab74432c4e02d2","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_slideout.scss","hash":"e4820a42698f647a824575b234835b9ce4ac4797","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_tags.scss","hash":"fb4bf54b34291d5b72598a7ba4d3e370c8ad9383","modified":1492873157000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1492873157000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1492873157000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1492873157000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1492873157000},{"_id":"themes/even/source/js/src/bootstrap.js","hash":"c37073db93271410e30dfa9a894fc78a4f025abd","modified":1492873157000},{"_id":"themes/even/source/js/src/even.js","hash":"9491d0c34812d76d5caf303100b17510ff8f0fc3","modified":1492873157000},{"_id":"themes/even/source/js/src/search.js","hash":"2670045b8af8150390df1a4f081f8167a5648d67","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1492873157000},{"_id":"themes/even/source/lib/slideout/slideout.min.js","hash":"7166ed307b771398a593fc3d4f1c5d93fbbe19bb","modified":1492873157000},{"_id":"themes/even/source/lib/slideout/slideout.js","hash":"81ec76a63f6f4bbdfc801d822182ab8afa9068fe","modified":1492873157000},{"_id":"themes/even/.git/objects/pack/pack-d8a31960825b99340ee99787c9474ddfbf6e7f63.idx","hash":"54aa14a5feded048fd92dee457a3a3259b01b39e","modified":1492873157000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1492873157000},{"_id":"themes/even/source/image/reward/alipay.png","hash":"75e0f7d3f804f5ed5f6978ffdc6522224df1b701","modified":1492873157000},{"_id":"themes/even/source/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1492873157000},{"_id":"themes/even/.git/logs/refs/heads/master","hash":"248d4b2c0a34480f8823e2a06e46bf581066951a","modified":1492873157000},{"_id":"themes/even/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_footer/_copyright.scss","hash":"afbc0f90c674e5cd5fd7509eb1296d60b999d4e1","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_footer/_social.scss","hash":"bca6a1036951c2475278bfbd3a5ce51ff861e9a3","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_header/_logo.scss","hash":"109073dde15146d835bf06faa2f256d1ac658315","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_header/_menu.scss","hash":"c823489bc6c0f320618362f9e07d9114b9f8612b","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_header/_search.scss","hash":"b272e3f0fba05d66de648717f6dfe2718637e8f6","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_post/_code.scss","hash":"d866ae4f05dd3f65e55388727c1277ace55d4c7c","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_post/_content.scss","hash":"d1a84cd75828e165133c7f7e9ad518d2d02e5925","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_post/_copyright.scss","hash":"9e33c5935885552d6abdf43e2b1e5a278211f052","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_post/_footer.scss","hash":"9f2ab0ac20b2a8bfd315febd387c399f72f43d10","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_post/_header.scss","hash":"e3644f535fab81e6437796901cba36500d8ae290","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_post/_reward.scss","hash":"66ec9faa27ed879dc9a2ca59c73ed6bfd5e61dcd","modified":1492873157000},{"_id":"themes/even/source/css/_partial/_post/_toc.scss","hash":"dba41bc7638e22c59eb704fc6de80c32d6f1ed52","modified":1492873157000},{"_id":"themes/even/source/image/reward/wechat.png","hash":"f9904f25b35fa9d38e221ef7089787d24ee8b02b","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1492873157000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1492873157000},{"_id":"themes/even/.git/logs/refs/remotes/origin/HEAD","hash":"248d4b2c0a34480f8823e2a06e46bf581066951a","modified":1492873157000},{"_id":"themes/even/.git/objects/pack/pack-d8a31960825b99340ee99787c9474ddfbf6e7f63.pack","hash":"0c3dd961b4efbfeb885d46af5662cdaec617f8b8","modified":1492873157000},{"_id":"public/2016/06/06/Coursera全栈课程学习笔记/index.html","hash":"8853cc2a039f30bf27bcf2655691aff017d92656","modified":1492873980272},{"_id":"public/2016/07/29/CSS系列之圣杯布局/index.html","hash":"57a916811a699063831a486ef85ac16b355dd26b","modified":1492873980273},{"_id":"public/2016/07/29/CSS系列之双飞翼布局/index.html","hash":"7aa2f421601df0cd2de56d0b957138a6a206e54b","modified":1492873980273},{"_id":"public/2016/09/12/JavaScript详解跨域/index.html","hash":"f30bd13c8c99fc6888a530b7e96c417d0d94c194","modified":1492873980274},{"_id":"public/2016/09/16/JavaScript基本数据结构/index.html","hash":"f5bb1dc58075ce5faae5208c939d3e14c8c37540","modified":1492874324377},{"_id":"public/2017/03/10/简历/index.html","hash":"0f57440f99670e8421ff9b50d3d2975f6bbf8f8b","modified":1492874114079},{"_id":"public/2017/04/22/hello-world/index.html","hash":"b4f1b80ceb87abea8bfd825c94e797f7f124efdd","modified":1492873508979},{"_id":"public/archives/index.html","hash":"239942f8611ae0708c4bfb3b9ed410822f085012","modified":1492874114080},{"_id":"public/archives/page/2/index.html","hash":"d3487397a895081b938a6f32b825412009bbe5d9","modified":1492873801847},{"_id":"public/archives/2016/index.html","hash":"d928992592349d6c135f041306c07a4b0588e4a7","modified":1492873801848},{"_id":"public/archives/2016/page/2/index.html","hash":"03148a60387cd394d6d96dbbf2ce881e90d6098f","modified":1492873801848},{"_id":"public/archives/2016/06/index.html","hash":"a20988b7aca561bbeee91cfa5a7f1c769fad0814","modified":1492873801848},{"_id":"public/archives/2016/07/index.html","hash":"c1e0926555da28371868fea571da11b20823d684","modified":1492873801848},{"_id":"public/archives/2016/08/index.html","hash":"8dbd97b49f12dc90c27c3a33a2ab9dd5f726e720","modified":1492873801849},{"_id":"public/archives/2016/09/index.html","hash":"7c483e113271113042d4c5e0fe02cfcf5ceec771","modified":1492873801850},{"_id":"public/archives/2017/index.html","hash":"334b23ac495c45f74025b31db29a66eee48a22d5","modified":1492874114080},{"_id":"public/archives/2017/03/index.html","hash":"0e4f3b4b13408a2316297a8ee3606eca9efdfe1d","modified":1492874114081},{"_id":"public/archives/2017/04/index.html","hash":"038e74296650693828e115c4c9720dfbebbfc8bd","modified":1492873508981},{"_id":"public/page/2/index.html","hash":"a8bffcceaf5077f5f84c064bc9d9e72ecc3e19d4","modified":1492873801850},{"_id":"public/tags/css/index.html","hash":"0770f8b9774a7aae58e3359d3b9e50337c8a3748","modified":1492873801850},{"_id":"public/tags/布局/index.html","hash":"2d3ec4ab489e64b48b631e7ebf7059a1a16b9319","modified":1492873801850},{"_id":"public/tags/盒模型/index.html","hash":"1863ffcd7b0040b7b5b66b6422ebe9a63d1dc800","modified":1492873801851},{"_id":"public/tags/JavaScript-CORS/index.html","hash":"ce7ee00acaeb18272bb1aa3f2d0bb2eaa5207ebd","modified":1492873801851},{"_id":"public/tags/resume/index.html","hash":"961a8360dabf0e6f5c677644fc52189e3f82a53e","modified":1492874114081},{"_id":"public/2016/07/02/CSS系列之选择器/index.html","hash":"e92cac8edc2603a594552de85fa4f543db7dfa55","modified":1492873980274},{"_id":"public/2016/07/27/css系列之常见布局/index.html","hash":"8d3c0dd8e22130e9d74f3cc6a5bc157fe6461b58","modified":1492873980275},{"_id":"public/2016/08/10/移动web学习笔记/index.html","hash":"6c2759bfff26b7f2cc201a8784983b0e97680311","modified":1492873980275},{"_id":"public/2016/08/25/JavaScript之理解作用域/index.html","hash":"f2ab04ecc594c1c0a63dafc4050d9617f41512ee","modified":1492873980275},{"_id":"public/2016/08/29/JavaScript之深入理解this/index.html","hash":"c05796612d8b985eda6d8b1d360b9e2146df4cd0","modified":1492873980275},{"_id":"public/2016/08/29/JavaScript之理解闭包/index.html","hash":"2fdde459f1bcdcc61aacdaa8c46433509b80d6c8","modified":1492873980275},{"_id":"public/2016/09/04/CSS系列之Flexbox布局/index.html","hash":"114e7167e52cc83b660b078860e3190be4486003","modified":1492873980275},{"_id":"public/2016/09/10/CSS系列之从box-sizing的值谈盒模型/index.html","hash":"7fb126160c474bb484150677e987de0755f12617","modified":1492873980276},{"_id":"public/index.html","hash":"b17a00e5cc74f6f25b7c71ffa956451fbd0b7f4e","modified":1492874324378},{"_id":"public/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1492873508997},{"_id":"public/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1492873508997},{"_id":"public/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1492873508997},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1492873508997},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1492873508997},{"_id":"public/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1492873508997},{"_id":"public/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1492873508997},{"_id":"public/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1492873508997},{"_id":"public/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1492873508997},{"_id":"public/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1492873508998},{"_id":"public/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1492873508998},{"_id":"public/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1492873508998},{"_id":"public/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1492873509014},{"_id":"public/image/reward/alipay.png","hash":"75e0f7d3f804f5ed5f6978ffdc6522224df1b701","modified":1492873509017},{"_id":"public/js/src/bootstrap.js","hash":"c37073db93271410e30dfa9a894fc78a4f025abd","modified":1492873509042},{"_id":"public/js/src/even.js","hash":"9491d0c34812d76d5caf303100b17510ff8f0fc3","modified":1492873509042},{"_id":"public/js/src/search.js","hash":"2670045b8af8150390df1a4f081f8167a5648d67","modified":1492873509042},{"_id":"public/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1492873509042},{"_id":"public/lib/slideout/slideout.min.js","hash":"7166ed307b771398a593fc3d4f1c5d93fbbe19bb","modified":1492873509042},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1492873509042},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1492873509042},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1492873509042},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1492873509043},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1492873509043},{"_id":"public/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1492873509043},{"_id":"public/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1492873509043},{"_id":"public/lib/slideout/slideout.js","hash":"81ec76a63f6f4bbdfc801d822182ab8afa9068fe","modified":1492873509043},{"_id":"public/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1492873509043},{"_id":"public/image/reward/wechat.png","hash":"f9904f25b35fa9d38e221ef7089787d24ee8b02b","modified":1492873509043},{"_id":"public/css/style.css","hash":"7b1a3a7deaa72a2a2f3d66eb60f1ff99cf93b586","modified":1492873509107},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1492873763000},{"_id":"public/tags/JavaScript/index.html","hash":"f5af7ac19e5ae763cd9054a8dcd468f82e7565f5","modified":1492873980310},{"_id":"source/CNAME","hash":"1b6783810ad73819abfa60f5b6da21e3644a4027","modified":1492874379000},{"_id":"public/CNAME","hash":"1b6783810ad73819abfa60f5b6da21e3644a4027","modified":1492874390807}],"Category":[],"Data":[],"Page":[],"Post":[{"date":"2016-09-04T11:44:00.000Z","status":"public","description":"Flex布局背后的主要思想是给容器控制项目（Flex项目）的宽度、高度的能力，使用Flex项目可以自动填满容器的可用空间（主要是适应所有类型的显示设备和屏幕大小）。Flex容器使用Flex项目可以自动放大与收缩，用来填补可用的空闲空间。","title":"CSS系列之Flexbox布局","_content":"\n# Flexbox布局\n\n---\n\n> Flex布局背后的主要思想是给容器控制项目（Flex项目）的宽度、高度的能力，使用Flex项目可以自动填满容器的可用空间（主要是适应所有类型的显示设备和屏幕大小）。Flex容器使用Flex项目可以自动放大与收缩，用来填补可用的空闲空间。\n\n> 最重要的是Flexbox布局的direction-agnostic与常规则布局（块的vertically-based和内联horizontally-based）不同。而那些好的页面缺乏灵活性，特别是方向的改变，大小的调整，伸展，收缩等等。\n\n> **注**：Flexbox布局比较适合Web应用程序的一些小组件和小规模的布局，而Grid布局更适合用于一些大规模的布局。\n\n> 有关于Grid布局模块的中文资料可以点击[这里][1]查阅。\n\n**首先我们得明确两个属性概念,Flex容器属性（container）和Flex项目属性（items）。容器即实现Flex布局的父属性，各项目在父容器内实现各种布局移动。**\n\n## Flex容器属性\n---\n### 1. 为元素开启flex属性\n```\n.container {\n    display: flex;// or inline-flex\n}\n```\n### 2. flex-flow 包含 flex-direction和flex-wrap两个属性。\n    - flex-direction 控制项目是横向排列（row，默认左→右）还是竖向排列（column，默认上→下）同时又可以有反向属性（*-reverse）。\n    - flex-wrap 控制新的一行的堆放方向。默认nowrap即单行显示。wrap即多行显示。\n\n### 3. justify-content 用于**主轴**上项目的对齐伸缩方式。\n图示：\n\n![justify-content][2]\n\n### 4. align-items 用于**侧轴**上项目的对齐伸缩方式\n图示：\n\n![align-items][3]\n\n### 5. align-content 当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，\n**注**：本属性在只有一行的伸缩容器上没有效果。\n\n图示：\n\n![align-content][4]\n\n## FLex项目属性\n\n### order 控制文档项目顺序流（常用于响应式布局中）\n值用number表示。小的在前，大的在后。\n\n### flex 是flex-grow，flex-shrink和flex-basis三个属性的缩写\n- flex-grow 控制项目的尺寸大小，1表示与其他相同尺寸。2表示2倍。（取负值将失效）\n- flex-shrink 控制项目的缩小比例。（取负值将失效）\n- flex-basis \n\n### align-self 用来在单独的伸缩项目上覆写默认的对齐方式\n- auto 默认值，无变化。\n- flex-start:伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边。\n- flex-end:伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。\n- center:伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。\n- baseline:如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。\n- stretch:如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。\n\n\n  [1]: http://www.w3cplus.com/blog/tags/355.html\n  [2]: http://cdn1.w3cplus.com/cdn/farfuture/3_5a61_Q3cMpKIljG_y_BmU3LpJRwGQxvbH2LHO4JHQ/mtime:1430148782/sites/default/files/blogs/2015/1504/justify-content.svg\n  [3]: http://cdn1.w3cplus.com/cdn/farfuture/Q_kuJYRoDp74fyzvT3BipQmDLtALTf_EYgj-RfOP4k0/mtime:1430148782/sites/default/files/blogs/2015/1504/align-items.svg\n  [4]: http://cdn2.w3cplus.com/cdn/farfuture/gRS9e7pjSKPVtrOiW-a0ab-z3R1jVS0QSuRTFNVA_14/mtime:1430148786/sites/default/files/blogs/2015/1504/align-content.svg","source":"_posts/CSS系列之Flexbox布局.md","raw":"---\ndate: 2016-09-04 19:44\nstatus: public\ndescription: Flex布局背后的主要思想是给容器控制项目（Flex项目）的宽度、高度的能力，使用Flex项目可以自动填满容器的可用空间（主要是适应所有类型的显示设备和屏幕大小）。Flex容器使用Flex项目可以自动放大与收缩，用来填补可用的空闲空间。\ntitle: CSS系列之Flexbox布局\n---\n\n# Flexbox布局\n\n---\n\n> Flex布局背后的主要思想是给容器控制项目（Flex项目）的宽度、高度的能力，使用Flex项目可以自动填满容器的可用空间（主要是适应所有类型的显示设备和屏幕大小）。Flex容器使用Flex项目可以自动放大与收缩，用来填补可用的空闲空间。\n\n> 最重要的是Flexbox布局的direction-agnostic与常规则布局（块的vertically-based和内联horizontally-based）不同。而那些好的页面缺乏灵活性，特别是方向的改变，大小的调整，伸展，收缩等等。\n\n> **注**：Flexbox布局比较适合Web应用程序的一些小组件和小规模的布局，而Grid布局更适合用于一些大规模的布局。\n\n> 有关于Grid布局模块的中文资料可以点击[这里][1]查阅。\n\n**首先我们得明确两个属性概念,Flex容器属性（container）和Flex项目属性（items）。容器即实现Flex布局的父属性，各项目在父容器内实现各种布局移动。**\n\n## Flex容器属性\n---\n### 1. 为元素开启flex属性\n```\n.container {\n    display: flex;// or inline-flex\n}\n```\n### 2. flex-flow 包含 flex-direction和flex-wrap两个属性。\n    - flex-direction 控制项目是横向排列（row，默认左→右）还是竖向排列（column，默认上→下）同时又可以有反向属性（*-reverse）。\n    - flex-wrap 控制新的一行的堆放方向。默认nowrap即单行显示。wrap即多行显示。\n\n### 3. justify-content 用于**主轴**上项目的对齐伸缩方式。\n图示：\n\n![justify-content][2]\n\n### 4. align-items 用于**侧轴**上项目的对齐伸缩方式\n图示：\n\n![align-items][3]\n\n### 5. align-content 当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，\n**注**：本属性在只有一行的伸缩容器上没有效果。\n\n图示：\n\n![align-content][4]\n\n## FLex项目属性\n\n### order 控制文档项目顺序流（常用于响应式布局中）\n值用number表示。小的在前，大的在后。\n\n### flex 是flex-grow，flex-shrink和flex-basis三个属性的缩写\n- flex-grow 控制项目的尺寸大小，1表示与其他相同尺寸。2表示2倍。（取负值将失效）\n- flex-shrink 控制项目的缩小比例。（取负值将失效）\n- flex-basis \n\n### align-self 用来在单独的伸缩项目上覆写默认的对齐方式\n- auto 默认值，无变化。\n- flex-start:伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边。\n- flex-end:伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。\n- center:伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。\n- baseline:如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。\n- stretch:如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。\n\n\n  [1]: http://www.w3cplus.com/blog/tags/355.html\n  [2]: http://cdn1.w3cplus.com/cdn/farfuture/3_5a61_Q3cMpKIljG_y_BmU3LpJRwGQxvbH2LHO4JHQ/mtime:1430148782/sites/default/files/blogs/2015/1504/justify-content.svg\n  [3]: http://cdn1.w3cplus.com/cdn/farfuture/Q_kuJYRoDp74fyzvT3BipQmDLtALTf_EYgj-RfOP4k0/mtime:1430148782/sites/default/files/blogs/2015/1504/align-items.svg\n  [4]: http://cdn2.w3cplus.com/cdn/farfuture/gRS9e7pjSKPVtrOiW-a0ab-z3R1jVS0QSuRTFNVA_14/mtime:1430148786/sites/default/files/blogs/2015/1504/align-content.svg","slug":"CSS系列之Flexbox布局","published":1,"updated":"2017-03-29T14:22:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca4m0000ib1ctdz1joos","content":"<h1 id=\"Flexbox布局\"><a href=\"#Flexbox布局\" class=\"headerlink\" title=\"Flexbox布局\"></a>Flexbox布局</h1><hr>\n<blockquote>\n<p>Flex布局背后的主要思想是给容器控制项目（Flex项目）的宽度、高度的能力，使用Flex项目可以自动填满容器的可用空间（主要是适应所有类型的显示设备和屏幕大小）。Flex容器使用Flex项目可以自动放大与收缩，用来填补可用的空闲空间。</p>\n<p>最重要的是Flexbox布局的direction-agnostic与常规则布局（块的vertically-based和内联horizontally-based）不同。而那些好的页面缺乏灵活性，特别是方向的改变，大小的调整，伸展，收缩等等。</p>\n<p><strong>注</strong>：Flexbox布局比较适合Web应用程序的一些小组件和小规模的布局，而Grid布局更适合用于一些大规模的布局。</p>\n<p>有关于Grid布局模块的中文资料可以点击<a href=\"http://www.w3cplus.com/blog/tags/355.html\" target=\"_blank\" rel=\"external\">这里</a>查阅。</p>\n</blockquote>\n<p><strong>首先我们得明确两个属性概念,Flex容器属性（container）和Flex项目属性（items）。容器即实现Flex布局的父属性，各项目在父容器内实现各种布局移动。</strong></p>\n<h2 id=\"Flex容器属性\"><a href=\"#Flex容器属性\" class=\"headerlink\" title=\"Flex容器属性\"></a>Flex容器属性</h2><hr>\n<h3 id=\"1-为元素开启flex属性\"><a href=\"#1-为元素开启flex属性\" class=\"headerlink\" title=\"1. 为元素开启flex属性\"></a>1. 为元素开启flex属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.container &#123;</div><div class=\"line\">    display: flex;// or inline-flex</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-flex-flow-包含-flex-direction和flex-wrap两个属性。\"><a href=\"#2-flex-flow-包含-flex-direction和flex-wrap两个属性。\" class=\"headerlink\" title=\"2. flex-flow 包含 flex-direction和flex-wrap两个属性。\"></a>2. flex-flow 包含 flex-direction和flex-wrap两个属性。</h3><pre><code>- flex-direction 控制项目是横向排列（row，默认左→右）还是竖向排列（column，默认上→下）同时又可以有反向属性（*-reverse）。\n- flex-wrap 控制新的一行的堆放方向。默认nowrap即单行显示。wrap即多行显示。\n</code></pre><h3 id=\"3-justify-content-用于主轴上项目的对齐伸缩方式。\"><a href=\"#3-justify-content-用于主轴上项目的对齐伸缩方式。\" class=\"headerlink\" title=\"3. justify-content 用于主轴上项目的对齐伸缩方式。\"></a>3. justify-content 用于<strong>主轴</strong>上项目的对齐伸缩方式。</h3><p>图示：</p>\n<p><img src=\"http://cdn1.w3cplus.com/cdn/farfuture/3_5a61_Q3cMpKIljG_y_BmU3LpJRwGQxvbH2LHO4JHQ/mtime:1430148782/sites/default/files/blogs/2015/1504/justify-content.svg\" alt=\"justify-content\"></p>\n<h3 id=\"4-align-items-用于侧轴上项目的对齐伸缩方式\"><a href=\"#4-align-items-用于侧轴上项目的对齐伸缩方式\" class=\"headerlink\" title=\"4. align-items 用于侧轴上项目的对齐伸缩方式\"></a>4. align-items 用于<strong>侧轴</strong>上项目的对齐伸缩方式</h3><p>图示：</p>\n<p><img src=\"http://cdn1.w3cplus.com/cdn/farfuture/Q_kuJYRoDp74fyzvT3BipQmDLtALTf_EYgj-RfOP4k0/mtime:1430148782/sites/default/files/blogs/2015/1504/align-items.svg\" alt=\"align-items\"></p>\n<h3 id=\"5-align-content-当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，\"><a href=\"#5-align-content-当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，\" class=\"headerlink\" title=\"5. align-content 当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，\"></a>5. align-content 当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，</h3><p><strong>注</strong>：本属性在只有一行的伸缩容器上没有效果。</p>\n<p>图示：</p>\n<p><img src=\"http://cdn2.w3cplus.com/cdn/farfuture/gRS9e7pjSKPVtrOiW-a0ab-z3R1jVS0QSuRTFNVA_14/mtime:1430148786/sites/default/files/blogs/2015/1504/align-content.svg\" alt=\"align-content\"></p>\n<h2 id=\"FLex项目属性\"><a href=\"#FLex项目属性\" class=\"headerlink\" title=\"FLex项目属性\"></a>FLex项目属性</h2><h3 id=\"order-控制文档项目顺序流（常用于响应式布局中）\"><a href=\"#order-控制文档项目顺序流（常用于响应式布局中）\" class=\"headerlink\" title=\"order 控制文档项目顺序流（常用于响应式布局中）\"></a>order 控制文档项目顺序流（常用于响应式布局中）</h3><p>值用number表示。小的在前，大的在后。</p>\n<h3 id=\"flex-是flex-grow，flex-shrink和flex-basis三个属性的缩写\"><a href=\"#flex-是flex-grow，flex-shrink和flex-basis三个属性的缩写\" class=\"headerlink\" title=\"flex 是flex-grow，flex-shrink和flex-basis三个属性的缩写\"></a>flex 是flex-grow，flex-shrink和flex-basis三个属性的缩写</h3><ul>\n<li>flex-grow 控制项目的尺寸大小，1表示与其他相同尺寸。2表示2倍。（取负值将失效）</li>\n<li>flex-shrink 控制项目的缩小比例。（取负值将失效）</li>\n<li>flex-basis </li>\n</ul>\n<h3 id=\"align-self-用来在单独的伸缩项目上覆写默认的对齐方式\"><a href=\"#align-self-用来在单独的伸缩项目上覆写默认的对齐方式\" class=\"headerlink\" title=\"align-self 用来在单独的伸缩项目上覆写默认的对齐方式\"></a>align-self 用来在单独的伸缩项目上覆写默认的对齐方式</h3><ul>\n<li>auto 默认值，无变化。</li>\n<li>flex-start:伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边。</li>\n<li>flex-end:伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。</li>\n<li>center:伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。</li>\n<li>baseline:如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。</li>\n<li>stretch:如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Flexbox布局\"><a href=\"#Flexbox布局\" class=\"headerlink\" title=\"Flexbox布局\"></a>Flexbox布局</h1><hr>\n<blockquote>\n<p>Flex布局背后的主要思想是给容器控制项目（Flex项目）的宽度、高度的能力，使用Flex项目可以自动填满容器的可用空间（主要是适应所有类型的显示设备和屏幕大小）。Flex容器使用Flex项目可以自动放大与收缩，用来填补可用的空闲空间。</p>\n<p>最重要的是Flexbox布局的direction-agnostic与常规则布局（块的vertically-based和内联horizontally-based）不同。而那些好的页面缺乏灵活性，特别是方向的改变，大小的调整，伸展，收缩等等。</p>\n<p><strong>注</strong>：Flexbox布局比较适合Web应用程序的一些小组件和小规模的布局，而Grid布局更适合用于一些大规模的布局。</p>\n<p>有关于Grid布局模块的中文资料可以点击<a href=\"http://www.w3cplus.com/blog/tags/355.html\">这里</a>查阅。</p>\n</blockquote>\n<p><strong>首先我们得明确两个属性概念,Flex容器属性（container）和Flex项目属性（items）。容器即实现Flex布局的父属性，各项目在父容器内实现各种布局移动。</strong></p>\n<h2 id=\"Flex容器属性\"><a href=\"#Flex容器属性\" class=\"headerlink\" title=\"Flex容器属性\"></a>Flex容器属性</h2><hr>\n<h3 id=\"1-为元素开启flex属性\"><a href=\"#1-为元素开启flex属性\" class=\"headerlink\" title=\"1. 为元素开启flex属性\"></a>1. 为元素开启flex属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.container &#123;</div><div class=\"line\">    display: flex;// or inline-flex</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-flex-flow-包含-flex-direction和flex-wrap两个属性。\"><a href=\"#2-flex-flow-包含-flex-direction和flex-wrap两个属性。\" class=\"headerlink\" title=\"2. flex-flow 包含 flex-direction和flex-wrap两个属性。\"></a>2. flex-flow 包含 flex-direction和flex-wrap两个属性。</h3><pre><code>- flex-direction 控制项目是横向排列（row，默认左→右）还是竖向排列（column，默认上→下）同时又可以有反向属性（*-reverse）。\n- flex-wrap 控制新的一行的堆放方向。默认nowrap即单行显示。wrap即多行显示。\n</code></pre><h3 id=\"3-justify-content-用于主轴上项目的对齐伸缩方式。\"><a href=\"#3-justify-content-用于主轴上项目的对齐伸缩方式。\" class=\"headerlink\" title=\"3. justify-content 用于主轴上项目的对齐伸缩方式。\"></a>3. justify-content 用于<strong>主轴</strong>上项目的对齐伸缩方式。</h3><p>图示：</p>\n<p><img src=\"http://cdn1.w3cplus.com/cdn/farfuture/3_5a61_Q3cMpKIljG_y_BmU3LpJRwGQxvbH2LHO4JHQ/mtime:1430148782/sites/default/files/blogs/2015/1504/justify-content.svg\" alt=\"justify-content\"></p>\n<h3 id=\"4-align-items-用于侧轴上项目的对齐伸缩方式\"><a href=\"#4-align-items-用于侧轴上项目的对齐伸缩方式\" class=\"headerlink\" title=\"4. align-items 用于侧轴上项目的对齐伸缩方式\"></a>4. align-items 用于<strong>侧轴</strong>上项目的对齐伸缩方式</h3><p>图示：</p>\n<p><img src=\"http://cdn1.w3cplus.com/cdn/farfuture/Q_kuJYRoDp74fyzvT3BipQmDLtALTf_EYgj-RfOP4k0/mtime:1430148782/sites/default/files/blogs/2015/1504/align-items.svg\" alt=\"align-items\"></p>\n<h3 id=\"5-align-content-当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，\"><a href=\"#5-align-content-当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，\" class=\"headerlink\" title=\"5. align-content 当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，\"></a>5. align-content 当伸缩容器的侧轴还有多余空间时，用来调准伸缩行在伸缩容器里的对齐方式，</h3><p><strong>注</strong>：本属性在只有一行的伸缩容器上没有效果。</p>\n<p>图示：</p>\n<p><img src=\"http://cdn2.w3cplus.com/cdn/farfuture/gRS9e7pjSKPVtrOiW-a0ab-z3R1jVS0QSuRTFNVA_14/mtime:1430148786/sites/default/files/blogs/2015/1504/align-content.svg\" alt=\"align-content\"></p>\n<h2 id=\"FLex项目属性\"><a href=\"#FLex项目属性\" class=\"headerlink\" title=\"FLex项目属性\"></a>FLex项目属性</h2><h3 id=\"order-控制文档项目顺序流（常用于响应式布局中）\"><a href=\"#order-控制文档项目顺序流（常用于响应式布局中）\" class=\"headerlink\" title=\"order 控制文档项目顺序流（常用于响应式布局中）\"></a>order 控制文档项目顺序流（常用于响应式布局中）</h3><p>值用number表示。小的在前，大的在后。</p>\n<h3 id=\"flex-是flex-grow，flex-shrink和flex-basis三个属性的缩写\"><a href=\"#flex-是flex-grow，flex-shrink和flex-basis三个属性的缩写\" class=\"headerlink\" title=\"flex 是flex-grow，flex-shrink和flex-basis三个属性的缩写\"></a>flex 是flex-grow，flex-shrink和flex-basis三个属性的缩写</h3><ul>\n<li>flex-grow 控制项目的尺寸大小，1表示与其他相同尺寸。2表示2倍。（取负值将失效）</li>\n<li>flex-shrink 控制项目的缩小比例。（取负值将失效）</li>\n<li>flex-basis </li>\n</ul>\n<h3 id=\"align-self-用来在单独的伸缩项目上覆写默认的对齐方式\"><a href=\"#align-self-用来在单独的伸缩项目上覆写默认的对齐方式\" class=\"headerlink\" title=\"align-self 用来在单独的伸缩项目上覆写默认的对齐方式\"></a>align-self 用来在单独的伸缩项目上覆写默认的对齐方式</h3><ul>\n<li>auto 默认值，无变化。</li>\n<li>flex-start:伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边。</li>\n<li>flex-end:伸缩项目在侧轴终点边的外边距靠住该行在侧轴终点的边 。</li>\n<li>center:伸缩项目的外边距盒在该行的侧轴上居中放置。（如果伸缩行的尺寸小于伸缩项目，则伸缩项目会向两个方向溢出相同的量）。</li>\n<li>baseline:如果伸缩项目的行内轴与侧轴为同一条，则该值和flex-start等效。其它情况下，该值将参与基线对齐。所有参与该对齐方式的伸缩项目将按下列方式排列：首先将这些伸缩项目的基线进行对齐，随后其中基线至侧轴起点边的外边距距离最长的那个项目将紧靠住该行在侧轴起点的边。</li>\n<li>stretch:如果侧轴长度属性的值为auto，则此值会使项目的外边距盒的尺寸在遵照min/max-width/height属性的限制下尽可能接近所在行的尺寸。</li>\n</ul>\n"},{"date":"2016-07-29T10:37:00.000Z","status":"public","description":"css经典双飞翼布局","title":"CSS系列之双飞翼布局","_content":"## 概念\n\n理解了上篇文章的圣杯布局，再来学习双飞翼布局就简单许多了。同样引用上次的元素命名。\n\n**圣杯布局**是给包裹着三栏的`container`加一个`padding`,让 padding-left 和 padding-right 的数值是左栏和右栏的宽度，然后利用相对定位把他们再移动在两旁。\n\n而**双飞翼布局**是在`center` **里面**再添加一个`div`，然后对这个`div`进行 margin-left 和 margin-right,即：\n\n\t<div id=\"header\"></div>\n    <div id=\"container\">\n        <div id=\"center\" class=\"column\">\n        \t<div class=\"wrap\"></div>\n        </div>\n        <div id=\"left\" class=\"column\"></div>\n\t\t<div id=\"right\" class=\"column\"></div>\n    </div>\n\t<div id=\"footer\"></div>\n\n`wrap`的 css 部分：\n\n```\n.wrap {\n    margin-left: 200px;\n    margin-right: 150px;\n}\n```\n\n其他部分和圣杯布局都是一样的。它们要实现的样式都是下面的这种形式：\n![](https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/7554325/13628574/2e28562c-e60e-11e5-9bae-905c4c7bf56a.png&objectId=1190000004579886&token=9bb8b342939860ca25c504a051283e89)\n\n**参考文章：**[那些年，奇妙的圣杯和双飞翼](https://segmentfault.com/a/1190000004579886)","source":"_posts/CSS系列之双飞翼布局.md","raw":"---\ndate: 2016-07-29 18:37\nstatus: public\ntags: [ css, 布局]\ndescription: css经典双飞翼布局\ntitle: CSS系列之双飞翼布局\n---\n## 概念\n\n理解了上篇文章的圣杯布局，再来学习双飞翼布局就简单许多了。同样引用上次的元素命名。\n\n**圣杯布局**是给包裹着三栏的`container`加一个`padding`,让 padding-left 和 padding-right 的数值是左栏和右栏的宽度，然后利用相对定位把他们再移动在两旁。\n\n而**双飞翼布局**是在`center` **里面**再添加一个`div`，然后对这个`div`进行 margin-left 和 margin-right,即：\n\n\t<div id=\"header\"></div>\n    <div id=\"container\">\n        <div id=\"center\" class=\"column\">\n        \t<div class=\"wrap\"></div>\n        </div>\n        <div id=\"left\" class=\"column\"></div>\n\t\t<div id=\"right\" class=\"column\"></div>\n    </div>\n\t<div id=\"footer\"></div>\n\n`wrap`的 css 部分：\n\n```\n.wrap {\n    margin-left: 200px;\n    margin-right: 150px;\n}\n```\n\n其他部分和圣杯布局都是一样的。它们要实现的样式都是下面的这种形式：\n![](https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/7554325/13628574/2e28562c-e60e-11e5-9bae-905c4c7bf56a.png&objectId=1190000004579886&token=9bb8b342939860ca25c504a051283e89)\n\n**参考文章：**[那些年，奇妙的圣杯和双飞翼](https://segmentfault.com/a/1190000004579886)","slug":"CSS系列之双飞翼布局","published":1,"updated":"2016-11-10T15:15:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca4v0001ib1ca3d74q20","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>理解了上篇文章的圣杯布局，再来学习双飞翼布局就简单许多了。同样引用上次的元素命名。</p>\n<p><strong>圣杯布局</strong>是给包裹着三栏的<code>container</code>加一个<code>padding</code>,让 padding-left 和 padding-right 的数值是左栏和右栏的宽度，然后利用相对定位把他们再移动在两旁。</p>\n<p>而<strong>双飞翼布局</strong>是在<code>center</code> <strong>里面</strong>再添加一个<code>div</code>，然后对这个<code>div</code>进行 margin-left 和 margin-right,即：</p>\n<pre><code>&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;container&quot;&gt;\n    &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;\n        &lt;div class=&quot;wrap&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;\n</code></pre><p><code>wrap</code>的 css 部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrap &#123;</div><div class=\"line\">    margin-left: 200px;</div><div class=\"line\">    margin-right: 150px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其他部分和圣杯布局都是一样的。它们要实现的样式都是下面的这种形式：<br><img src=\"https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/7554325/13628574/2e28562c-e60e-11e5-9bae-905c4c7bf56a.png&amp;objectId=1190000004579886&amp;token=9bb8b342939860ca25c504a051283e89\" alt=\"\"></p>\n<p><strong>参考文章：</strong><a href=\"https://segmentfault.com/a/1190000004579886\" target=\"_blank\" rel=\"external\">那些年，奇妙的圣杯和双飞翼</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>理解了上篇文章的圣杯布局，再来学习双飞翼布局就简单许多了。同样引用上次的元素命名。</p>\n<p><strong>圣杯布局</strong>是给包裹着三栏的<code>container</code>加一个<code>padding</code>,让 padding-left 和 padding-right 的数值是左栏和右栏的宽度，然后利用相对定位把他们再移动在两旁。</p>\n<p>而<strong>双飞翼布局</strong>是在<code>center</code> <strong>里面</strong>再添加一个<code>div</code>，然后对这个<code>div</code>进行 margin-left 和 margin-right,即：</p>\n<pre><code>&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;container&quot;&gt;\n    &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;\n        &lt;div class=&quot;wrap&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;\n</code></pre><p><code>wrap</code>的 css 部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrap &#123;</div><div class=\"line\">    margin-left: 200px;</div><div class=\"line\">    margin-right: 150px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其他部分和圣杯布局都是一样的。它们要实现的样式都是下面的这种形式：<br><img src=\"https://segmentfault.com/image?src=https://cloud.githubusercontent.com/assets/7554325/13628574/2e28562c-e60e-11e5-9bae-905c4c7bf56a.png&amp;objectId=1190000004579886&amp;token=9bb8b342939860ca25c504a051283e89\" alt=\"\"></p>\n<p><strong>参考文章：</strong><a href=\"https://segmentfault.com/a/1190000004579886\">那些年，奇妙的圣杯和双飞翼</a></p>\n"},{"date":"2016-09-09T16:00:00.000Z","status":"public","description":"在**标准模式**下，浏览器按照W3C标准对文档进行解析和渲染；而在**怪异模式**下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。","title":"CSS系列之从box-sizing的值谈浏览器的渲染模式","_content":"\n## 标准模式与怪异模式\n在**标准模式**下，浏览器按照W3C标准对文档进行解析和渲染；而在**怪异模式**下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。\n\n这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。\n\n那浏览器根据什么来判断 采用哪种模式来渲染打开的网页呢？答案是我们经常在HTML头部看到的DOCTYPE；\n\n## <!DOCTYPE>\n### 定义\n\n- DOCTYPE是Document Type（文档类型）的简写，用来告知浏览器该文档使用哪种 HTML 或 XHTML 规范；\n- 不属于HTML或XHTML标签，是一种声明，不需要闭合；\n- 必须位于HTML或XHTML文档第一行；\n- 大小写不敏感；\n- 所有浏览器都支持<!DOCTYPE>声明\n\n### 用法\n<!DOCTYPE html\n\nPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\n以上代码\n\n第一行：声明文档的根元素是 html，\n\n第二行：在公共标识符被定义为 \"-//W3C//DTD XHTML 1.0 Strict//EN\" 的 DTD 中进行了定义，浏览器将明白如何寻找匹配此公共标识符的 DTD，\n\n第三行：如果浏览器匹配不到第二行中的标识符，浏览器将使用公共标识符后面的 URL 作为寻找 **DTD** （文档类型定义，规定了标记语言的规则，这样浏览器才能正确地呈现内容）的位置。\n\n### 常用的 DOCTYPE 声明\n*   HTML 5\n     <!DOCTYPE html>\n\n *  HTML 4.01 Strict\n \n     该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n\n *  HTML 4.01 Transitional\n \n     该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"  \"http://www.w3.org/TR/html4/loose.dtd\">\n\n *  HTML 4.01 Frameset\n \n     该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\"  \"http://www.w3.org/TR/html4/frameset.dtd\">\n\n *  XHTML 1.0 Strict\n \n     该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\n *  XHTML 1.0 Transitional\n \n     该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n *  XHTML 1.0 Frameset\n \n     该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\n\n *  XHTML 1.1\n \n     该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\n### HTML5 为什么声明这么短\nHTML4.01 DOCTYPE需要对 DTD 进行引用，是因为 HTML4.01基于 SGML，而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为。至于 DTD 和 SGML 具体是什么，可以看这两段描述:\n>\n- DTD is a set of markup declarations that define a document type for an SGML-family markup language (SGML, XML, HTML). A Document Type Definition (DTD) defines the legal building blocks of an XML document. It defines the document structure with a list of legal elements and attributes.\n- SGML is a standard for how to specify a document markup language or tag set. Such a specification is itself a document type definition (DTD). SGML is not in itself a document language, but a description of how to specify one. It is metadata.\n\n## box-sizing的两个值\nbox-sizing有两个值一个是content-box，另一个是border-box。\n\n- 当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；\n\n- 当设置为box-sizing:border-box时，将采用怪异模式解析计算；\n\n为了理解，我们写个例子：\n一个div我们加上这些属性\n\n```\ndiv {\n     background-color: red;\n    width: 300px;\n    height: 300px;\n    margin: 50px;\n    padding: 50px;\n    border: 20px solid;\n}\n```\n这时的box-sizing默认为content-box；这个div的width = 300 + 50\\*2 + 20\\*2 = 440px; height亦然。而它的盒子模型的总宽度是 width + 50\\*2 = 540px;\n\n```\ndiv {\n    ...\n    ...\n    box-sizing: border-box;\n}\n```\n\n而我们给它的box-sizing属性设为 border-box时，盒子模型的计算方式发生改变。这时这个div的width = 300px。而它的盒子模型的总宽度是 width + 50\\*2 = 400px;\n\n言而总之就是 怪异模式的 盒子模型的宽度/高度 是包括 padding 和 border 的宽和高的，你给它设置了一定的宽高，无论里面的padding、border宽高怎么变，盒子的width和height一直是你设置的值而不会撑大。\n\n\n### 参考文档：\n\n- [CSS盒模型全面讲解，怪异模式盒模型，CSS3 box-sizing属性](http://www.cnblogs.com/slp-qm/p/5611268.html)\n- [HTML5中回归简单的<!DOCTYPE>声明](http://lib.csdn.net/article/html5/14445)","source":"_posts/CSS系列之从box-sizing的值谈盒模型.md","raw":"---\ndate: 2016-09-10\nstatus: public\ntags: [css, 盒模型]\ndescription: 在**标准模式**下，浏览器按照W3C标准对文档进行解析和渲染；而在**怪异模式**下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。\ntitle: CSS系列之从box-sizing的值谈浏览器的渲染模式\n\n---\n\n## 标准模式与怪异模式\n在**标准模式**下，浏览器按照W3C标准对文档进行解析和渲染；而在**怪异模式**下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。\n\n这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。\n\n那浏览器根据什么来判断 采用哪种模式来渲染打开的网页呢？答案是我们经常在HTML头部看到的DOCTYPE；\n\n## <!DOCTYPE>\n### 定义\n\n- DOCTYPE是Document Type（文档类型）的简写，用来告知浏览器该文档使用哪种 HTML 或 XHTML 规范；\n- 不属于HTML或XHTML标签，是一种声明，不需要闭合；\n- 必须位于HTML或XHTML文档第一行；\n- 大小写不敏感；\n- 所有浏览器都支持<!DOCTYPE>声明\n\n### 用法\n<!DOCTYPE html\n\nPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\n以上代码\n\n第一行：声明文档的根元素是 html，\n\n第二行：在公共标识符被定义为 \"-//W3C//DTD XHTML 1.0 Strict//EN\" 的 DTD 中进行了定义，浏览器将明白如何寻找匹配此公共标识符的 DTD，\n\n第三行：如果浏览器匹配不到第二行中的标识符，浏览器将使用公共标识符后面的 URL 作为寻找 **DTD** （文档类型定义，规定了标记语言的规则，这样浏览器才能正确地呈现内容）的位置。\n\n### 常用的 DOCTYPE 声明\n*   HTML 5\n     <!DOCTYPE html>\n\n *  HTML 4.01 Strict\n \n     该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n\n *  HTML 4.01 Transitional\n \n     该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"  \"http://www.w3.org/TR/html4/loose.dtd\">\n\n *  HTML 4.01 Frameset\n \n     该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\"  \"http://www.w3.org/TR/html4/frameset.dtd\">\n\n *  XHTML 1.0 Strict\n \n     该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n\n *  XHTML 1.0 Transitional\n \n     该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n *  XHTML 1.0 Frameset\n \n     该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\n\n *  XHTML 1.1\n \n     该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n\n### HTML5 为什么声明这么短\nHTML4.01 DOCTYPE需要对 DTD 进行引用，是因为 HTML4.01基于 SGML，而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为。至于 DTD 和 SGML 具体是什么，可以看这两段描述:\n>\n- DTD is a set of markup declarations that define a document type for an SGML-family markup language (SGML, XML, HTML). A Document Type Definition (DTD) defines the legal building blocks of an XML document. It defines the document structure with a list of legal elements and attributes.\n- SGML is a standard for how to specify a document markup language or tag set. Such a specification is itself a document type definition (DTD). SGML is not in itself a document language, but a description of how to specify one. It is metadata.\n\n## box-sizing的两个值\nbox-sizing有两个值一个是content-box，另一个是border-box。\n\n- 当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；\n\n- 当设置为box-sizing:border-box时，将采用怪异模式解析计算；\n\n为了理解，我们写个例子：\n一个div我们加上这些属性\n\n```\ndiv {\n     background-color: red;\n    width: 300px;\n    height: 300px;\n    margin: 50px;\n    padding: 50px;\n    border: 20px solid;\n}\n```\n这时的box-sizing默认为content-box；这个div的width = 300 + 50\\*2 + 20\\*2 = 440px; height亦然。而它的盒子模型的总宽度是 width + 50\\*2 = 540px;\n\n```\ndiv {\n    ...\n    ...\n    box-sizing: border-box;\n}\n```\n\n而我们给它的box-sizing属性设为 border-box时，盒子模型的计算方式发生改变。这时这个div的width = 300px。而它的盒子模型的总宽度是 width + 50\\*2 = 400px;\n\n言而总之就是 怪异模式的 盒子模型的宽度/高度 是包括 padding 和 border 的宽和高的，你给它设置了一定的宽高，无论里面的padding、border宽高怎么变，盒子的width和height一直是你设置的值而不会撑大。\n\n\n### 参考文档：\n\n- [CSS盒模型全面讲解，怪异模式盒模型，CSS3 box-sizing属性](http://www.cnblogs.com/slp-qm/p/5611268.html)\n- [HTML5中回归简单的<!DOCTYPE>声明](http://lib.csdn.net/article/html5/14445)","slug":"CSS系列之从box-sizing的值谈盒模型","published":1,"updated":"2017-04-22T15:09:21.000Z","_id":"cj1teca500002ib1csry0zhvk","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"标准模式与怪异模式\"><a href=\"#标准模式与怪异模式\" class=\"headerlink\" title=\"标准模式与怪异模式\"></a>标准模式与怪异模式</h2><p>在<strong>标准模式</strong>下，浏览器按照W3C标准对文档进行解析和渲染；而在<strong>怪异模式</strong>下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。</p>\n<p>这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。</p>\n<p>那浏览器根据什么来判断 采用哪种模式来渲染打开的网页呢？答案是我们经常在HTML头部看到的DOCTYPE；</p>\n<h2 id=\"lt-DOCTYPE-gt\"><a href=\"#lt-DOCTYPE-gt\" class=\"headerlink\" title=\"&lt;!DOCTYPE&gt;\"></a>&lt;!DOCTYPE&gt;</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>DOCTYPE是Document Type（文档类型）的简写，用来告知浏览器该文档使用哪种 HTML 或 XHTML 规范；</li>\n<li>不属于HTML或XHTML标签，是一种声明，不需要闭合；</li>\n<li>必须位于HTML或XHTML文档第一行；</li>\n<li>大小写不敏感；</li>\n<li>所有浏览器都支持&lt;!DOCTYPE&gt;声明</li>\n</ul>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>&lt;!DOCTYPE html</p>\n<p>PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN”</p>\n<p>“<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;\" target=\"_blank\" rel=\"external\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a></p>\n<p>以上代码</p>\n<p>第一行：声明文档的根元素是 html，</p>\n<p>第二行：在公共标识符被定义为 “-//W3C//DTD XHTML 1.0 Strict//EN” 的 DTD 中进行了定义，浏览器将明白如何寻找匹配此公共标识符的 DTD，</p>\n<p>第三行：如果浏览器匹配不到第二行中的标识符，浏览器将使用公共标识符后面的 URL 作为寻找 <strong>DTD</strong> （文档类型定义，规定了标记语言的规则，这样浏览器才能正确地呈现内容）的位置。</p>\n<h3 id=\"常用的-DOCTYPE-声明\"><a href=\"#常用的-DOCTYPE-声明\" class=\"headerlink\" title=\"常用的 DOCTYPE 声明\"></a>常用的 DOCTYPE 声明</h3><ul>\n<li><p>HTML 5<br> &lt;!DOCTYPE html&gt;</p>\n<ul>\n<li><p>HTML 4.01 Strict</p>\n<p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。<br>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href=\"http://www.w3.org/TR/html4/strict.dtd&quot;&gt;\" target=\"_blank\" rel=\"external\">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a></p>\n</li>\n<li><p>HTML 4.01 Transitional</p>\n<p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。<br>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”  “<a href=\"http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\" target=\"_blank\" rel=\"external\">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a></p>\n</li>\n<li><p>HTML 4.01 Frameset</p>\n<p>该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。<br>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Frameset//EN”  “<a href=\"http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;\" target=\"_blank\" rel=\"external\">http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</a></p>\n</li>\n<li><p>XHTML 1.0 Strict</p>\n<p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。<br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN”  “<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;\" target=\"_blank\" rel=\"external\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a></p>\n</li>\n<li><p>XHTML 1.0 Transitional</p>\n<p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。<br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”  “<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\" target=\"_blank\" rel=\"external\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a></p>\n</li>\n<li><p>XHTML 1.0 Frameset</p>\n<p>该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。<br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN”  “<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;\" target=\"_blank\" rel=\"external\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</a></p>\n</li>\n<li><p>XHTML 1.1</p>\n<p>该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。<br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.1//EN” “<a href=\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\" target=\"_blank\" rel=\"external\">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTML5-为什么声明这么短\"><a href=\"#HTML5-为什么声明这么短\" class=\"headerlink\" title=\"HTML5 为什么声明这么短\"></a>HTML5 为什么声明这么短</h3><p>HTML4.01 DOCTYPE需要对 DTD 进行引用，是因为 HTML4.01基于 SGML，而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为。至于 DTD 和 SGML 具体是什么，可以看这两段描述:<br>&gt;</p>\n<ul>\n<li>DTD is a set of markup declarations that define a document type for an SGML-family markup language (SGML, XML, HTML). A Document Type Definition (DTD) defines the legal building blocks of an XML document. It defines the document structure with a list of legal elements and attributes.</li>\n<li>SGML is a standard for how to specify a document markup language or tag set. Such a specification is itself a document type definition (DTD). SGML is not in itself a document language, but a description of how to specify one. It is metadata.</li>\n</ul>\n<h2 id=\"box-sizing的两个值\"><a href=\"#box-sizing的两个值\" class=\"headerlink\" title=\"box-sizing的两个值\"></a>box-sizing的两个值</h2><p>box-sizing有两个值一个是content-box，另一个是border-box。</p>\n<ul>\n<li><p>当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；</p>\n</li>\n<li><p>当设置为box-sizing:border-box时，将采用怪异模式解析计算；</p>\n</li>\n</ul>\n<p>为了理解，我们写个例子：<br>一个div我们加上这些属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">div &#123;</div><div class=\"line\">     background-color: red;</div><div class=\"line\">    width: 300px;</div><div class=\"line\">    height: 300px;</div><div class=\"line\">    margin: 50px;</div><div class=\"line\">    padding: 50px;</div><div class=\"line\">    border: 20px solid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这时的box-sizing默认为content-box；这个div的width = 300 + 50*2 + 20*2 = 440px; height亦然。而它的盒子模型的总宽度是 width + 50*2 = 540px;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">div &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    ...</div><div class=\"line\">    box-sizing: border-box;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而我们给它的box-sizing属性设为 border-box时，盒子模型的计算方式发生改变。这时这个div的width = 300px。而它的盒子模型的总宽度是 width + 50*2 = 400px;</p>\n<p>言而总之就是 怪异模式的 盒子模型的宽度/高度 是包括 padding 和 border 的宽和高的，你给它设置了一定的宽高，无论里面的padding、border宽高怎么变，盒子的width和height一直是你设置的值而不会撑大。</p>\n<h3 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h3><ul>\n<li><a href=\"http://www.cnblogs.com/slp-qm/p/5611268.html\" target=\"_blank\" rel=\"external\">CSS盒模型全面讲解，怪异模式盒模型，CSS3 box-sizing属性</a></li>\n<li><a href=\"http://lib.csdn.net/article/html5/14445\" target=\"_blank\" rel=\"external\">HTML5中回归简单的&lt;!DOCTYPE&gt;声明</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"标准模式与怪异模式\"><a href=\"#标准模式与怪异模式\" class=\"headerlink\" title=\"标准模式与怪异模式\"></a>标准模式与怪异模式</h2><p>在<strong>标准模式</strong>下，浏览器按照W3C标准对文档进行解析和渲染；而在<strong>怪异模式</strong>下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。</p>\n<p>这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。</p>\n<p>那浏览器根据什么来判断 采用哪种模式来渲染打开的网页呢？答案是我们经常在HTML头部看到的DOCTYPE；</p>\n<h2 id=\"lt-DOCTYPE-gt\"><a href=\"#lt-DOCTYPE-gt\" class=\"headerlink\" title=\"&lt;!DOCTYPE&gt;\"></a>&lt;!DOCTYPE&gt;</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>DOCTYPE是Document Type（文档类型）的简写，用来告知浏览器该文档使用哪种 HTML 或 XHTML 规范；</li>\n<li>不属于HTML或XHTML标签，是一种声明，不需要闭合；</li>\n<li>必须位于HTML或XHTML文档第一行；</li>\n<li>大小写不敏感；</li>\n<li>所有浏览器都支持&lt;!DOCTYPE&gt;声明</li>\n</ul>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>&lt;!DOCTYPE html</p>\n<p>PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN”</p>\n<p>“<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a></p>\n<p>以上代码</p>\n<p>第一行：声明文档的根元素是 html，</p>\n<p>第二行：在公共标识符被定义为 “-//W3C//DTD XHTML 1.0 Strict//EN” 的 DTD 中进行了定义，浏览器将明白如何寻找匹配此公共标识符的 DTD，</p>\n<p>第三行：如果浏览器匹配不到第二行中的标识符，浏览器将使用公共标识符后面的 URL 作为寻找 <strong>DTD</strong> （文档类型定义，规定了标记语言的规则，这样浏览器才能正确地呈现内容）的位置。</p>\n<h3 id=\"常用的-DOCTYPE-声明\"><a href=\"#常用的-DOCTYPE-声明\" class=\"headerlink\" title=\"常用的 DOCTYPE 声明\"></a>常用的 DOCTYPE 声明</h3><ul>\n<li><p>HTML 5<br> &lt;!DOCTYPE html&gt;</p>\n<ul>\n<li><p>HTML 4.01 Strict</p>\n<p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。<br>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href=\"http://www.w3.org/TR/html4/strict.dtd&quot;&gt;\">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a></p>\n</li>\n<li><p>HTML 4.01 Transitional</p>\n<p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。<br>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”  “<a href=\"http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a></p>\n</li>\n<li><p>HTML 4.01 Frameset</p>\n<p>该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。<br>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Frameset//EN”  “<a href=\"http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;\">http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</a></p>\n</li>\n<li><p>XHTML 1.0 Strict</p>\n<p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。<br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN”  “<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a></p>\n</li>\n<li><p>XHTML 1.0 Transitional</p>\n<p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。<br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”  “<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</a></p>\n</li>\n<li><p>XHTML 1.0 Frameset</p>\n<p>该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。<br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Frameset//EN”  “<a href=\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</a></p>\n</li>\n<li><p>XHTML 1.1</p>\n<p>该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。<br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.1//EN” “<a href=\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</a></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTML5-为什么声明这么短\"><a href=\"#HTML5-为什么声明这么短\" class=\"headerlink\" title=\"HTML5 为什么声明这么短\"></a>HTML5 为什么声明这么短</h3><p>HTML4.01 DOCTYPE需要对 DTD 进行引用，是因为 HTML4.01基于 SGML，而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为。至于 DTD 和 SGML 具体是什么，可以看这两段描述:<br>&gt;</p>\n<ul>\n<li>DTD is a set of markup declarations that define a document type for an SGML-family markup language (SGML, XML, HTML). A Document Type Definition (DTD) defines the legal building blocks of an XML document. It defines the document structure with a list of legal elements and attributes.</li>\n<li>SGML is a standard for how to specify a document markup language or tag set. Such a specification is itself a document type definition (DTD). SGML is not in itself a document language, but a description of how to specify one. It is metadata.</li>\n</ul>\n<h2 id=\"box-sizing的两个值\"><a href=\"#box-sizing的两个值\" class=\"headerlink\" title=\"box-sizing的两个值\"></a>box-sizing的两个值</h2><p>box-sizing有两个值一个是content-box，另一个是border-box。</p>\n<ul>\n<li><p>当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；</p>\n</li>\n<li><p>当设置为box-sizing:border-box时，将采用怪异模式解析计算；</p>\n</li>\n</ul>\n<p>为了理解，我们写个例子：<br>一个div我们加上这些属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">div &#123;</div><div class=\"line\">     background-color: red;</div><div class=\"line\">    width: 300px;</div><div class=\"line\">    height: 300px;</div><div class=\"line\">    margin: 50px;</div><div class=\"line\">    padding: 50px;</div><div class=\"line\">    border: 20px solid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这时的box-sizing默认为content-box；这个div的width = 300 + 50*2 + 20*2 = 440px; height亦然。而它的盒子模型的总宽度是 width + 50*2 = 540px;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">div &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    ...</div><div class=\"line\">    box-sizing: border-box;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而我们给它的box-sizing属性设为 border-box时，盒子模型的计算方式发生改变。这时这个div的width = 300px。而它的盒子模型的总宽度是 width + 50*2 = 400px;</p>\n<p>言而总之就是 怪异模式的 盒子模型的宽度/高度 是包括 padding 和 border 的宽和高的，你给它设置了一定的宽高，无论里面的padding、border宽高怎么变，盒子的width和height一直是你设置的值而不会撑大。</p>\n<h3 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h3><ul>\n<li><a href=\"http://www.cnblogs.com/slp-qm/p/5611268.html\">CSS盒模型全面讲解，怪异模式盒模型，CSS3 box-sizing属性</a></li>\n<li><a href=\"http://lib.csdn.net/article/html5/14445\">HTML5中回归简单的&lt;!DOCTYPE&gt;声明</a></li>\n</ul>\n"},{"date":"2016-06-06T11:45:00.000Z","status":"public","description":"对Cousera上的全栈课程做个简单笔记","title":"Coursera全栈课程学习笔记","_content":"\n# What is Full Stack Web Development?\n\n\n\n---\n![](http://e.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=169594ccee50352ab56121096373c083/0824ab18972bd407199c48867c899e510fb30975.jpg)\n---\n## *Front end and Back end*\n- **Front end/Client-side**\n    — HTML,CSS and Javascript\n- **Back end/Sever-side**\n    — Various technologies and approaches\n    — PHP,Java,Asp.NET,Ruby,Python \n\n---\n![](http://f.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=266af5feceea15ce45eee40886300182/dcc451da81cb39db93acfc2dd7160924ab183058.jpg)\n---\n\n## *Three Tier Architecture*\n#### Full stack\n    1. Presentation layer (Concerned with UI related issues)\n    2. Business Logic layer (Data validation dynamic content processing)\n    3. Data Access layer (Data persistence data access through an API)\n## *Full Stack Javascript Development*\n 示意图：\n    ![file-list](http://e.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=301499e359df8db1b82e78653913e625/a8014c086e061d95660faf437cf40ad162d9ca04.jpg)\n\n\n## *Foundation for Responsive Design*\n\n - Grid system\n    --  We'll deal with Bootstrap Grid system next\n - Fluid images\n    -- We'll look at Bootsrap support later\n - Media queries\n\n### *Grid*\n- Bootstrap makes available four classes\n    - xs for extra small\n    - sm for small\n    - md for medium,and\n    - lg for large screen sizes\n- Each row in Bootstrap grid system is divided into 12 columns\n- Use the classes .col-xs-\",.col-sm-\",col-md-\",and .col-lg-\" for defining the layouts for the various screen sizes\n- Specify how many columns each piece of content will occupy within a row,all adding up to 12 or a multiple thereof\n\n\n    - pull and push \n    - offset\n    - ne\n    \n---\n- Bootstrap\n- Web Tools:\n        — Node.js and NPM\n        — Bower\n\n---\n\n## Bootstraps Overview\n\n- Responsive Design and Bootstrap Grid System\n\n- Navigation and Navigation Bar \n\n## Bootstrap CSS Components\n\n- Tabs,Pill and Tabbed Navigation\n- Hide and Seek:Collapse,Accordion,Scrollspy and affix\n- revealing Content:Tooltips,Popovers and Modals\n\n## Web Tools\n\n- Bootstrap and JQuery\n- Node.js and Node Package Manager\n- Less id More！: Less and Sass\n- Web Tools: Bower\n","source":"_posts/Coursera全栈课程学习笔记.md","raw":"---\ndate: 2016-06-06 19:45\nstatus: public\ndescription: 对Cousera上的全栈课程做个简单笔记\ntitle: Coursera全栈课程学习笔记\n---\n\n# What is Full Stack Web Development?\n\n\n\n---\n![](http://e.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=169594ccee50352ab56121096373c083/0824ab18972bd407199c48867c899e510fb30975.jpg)\n---\n## *Front end and Back end*\n- **Front end/Client-side**\n    — HTML,CSS and Javascript\n- **Back end/Sever-side**\n    — Various technologies and approaches\n    — PHP,Java,Asp.NET,Ruby,Python \n\n---\n![](http://f.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=266af5feceea15ce45eee40886300182/dcc451da81cb39db93acfc2dd7160924ab183058.jpg)\n---\n\n## *Three Tier Architecture*\n#### Full stack\n    1. Presentation layer (Concerned with UI related issues)\n    2. Business Logic layer (Data validation dynamic content processing)\n    3. Data Access layer (Data persistence data access through an API)\n## *Full Stack Javascript Development*\n 示意图：\n    ![file-list](http://e.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=301499e359df8db1b82e78653913e625/a8014c086e061d95660faf437cf40ad162d9ca04.jpg)\n\n\n## *Foundation for Responsive Design*\n\n - Grid system\n    --  We'll deal with Bootstrap Grid system next\n - Fluid images\n    -- We'll look at Bootsrap support later\n - Media queries\n\n### *Grid*\n- Bootstrap makes available four classes\n    - xs for extra small\n    - sm for small\n    - md for medium,and\n    - lg for large screen sizes\n- Each row in Bootstrap grid system is divided into 12 columns\n- Use the classes .col-xs-\",.col-sm-\",col-md-\",and .col-lg-\" for defining the layouts for the various screen sizes\n- Specify how many columns each piece of content will occupy within a row,all adding up to 12 or a multiple thereof\n\n\n    - pull and push \n    - offset\n    - ne\n    \n---\n- Bootstrap\n- Web Tools:\n        — Node.js and NPM\n        — Bower\n\n---\n\n## Bootstraps Overview\n\n- Responsive Design and Bootstrap Grid System\n\n- Navigation and Navigation Bar \n\n## Bootstrap CSS Components\n\n- Tabs,Pill and Tabbed Navigation\n- Hide and Seek:Collapse,Accordion,Scrollspy and affix\n- revealing Content:Tooltips,Popovers and Modals\n\n## Web Tools\n\n- Bootstrap and JQuery\n- Node.js and Node Package Manager\n- Less id More！: Less and Sass\n- Web Tools: Bower\n","slug":"Coursera全栈课程学习笔记","published":1,"updated":"2017-03-29T14:25:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca5c0004ib1c9k6i80iz","content":"<h1 id=\"What-is-Full-Stack-Web-Development\"><a href=\"#What-is-Full-Stack-Web-Development\" class=\"headerlink\" title=\"What is Full Stack Web Development?\"></a>What is Full Stack Web Development?</h1><hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://e.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=169594ccee50352ab56121096373c083/0824ab18972bd407199c48867c899e510fb30975.jpg\" alt=\"\"></h2><h2 id=\"Front-end-and-Back-end\"><a href=\"#Front-end-and-Back-end\" class=\"headerlink\" title=\"Front end and Back end\"></a><em>Front end and Back end</em></h2><ul>\n<li><strong>Front end/Client-side</strong><br>  — HTML,CSS and Javascript</li>\n<li><strong>Back end/Sever-side</strong><br>  — Various technologies and approaches<br>  — PHP,Java,Asp.NET,Ruby,Python </li>\n</ul>\n<hr>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><img src=\"http://f.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=266af5feceea15ce45eee40886300182/dcc451da81cb39db93acfc2dd7160924ab183058.jpg\" alt=\"\"></h2><h2 id=\"Three-Tier-Architecture\"><a href=\"#Three-Tier-Architecture\" class=\"headerlink\" title=\"Three Tier Architecture\"></a><em>Three Tier Architecture</em></h2><h4 id=\"Full-stack\"><a href=\"#Full-stack\" class=\"headerlink\" title=\"Full stack\"></a>Full stack</h4><pre><code>1. Presentation layer (Concerned with UI related issues)\n2. Business Logic layer (Data validation dynamic content processing)\n3. Data Access layer (Data persistence data access through an API)\n</code></pre><h2 id=\"Full-Stack-Javascript-Development\"><a href=\"#Full-Stack-Javascript-Development\" class=\"headerlink\" title=\"Full Stack Javascript Development\"></a><em>Full Stack Javascript Development</em></h2><p> 示意图：<br>    <img src=\"http://e.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=301499e359df8db1b82e78653913e625/a8014c086e061d95660faf437cf40ad162d9ca04.jpg\" alt=\"file-list\"></p>\n<h2 id=\"Foundation-for-Responsive-Design\"><a href=\"#Foundation-for-Responsive-Design\" class=\"headerlink\" title=\"Foundation for Responsive Design\"></a><em>Foundation for Responsive Design</em></h2><ul>\n<li>Grid system<br> –  We’ll deal with Bootstrap Grid system next</li>\n<li>Fluid images<br> – We’ll look at Bootsrap support later</li>\n<li>Media queries</li>\n</ul>\n<h3 id=\"Grid\"><a href=\"#Grid\" class=\"headerlink\" title=\"Grid\"></a><em>Grid</em></h3><ul>\n<li>Bootstrap makes available four classes<ul>\n<li>xs for extra small</li>\n<li>sm for small</li>\n<li>md for medium,and</li>\n<li>lg for large screen sizes</li>\n</ul>\n</li>\n<li>Each row in Bootstrap grid system is divided into 12 columns</li>\n<li>Use the classes .col-xs-“,.col-sm-“,col-md-“,and .col-lg-“ for defining the layouts for the various screen sizes</li>\n<li>Specify how many columns each piece of content will occupy within a row,all adding up to 12 or a multiple thereof</li>\n</ul>\n<pre><code>- pull and push \n- offset\n- ne\n</code></pre><hr>\n<ul>\n<li>Bootstrap</li>\n<li>Web Tools:<pre><code>— Node.js and NPM\n— Bower\n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"Bootstraps-Overview\"><a href=\"#Bootstraps-Overview\" class=\"headerlink\" title=\"Bootstraps Overview\"></a>Bootstraps Overview</h2><ul>\n<li><p>Responsive Design and Bootstrap Grid System</p>\n</li>\n<li><p>Navigation and Navigation Bar </p>\n</li>\n</ul>\n<h2 id=\"Bootstrap-CSS-Components\"><a href=\"#Bootstrap-CSS-Components\" class=\"headerlink\" title=\"Bootstrap CSS Components\"></a>Bootstrap CSS Components</h2><ul>\n<li>Tabs,Pill and Tabbed Navigation</li>\n<li>Hide and Seek:Collapse,Accordion,Scrollspy and affix</li>\n<li>revealing Content:Tooltips,Popovers and Modals</li>\n</ul>\n<h2 id=\"Web-Tools\"><a href=\"#Web-Tools\" class=\"headerlink\" title=\"Web Tools\"></a>Web Tools</h2><ul>\n<li>Bootstrap and JQuery</li>\n<li>Node.js and Node Package Manager</li>\n<li>Less id More！: Less and Sass</li>\n<li>Web Tools: Bower</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"What-is-Full-Stack-Web-Development\"><a href=\"#What-is-Full-Stack-Web-Development\" class=\"headerlink\" title=\"What is Full Stack Web Development?\"></a>What is Full Stack Web Development?</h1><hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://e.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=169594ccee50352ab56121096373c083/0824ab18972bd407199c48867c899e510fb30975.jpg\" alt=\"\"></h2><h2 id=\"Front-end-and-Back-end\"><a href=\"#Front-end-and-Back-end\" class=\"headerlink\" title=\"Front end and Back end\"></a><em>Front end and Back end</em></h2><ul>\n<li><strong>Front end/Client-side</strong><br>  — HTML,CSS and Javascript</li>\n<li><strong>Back end/Sever-side</strong><br>  — Various technologies and approaches<br>  — PHP,Java,Asp.NET,Ruby,Python </li>\n</ul>\n<hr>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><img src=\"http://f.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=266af5feceea15ce45eee40886300182/dcc451da81cb39db93acfc2dd7160924ab183058.jpg\" alt=\"\"></h2><h2 id=\"Three-Tier-Architecture\"><a href=\"#Three-Tier-Architecture\" class=\"headerlink\" title=\"Three Tier Architecture\"></a><em>Three Tier Architecture</em></h2><h4 id=\"Full-stack\"><a href=\"#Full-stack\" class=\"headerlink\" title=\"Full stack\"></a>Full stack</h4><pre><code>1. Presentation layer (Concerned with UI related issues)\n2. Business Logic layer (Data validation dynamic content processing)\n3. Data Access layer (Data persistence data access through an API)\n</code></pre><h2 id=\"Full-Stack-Javascript-Development\"><a href=\"#Full-Stack-Javascript-Development\" class=\"headerlink\" title=\"Full Stack Javascript Development\"></a><em>Full Stack Javascript Development</em></h2><p> 示意图：<br>    <img src=\"http://e.picphotos.baidu.com/album/s%3D1100%3Bq%3D90/sign=301499e359df8db1b82e78653913e625/a8014c086e061d95660faf437cf40ad162d9ca04.jpg\" alt=\"file-list\"></p>\n<h2 id=\"Foundation-for-Responsive-Design\"><a href=\"#Foundation-for-Responsive-Design\" class=\"headerlink\" title=\"Foundation for Responsive Design\"></a><em>Foundation for Responsive Design</em></h2><ul>\n<li>Grid system<br> –  We’ll deal with Bootstrap Grid system next</li>\n<li>Fluid images<br> – We’ll look at Bootsrap support later</li>\n<li>Media queries</li>\n</ul>\n<h3 id=\"Grid\"><a href=\"#Grid\" class=\"headerlink\" title=\"Grid\"></a><em>Grid</em></h3><ul>\n<li>Bootstrap makes available four classes<ul>\n<li>xs for extra small</li>\n<li>sm for small</li>\n<li>md for medium,and</li>\n<li>lg for large screen sizes</li>\n</ul>\n</li>\n<li>Each row in Bootstrap grid system is divided into 12 columns</li>\n<li>Use the classes .col-xs-“,.col-sm-“,col-md-“,and .col-lg-“ for defining the layouts for the various screen sizes</li>\n<li>Specify how many columns each piece of content will occupy within a row,all adding up to 12 or a multiple thereof</li>\n</ul>\n<pre><code>- pull and push \n- offset\n- ne\n</code></pre><hr>\n<ul>\n<li>Bootstrap</li>\n<li>Web Tools:<pre><code>— Node.js and NPM\n— Bower\n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"Bootstraps-Overview\"><a href=\"#Bootstraps-Overview\" class=\"headerlink\" title=\"Bootstraps Overview\"></a>Bootstraps Overview</h2><ul>\n<li><p>Responsive Design and Bootstrap Grid System</p>\n</li>\n<li><p>Navigation and Navigation Bar </p>\n</li>\n</ul>\n<h2 id=\"Bootstrap-CSS-Components\"><a href=\"#Bootstrap-CSS-Components\" class=\"headerlink\" title=\"Bootstrap CSS Components\"></a>Bootstrap CSS Components</h2><ul>\n<li>Tabs,Pill and Tabbed Navigation</li>\n<li>Hide and Seek:Collapse,Accordion,Scrollspy and affix</li>\n<li>revealing Content:Tooltips,Popovers and Modals</li>\n</ul>\n<h2 id=\"Web-Tools\"><a href=\"#Web-Tools\" class=\"headerlink\" title=\"Web Tools\"></a>Web Tools</h2><ul>\n<li>Bootstrap and JQuery</li>\n<li>Node.js and Node Package Manager</li>\n<li>Less id More！: Less and Sass</li>\n<li>Web Tools: Bower</li>\n</ul>\n"},{"date":"2016-07-29T10:37:00.000Z","status":"public","description":"css经典圣杯布局","title":"CSS系列之圣杯布局","_content":"\n## 圣杯布局的概念\n---\n![Holy Grial](http://alistapart.com/d/_made/d/ALA211_grail_300_348_421_81.jpg)\n\n即一种轻便，广泛使用的三栏流体布局。它具有以下的优秀特性：\n\n1. 两边固定宽度而中间可以流动；\n2. 允许中间栏代码最先出现；\n3. 允许任一栏的高度都最高；\n4. 仅需一个额外的`div`标签；\n5. 仅需很少必要css代码及最少兼容性补丁代码。\n\n我们先看看实现效果：[Take a look](http://alistapart.com/d/holygrail/example_1.html)\n\n## 实现步骤\n\n#### STEP 1：CREAT THE FRAME\n\nhtml代码:\n\n\t<div id=\"header\"></div>\n\t<div id=\"container\">\n\t<div id=\"footer\"></div>\n\n给`container`设置`padding`，为两栏预留空间\n\n```\n#container {\n  padding-left: 200px;   /* LC width */\n  padding-right: 150px;  /* RC width */\n}\n```\n效果像是这样：\n\n![img1](http://alistapart.com/d/holygrail/diagram_01.gif)\n\n#### STEP 2：ADD THE COLUMNS\n加上三栏：\n\n\t\n    <div id=\"center\" class=\"column\"></div>\n\t<div id=\"left\" class=\"column\"></div>\n\t<div id=\"right\" class=\"column\"></div>\n\t\t\n给两边加上适合的宽度，然后让中间栏自适应，让三栏全部浮动，当然也要给底栏`footer`清除浮动：\n\n```\n#container .column {\n  float: left;\n}\n#center {\n  width: 100%;\n}\n#left {\n  width: 200px;  /* LC width */\n}\n#right {\n  width: 150px;  /* RC width */\n}\n#footer {\n  clear: both;\n}\n```\n\n这时的效果图是这样的：\n\n![](http://alistapart.com/d/holygrail/diagram_02.gif)\n\n\n#### STEP 3: PULL THE LEFT COLUMN INTO PLACE\n\n这里才开始精妙的部分，我们先看代码：\n\n```\n#left {\n  width: 200px;        /* LC width */\n  margin-left: -100%;  \n}\n```\n`margin-left: -100%` 这条语句使左栏向左浮动了100%，center和left栏就会重叠，效果是这样的：\n\n![](http://alistapart.com/d/holygrail/diagram_03.gif)\n\n这时我们再利用relative的特性，使left移动到左栏，即：\n\n```\n#container .columns {\n  float: left;\n  position: relative;\n}\n#left {\n  width: 200px;        /* LC width */\n  margin-left: -100%;  \n  right: 200px;        /* LC width */\n}\n```\n\n左栏想要的效果就达到了：\n\n![](http://alistapart.com/d/holygrail/diagram_04.gif)\n\n#### STEP 4: PULL THE RIGHT COLUMN INTO PLACE\n\n接下来我们把放置右栏就简单多了，利用margin的负值法：\n\n```\n#right {\n  width: 150px;          /* RC width */\n  margin-right: -150px;  /* RC width */\n}\n```\n\nok，每栏都到达了正确位置，效果是这样的：\n\n![](http://alistapart.com/d/holygrail/diagram_05.gif)\n\n\n**圣杯布局就是这样了。如果想要更多了解，推荐看这篇原文**：[In Search of the Holy Grail](http://alistapart.com/article/holygrail)\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/CSS系列之圣杯布局.md","raw":"---\ndate: 2016-07-29 18:37\nstatus: public\ntags: [ css, 布局]\ndescription: css经典圣杯布局\ntitle: CSS系列之圣杯布局\n---\n\n## 圣杯布局的概念\n---\n![Holy Grial](http://alistapart.com/d/_made/d/ALA211_grail_300_348_421_81.jpg)\n\n即一种轻便，广泛使用的三栏流体布局。它具有以下的优秀特性：\n\n1. 两边固定宽度而中间可以流动；\n2. 允许中间栏代码最先出现；\n3. 允许任一栏的高度都最高；\n4. 仅需一个额外的`div`标签；\n5. 仅需很少必要css代码及最少兼容性补丁代码。\n\n我们先看看实现效果：[Take a look](http://alistapart.com/d/holygrail/example_1.html)\n\n## 实现步骤\n\n#### STEP 1：CREAT THE FRAME\n\nhtml代码:\n\n\t<div id=\"header\"></div>\n\t<div id=\"container\">\n\t<div id=\"footer\"></div>\n\n给`container`设置`padding`，为两栏预留空间\n\n```\n#container {\n  padding-left: 200px;   /* LC width */\n  padding-right: 150px;  /* RC width */\n}\n```\n效果像是这样：\n\n![img1](http://alistapart.com/d/holygrail/diagram_01.gif)\n\n#### STEP 2：ADD THE COLUMNS\n加上三栏：\n\n\t\n    <div id=\"center\" class=\"column\"></div>\n\t<div id=\"left\" class=\"column\"></div>\n\t<div id=\"right\" class=\"column\"></div>\n\t\t\n给两边加上适合的宽度，然后让中间栏自适应，让三栏全部浮动，当然也要给底栏`footer`清除浮动：\n\n```\n#container .column {\n  float: left;\n}\n#center {\n  width: 100%;\n}\n#left {\n  width: 200px;  /* LC width */\n}\n#right {\n  width: 150px;  /* RC width */\n}\n#footer {\n  clear: both;\n}\n```\n\n这时的效果图是这样的：\n\n![](http://alistapart.com/d/holygrail/diagram_02.gif)\n\n\n#### STEP 3: PULL THE LEFT COLUMN INTO PLACE\n\n这里才开始精妙的部分，我们先看代码：\n\n```\n#left {\n  width: 200px;        /* LC width */\n  margin-left: -100%;  \n}\n```\n`margin-left: -100%` 这条语句使左栏向左浮动了100%，center和left栏就会重叠，效果是这样的：\n\n![](http://alistapart.com/d/holygrail/diagram_03.gif)\n\n这时我们再利用relative的特性，使left移动到左栏，即：\n\n```\n#container .columns {\n  float: left;\n  position: relative;\n}\n#left {\n  width: 200px;        /* LC width */\n  margin-left: -100%;  \n  right: 200px;        /* LC width */\n}\n```\n\n左栏想要的效果就达到了：\n\n![](http://alistapart.com/d/holygrail/diagram_04.gif)\n\n#### STEP 4: PULL THE RIGHT COLUMN INTO PLACE\n\n接下来我们把放置右栏就简单多了，利用margin的负值法：\n\n```\n#right {\n  width: 150px;          /* RC width */\n  margin-right: -150px;  /* RC width */\n}\n```\n\nok，每栏都到达了正确位置，效果是这样的：\n\n![](http://alistapart.com/d/holygrail/diagram_05.gif)\n\n\n**圣杯布局就是这样了。如果想要更多了解，推荐看这篇原文**：[In Search of the Holy Grail](http://alistapart.com/article/holygrail)\n\n\n\n\n\n\n\n\n\n\n","slug":"CSS系列之圣杯布局","published":1,"updated":"2016-11-10T15:15:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca5h0005ib1c0jh0rwvk","content":"<h2 id=\"圣杯布局的概念\"><a href=\"#圣杯布局的概念\" class=\"headerlink\" title=\"圣杯布局的概念\"></a>圣杯布局的概念</h2><hr>\n<p><img src=\"http://alistapart.com/d/_made/d/ALA211_grail_300_348_421_81.jpg\" alt=\"Holy Grial\"></p>\n<p>即一种轻便，广泛使用的三栏流体布局。它具有以下的优秀特性：</p>\n<ol>\n<li>两边固定宽度而中间可以流动；</li>\n<li>允许中间栏代码最先出现；</li>\n<li>允许任一栏的高度都最高；</li>\n<li>仅需一个额外的<code>div</code>标签；</li>\n<li>仅需很少必要css代码及最少兼容性补丁代码。</li>\n</ol>\n<p>我们先看看实现效果：<a href=\"http://alistapart.com/d/holygrail/example_1.html\" target=\"_blank\" rel=\"external\">Take a look</a></p>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><h4 id=\"STEP-1：CREAT-THE-FRAME\"><a href=\"#STEP-1：CREAT-THE-FRAME\" class=\"headerlink\" title=\"STEP 1：CREAT THE FRAME\"></a>STEP 1：CREAT THE FRAME</h4><p>html代码:</p>\n<pre><code>&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;container&quot;&gt;\n&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;\n</code></pre><p>给<code>container</code>设置<code>padding</code>，为两栏预留空间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  padding-left: 200px;   /* LC width */</div><div class=\"line\">  padding-right: 150px;  /* RC width */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>效果像是这样：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_01.gif\" alt=\"img1\"></p>\n<h4 id=\"STEP-2：ADD-THE-COLUMNS\"><a href=\"#STEP-2：ADD-THE-COLUMNS\" class=\"headerlink\" title=\"STEP 2：ADD THE COLUMNS\"></a>STEP 2：ADD THE COLUMNS</h4><p>加上三栏：</p>\n<pre><code>&lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n</code></pre><p>给两边加上适合的宽度，然后让中间栏自适应，让三栏全部浮动，当然也要给底栏<code>footer</code>清除浮动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container .column &#123;</div><div class=\"line\">  float: left;</div><div class=\"line\">&#125;</div><div class=\"line\">#center &#123;</div><div class=\"line\">  width: 100%;</div><div class=\"line\">&#125;</div><div class=\"line\">#left &#123;</div><div class=\"line\">  width: 200px;  /* LC width */</div><div class=\"line\">&#125;</div><div class=\"line\">#right &#123;</div><div class=\"line\">  width: 150px;  /* RC width */</div><div class=\"line\">&#125;</div><div class=\"line\">#footer &#123;</div><div class=\"line\">  clear: both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这时的效果图是这样的：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_02.gif\" alt=\"\"></p>\n<h4 id=\"STEP-3-PULL-THE-LEFT-COLUMN-INTO-PLACE\"><a href=\"#STEP-3-PULL-THE-LEFT-COLUMN-INTO-PLACE\" class=\"headerlink\" title=\"STEP 3: PULL THE LEFT COLUMN INTO PLACE\"></a>STEP 3: PULL THE LEFT COLUMN INTO PLACE</h4><p>这里才开始精妙的部分，我们先看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#left &#123;</div><div class=\"line\">  width: 200px;        /* LC width */</div><div class=\"line\">  margin-left: -100%;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>margin-left: -100%</code> 这条语句使左栏向左浮动了100%，center和left栏就会重叠，效果是这样的：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_03.gif\" alt=\"\"></p>\n<p>这时我们再利用relative的特性，使left移动到左栏，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container .columns &#123;</div><div class=\"line\">  float: left;</div><div class=\"line\">  position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">#left &#123;</div><div class=\"line\">  width: 200px;        /* LC width */</div><div class=\"line\">  margin-left: -100%;  </div><div class=\"line\">  right: 200px;        /* LC width */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>左栏想要的效果就达到了：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_04.gif\" alt=\"\"></p>\n<h4 id=\"STEP-4-PULL-THE-RIGHT-COLUMN-INTO-PLACE\"><a href=\"#STEP-4-PULL-THE-RIGHT-COLUMN-INTO-PLACE\" class=\"headerlink\" title=\"STEP 4: PULL THE RIGHT COLUMN INTO PLACE\"></a>STEP 4: PULL THE RIGHT COLUMN INTO PLACE</h4><p>接下来我们把放置右栏就简单多了，利用margin的负值法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#right &#123;</div><div class=\"line\">  width: 150px;          /* RC width */</div><div class=\"line\">  margin-right: -150px;  /* RC width */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ok，每栏都到达了正确位置，效果是这样的：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_05.gif\" alt=\"\"></p>\n<p><strong>圣杯布局就是这样了。如果想要更多了解，推荐看这篇原文</strong>：<a href=\"http://alistapart.com/article/holygrail\" target=\"_blank\" rel=\"external\">In Search of the Holy Grail</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"圣杯布局的概念\"><a href=\"#圣杯布局的概念\" class=\"headerlink\" title=\"圣杯布局的概念\"></a>圣杯布局的概念</h2><hr>\n<p><img src=\"http://alistapart.com/d/_made/d/ALA211_grail_300_348_421_81.jpg\" alt=\"Holy Grial\"></p>\n<p>即一种轻便，广泛使用的三栏流体布局。它具有以下的优秀特性：</p>\n<ol>\n<li>两边固定宽度而中间可以流动；</li>\n<li>允许中间栏代码最先出现；</li>\n<li>允许任一栏的高度都最高；</li>\n<li>仅需一个额外的<code>div</code>标签；</li>\n<li>仅需很少必要css代码及最少兼容性补丁代码。</li>\n</ol>\n<p>我们先看看实现效果：<a href=\"http://alistapart.com/d/holygrail/example_1.html\">Take a look</a></p>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><h4 id=\"STEP-1：CREAT-THE-FRAME\"><a href=\"#STEP-1：CREAT-THE-FRAME\" class=\"headerlink\" title=\"STEP 1：CREAT THE FRAME\"></a>STEP 1：CREAT THE FRAME</h4><p>html代码:</p>\n<pre><code>&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;container&quot;&gt;\n&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;\n</code></pre><p>给<code>container</code>设置<code>padding</code>，为两栏预留空间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container &#123;</div><div class=\"line\">  padding-left: 200px;   /* LC width */</div><div class=\"line\">  padding-right: 150px;  /* RC width */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>效果像是这样：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_01.gif\" alt=\"img1\"></p>\n<h4 id=\"STEP-2：ADD-THE-COLUMNS\"><a href=\"#STEP-2：ADD-THE-COLUMNS\" class=\"headerlink\" title=\"STEP 2：ADD THE COLUMNS\"></a>STEP 2：ADD THE COLUMNS</h4><p>加上三栏：</p>\n<pre><code>&lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;&lt;/div&gt;\n</code></pre><p>给两边加上适合的宽度，然后让中间栏自适应，让三栏全部浮动，当然也要给底栏<code>footer</code>清除浮动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container .column &#123;</div><div class=\"line\">  float: left;</div><div class=\"line\">&#125;</div><div class=\"line\">#center &#123;</div><div class=\"line\">  width: 100%;</div><div class=\"line\">&#125;</div><div class=\"line\">#left &#123;</div><div class=\"line\">  width: 200px;  /* LC width */</div><div class=\"line\">&#125;</div><div class=\"line\">#right &#123;</div><div class=\"line\">  width: 150px;  /* RC width */</div><div class=\"line\">&#125;</div><div class=\"line\">#footer &#123;</div><div class=\"line\">  clear: both;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这时的效果图是这样的：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_02.gif\" alt=\"\"></p>\n<h4 id=\"STEP-3-PULL-THE-LEFT-COLUMN-INTO-PLACE\"><a href=\"#STEP-3-PULL-THE-LEFT-COLUMN-INTO-PLACE\" class=\"headerlink\" title=\"STEP 3: PULL THE LEFT COLUMN INTO PLACE\"></a>STEP 3: PULL THE LEFT COLUMN INTO PLACE</h4><p>这里才开始精妙的部分，我们先看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#left &#123;</div><div class=\"line\">  width: 200px;        /* LC width */</div><div class=\"line\">  margin-left: -100%;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>margin-left: -100%</code> 这条语句使左栏向左浮动了100%，center和left栏就会重叠，效果是这样的：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_03.gif\" alt=\"\"></p>\n<p>这时我们再利用relative的特性，使left移动到左栏，即：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">#container .columns &#123;</div><div class=\"line\">  float: left;</div><div class=\"line\">  position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">#left &#123;</div><div class=\"line\">  width: 200px;        /* LC width */</div><div class=\"line\">  margin-left: -100%;  </div><div class=\"line\">  right: 200px;        /* LC width */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>左栏想要的效果就达到了：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_04.gif\" alt=\"\"></p>\n<h4 id=\"STEP-4-PULL-THE-RIGHT-COLUMN-INTO-PLACE\"><a href=\"#STEP-4-PULL-THE-RIGHT-COLUMN-INTO-PLACE\" class=\"headerlink\" title=\"STEP 4: PULL THE RIGHT COLUMN INTO PLACE\"></a>STEP 4: PULL THE RIGHT COLUMN INTO PLACE</h4><p>接下来我们把放置右栏就简单多了，利用margin的负值法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#right &#123;</div><div class=\"line\">  width: 150px;          /* RC width */</div><div class=\"line\">  margin-right: -150px;  /* RC width */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ok，每栏都到达了正确位置，效果是这样的：</p>\n<p><img src=\"http://alistapart.com/d/holygrail/diagram_05.gif\" alt=\"\"></p>\n<p><strong>圣杯布局就是这样了。如果想要更多了解，推荐看这篇原文</strong>：<a href=\"http://alistapart.com/article/holygrail\">In Search of the Holy Grail</a></p>\n"},{"date":"2016-08-29T11:45:00.000Z","status":"public","description":"this是函数运行时自动生成的内部对象，即调用函数的那个对象。（不一定很准确的定义，但还算通俗易懂） 在大多数情况下，this的值由函数调用方式决定，它不能在执行期间赋值来设置，它在每次执行下可能都有不同的值。","title":"JavaScript之深入理解this","_content":"> 此文参考 [MDN_this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) 写成\n\n## 定义\nthis是函数运行时自动生成的内部对象，即调用函数的那个对象。（不一定很准确的定义，但还算通俗易懂）\n 在大多数情况下，this的值由函数调用方式决定，它不能在执行期间赋值来设置，它在每次执行下可能都有不同的值。\n## 全局执行环境（outside function）\n在全局执行环境中，this一直指向全局对象（global object），不管是在严格模式还是在非严格模式中。\n\n**代码1**\n\n```\nconsole.log(this.document === document);   //true\n\n// 在浏览器中，window对象也就是全局对象（global object）\nconsole.log(this === window);   //true\n\nthis.a  = 37;\nconsole.log(window.a);   //37\n```\n\n## 函数执行环境（inside function）\n在函数执行环境中，this的值取决于函数的调用方式。\n\n**而函数的调用方式主要有4种：**\n\n- 函数直接调用\n- 对象方法调用\n- 构造函数调用\n- call / apply / bind\n- 箭头函数（ES6）\n\n### 函数直接调用\n\n下面的代码在非严格模式执行时，this的值会指向全局对象；而在严格模式中，this的值将会默认为undefined。\n\n**代码2**\n\n```\n/* 非严格模式 */\nfunction f1 () {\n  return this;\n}\nconsole.log(f1() === window);   //true\n\n// in node;\nconsole.log(f1() === global);   //true\n\n/* 严格模式 */\nfunction f2 () {\n  'use strict'\n  return this;\n}\nconsole.log(f1() === undefined);   //true\n```\n----------------------------------\n### call / apply / bind 改变this的指向\n#### call / apply\ncall和apply的用法很像，只是后面参数的传入形式不同。\n\n**代码3**\n\n```\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nvar o = {a: 1, b: 3};\n\n// call的第一个参数 是对象，也就是this的指向对象。后面的参数就是函数arguments对象的成员\nadd.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\n\n// call的第一个参数 是对象，也就是this的指向对象。后面的参数是数组，数组里的成员也就是函数arguments对象成员\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34\n```\n**使用call和apply时需要注意的是**，当传入的第一个参数的值不是对象时，JavaScript会尝试使用ToObject 操作将其转化为对象。\n\n**代码4**\n\n```\nfunction bar() {\n  console.log(Object.prototype.toString.call(this));\n}\n\nbar.call(7); // [object Number]\n```\n#### bind 方法\nECMAScript 5 引入了 [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind)。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。\n\n**代码5**\n\n```\nfunction f() {\n  return this.a;\n}\n\nvar g = f.bind({a: 'azerty'}); //生成一个绑定函数g\nconsole.log(g()); // azerty\n\nvar o = {a: 10, f: f, g: g};\nconsole.log(o.f(), o.g());   //10, azerty\n\n//需要注意的是，绑定函数不可以再bind\nvar h = g.bind({a: 'foo'});\nconsole.log(h());  //azerty，不会变成foo\n```\n-------------------------------------\n### 对象方法调用\n当以对象里的方法的方式调用函数时，它们的 this 是调用该函数的对象.\n\n下面的例子中，当 o.f() 被调用时，函数内的this将绑定到o对象。\n\n```\nvar prop = 36;\nvar o = {\n  prop: 37,\n  bar: function() {\n    return this.prop;\n  }\n};\nconsole.log(o.bar());  //37\n```\n### 构造函数调用\n\n**代码6**\n\n```\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.introduce = function () {\n    console.log('My name is ' + this.name + ', I\\'m ' + this.age);\n  };\n}\nvar Joseph = new Person('Joseph', 19);\nJoseph.introduce();  // \"My name is Joseph, I'm 19\"\n```\n由上述代码可以清晰的看到this与被新创建的对象绑定了。\n\n*注意*：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。（这句话看起来比较难理解，我们看下一个例子）。\n\n**代码7**\n\n```\nfunction Fn2() {\n  this.a = 9;  // dead code\n  return {a: 10};\n}\nvar o = new Fn2();\nconsole.log(o.a);  // 10\n```\n这个例子说明了当构造函数返回的是一个对象的话，此时this的值会变成此时返回的对象。‘this.a = 9’成了僵尸代码。\n\n### 箭头函数\n在箭头函数（ [Arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)）中，this的值是封闭执行环境决定的。在全局环境中，那么被赋值为全局对象。\n\n```\nvar globalObject = this;\nvar foo = (() => this);\nconsole.log(foo() === globalObject); // true\n```\n更重要的是它与其他情况不同的是，不管函数如何调用，上面this的值一直都是全局对象。call / bind 也不能改变它的值。\n\n**代码8**\n\n```\n// 作为对象方法被调用\nvar obj = {foo: foo};\nconsole.log(obj.foo() === globalObject); // true\n\n// 尝试用 call 改变this的值\nconsole.log(foo.call(obj) === globalObject); // true //this的值并未变成obj\n\n// 尝试用 bind 改变this的值\nfoo = foo.bind(obj);\nconsole.log(foo() === globalObject); // true\n```\n\n--------------------------------\n## 案例\n本文知识点都看完了。让我们看几个案例，检查自己的掌握情况。\n\n例1\n\n```\nvar prop = 36;\nvar o = {\n  prop: 37,\n  bar1: function() {\n    function foo1() {\n      return this.prop;\n    }\n    return foo1;\n  },\n  bar2: function() {\n    var foo2  = (() => this.prop); //ES6箭头函数\n    return foo2;\n  }\n};\nconsole.log('result1:'+o.bar1()()); // result1 ?\nconsole.log('result2:'+o.bar2()()); // result2 ?\nvar fn2 = o.bar2;\nconsole.log('result3:'+fn2()()); // result3 ?\n```\n先揭晓答案：例1 result1 = 36，result2 = 37，result3 = 36。我的理解是，在result1中，o.bar1()执行导致foo函数return到了全局环境中，然后执行就变成了在全局中执行，所以得到的是全局中36的值。result2呢？因为this在箭头函数中。它的值不会改变。所以this仍指向o。那为什么result3又重新变了呢？因为此时‘var fn2  = o.bar2’相当于重新定义了一个函数，而this的值当然也就变为了全局对象。\n```\n// 相当于这样\nvar fn2 = function() {\n    function foo1() {\n      return this.prop;\n    }\n    return foo1;\n  }\nfn2()();\n```\n\n例2\n\n```\nfunction sum(a,b) {\n return a+b;\n};\nvar o = {\n  num: 1,\n  fn: function() {\n        function handle() {\n          return this.num = sum(this.num, this.num);\n        }\n    handle();\n  }\n};\nconsole.log('result:'+o.fn());  // result ?\n```\n同样先揭晓答案：result = undefined，用控制台可以看到此时this指向window，而不是o。这是个比较容易掉进去的坑。看似函数是由对象方法调用的，其实细心的话，我们可以看到。handle函数的执行，前面的没有对象的。这种情况下，this指向全局对象。解决办法也很简单。\n\n```\n// 1、取消 handle函数的定义，直接在对象的方法中使用this\nfn2: function() {\n    this.value = sum(this.value, this.value);  //2\n},\n///2、使用变量保存外部函数的this。\nfn3: function() {\n    var that = this;   // that == o\n    function handle() {\n        that.value = add(that.value, that.value);\n    }\n    handle();\n}\n```\n---------------------------\n\n参考文章：\n\n- [Javascript中this与闭包学习笔记](https://segmentfault.com/a/1190000006150835)\n- [理解JS中的this](https://segmentfault.com/a/1190000004905145)","source":"_posts/JavaScript之深入理解this.md","raw":"---\ndate: 2016-08-29 19:45\nstatus: public\ndescription: this是函数运行时自动生成的内部对象，即调用函数的那个对象。（不一定很准确的定义，但还算通俗易懂）\n 在大多数情况下，this的值由函数调用方式决定，它不能在执行期间赋值来设置，它在每次执行下可能都有不同的值。\ntitle: JavaScript之深入理解this\n---\n> 此文参考 [MDN_this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) 写成\n\n## 定义\nthis是函数运行时自动生成的内部对象，即调用函数的那个对象。（不一定很准确的定义，但还算通俗易懂）\n 在大多数情况下，this的值由函数调用方式决定，它不能在执行期间赋值来设置，它在每次执行下可能都有不同的值。\n## 全局执行环境（outside function）\n在全局执行环境中，this一直指向全局对象（global object），不管是在严格模式还是在非严格模式中。\n\n**代码1**\n\n```\nconsole.log(this.document === document);   //true\n\n// 在浏览器中，window对象也就是全局对象（global object）\nconsole.log(this === window);   //true\n\nthis.a  = 37;\nconsole.log(window.a);   //37\n```\n\n## 函数执行环境（inside function）\n在函数执行环境中，this的值取决于函数的调用方式。\n\n**而函数的调用方式主要有4种：**\n\n- 函数直接调用\n- 对象方法调用\n- 构造函数调用\n- call / apply / bind\n- 箭头函数（ES6）\n\n### 函数直接调用\n\n下面的代码在非严格模式执行时，this的值会指向全局对象；而在严格模式中，this的值将会默认为undefined。\n\n**代码2**\n\n```\n/* 非严格模式 */\nfunction f1 () {\n  return this;\n}\nconsole.log(f1() === window);   //true\n\n// in node;\nconsole.log(f1() === global);   //true\n\n/* 严格模式 */\nfunction f2 () {\n  'use strict'\n  return this;\n}\nconsole.log(f1() === undefined);   //true\n```\n----------------------------------\n### call / apply / bind 改变this的指向\n#### call / apply\ncall和apply的用法很像，只是后面参数的传入形式不同。\n\n**代码3**\n\n```\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nvar o = {a: 1, b: 3};\n\n// call的第一个参数 是对象，也就是this的指向对象。后面的参数就是函数arguments对象的成员\nadd.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\n\n// call的第一个参数 是对象，也就是this的指向对象。后面的参数是数组，数组里的成员也就是函数arguments对象成员\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34\n```\n**使用call和apply时需要注意的是**，当传入的第一个参数的值不是对象时，JavaScript会尝试使用ToObject 操作将其转化为对象。\n\n**代码4**\n\n```\nfunction bar() {\n  console.log(Object.prototype.toString.call(this));\n}\n\nbar.call(7); // [object Number]\n```\n#### bind 方法\nECMAScript 5 引入了 [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind)。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。\n\n**代码5**\n\n```\nfunction f() {\n  return this.a;\n}\n\nvar g = f.bind({a: 'azerty'}); //生成一个绑定函数g\nconsole.log(g()); // azerty\n\nvar o = {a: 10, f: f, g: g};\nconsole.log(o.f(), o.g());   //10, azerty\n\n//需要注意的是，绑定函数不可以再bind\nvar h = g.bind({a: 'foo'});\nconsole.log(h());  //azerty，不会变成foo\n```\n-------------------------------------\n### 对象方法调用\n当以对象里的方法的方式调用函数时，它们的 this 是调用该函数的对象.\n\n下面的例子中，当 o.f() 被调用时，函数内的this将绑定到o对象。\n\n```\nvar prop = 36;\nvar o = {\n  prop: 37,\n  bar: function() {\n    return this.prop;\n  }\n};\nconsole.log(o.bar());  //37\n```\n### 构造函数调用\n\n**代码6**\n\n```\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.introduce = function () {\n    console.log('My name is ' + this.name + ', I\\'m ' + this.age);\n  };\n}\nvar Joseph = new Person('Joseph', 19);\nJoseph.introduce();  // \"My name is Joseph, I'm 19\"\n```\n由上述代码可以清晰的看到this与被新创建的对象绑定了。\n\n*注意*：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。（这句话看起来比较难理解，我们看下一个例子）。\n\n**代码7**\n\n```\nfunction Fn2() {\n  this.a = 9;  // dead code\n  return {a: 10};\n}\nvar o = new Fn2();\nconsole.log(o.a);  // 10\n```\n这个例子说明了当构造函数返回的是一个对象的话，此时this的值会变成此时返回的对象。‘this.a = 9’成了僵尸代码。\n\n### 箭头函数\n在箭头函数（ [Arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)）中，this的值是封闭执行环境决定的。在全局环境中，那么被赋值为全局对象。\n\n```\nvar globalObject = this;\nvar foo = (() => this);\nconsole.log(foo() === globalObject); // true\n```\n更重要的是它与其他情况不同的是，不管函数如何调用，上面this的值一直都是全局对象。call / bind 也不能改变它的值。\n\n**代码8**\n\n```\n// 作为对象方法被调用\nvar obj = {foo: foo};\nconsole.log(obj.foo() === globalObject); // true\n\n// 尝试用 call 改变this的值\nconsole.log(foo.call(obj) === globalObject); // true //this的值并未变成obj\n\n// 尝试用 bind 改变this的值\nfoo = foo.bind(obj);\nconsole.log(foo() === globalObject); // true\n```\n\n--------------------------------\n## 案例\n本文知识点都看完了。让我们看几个案例，检查自己的掌握情况。\n\n例1\n\n```\nvar prop = 36;\nvar o = {\n  prop: 37,\n  bar1: function() {\n    function foo1() {\n      return this.prop;\n    }\n    return foo1;\n  },\n  bar2: function() {\n    var foo2  = (() => this.prop); //ES6箭头函数\n    return foo2;\n  }\n};\nconsole.log('result1:'+o.bar1()()); // result1 ?\nconsole.log('result2:'+o.bar2()()); // result2 ?\nvar fn2 = o.bar2;\nconsole.log('result3:'+fn2()()); // result3 ?\n```\n先揭晓答案：例1 result1 = 36，result2 = 37，result3 = 36。我的理解是，在result1中，o.bar1()执行导致foo函数return到了全局环境中，然后执行就变成了在全局中执行，所以得到的是全局中36的值。result2呢？因为this在箭头函数中。它的值不会改变。所以this仍指向o。那为什么result3又重新变了呢？因为此时‘var fn2  = o.bar2’相当于重新定义了一个函数，而this的值当然也就变为了全局对象。\n```\n// 相当于这样\nvar fn2 = function() {\n    function foo1() {\n      return this.prop;\n    }\n    return foo1;\n  }\nfn2()();\n```\n\n例2\n\n```\nfunction sum(a,b) {\n return a+b;\n};\nvar o = {\n  num: 1,\n  fn: function() {\n        function handle() {\n          return this.num = sum(this.num, this.num);\n        }\n    handle();\n  }\n};\nconsole.log('result:'+o.fn());  // result ?\n```\n同样先揭晓答案：result = undefined，用控制台可以看到此时this指向window，而不是o。这是个比较容易掉进去的坑。看似函数是由对象方法调用的，其实细心的话，我们可以看到。handle函数的执行，前面的没有对象的。这种情况下，this指向全局对象。解决办法也很简单。\n\n```\n// 1、取消 handle函数的定义，直接在对象的方法中使用this\nfn2: function() {\n    this.value = sum(this.value, this.value);  //2\n},\n///2、使用变量保存外部函数的this。\nfn3: function() {\n    var that = this;   // that == o\n    function handle() {\n        that.value = add(that.value, that.value);\n    }\n    handle();\n}\n```\n---------------------------\n\n参考文章：\n\n- [Javascript中this与闭包学习笔记](https://segmentfault.com/a/1190000006150835)\n- [理解JS中的this](https://segmentfault.com/a/1190000004905145)","slug":"JavaScript之深入理解this","published":1,"updated":"2017-03-29T14:24:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca5k0006ib1cqvy01f31","content":"<blockquote>\n<p>此文参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"external\">MDN_this</a> 写成</p>\n</blockquote>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>this是函数运行时自动生成的内部对象，即调用函数的那个对象。（不一定很准确的定义，但还算通俗易懂）<br> 在大多数情况下，this的值由函数调用方式决定，它不能在执行期间赋值来设置，它在每次执行下可能都有不同的值。</p>\n<h2 id=\"全局执行环境（outside-function）\"><a href=\"#全局执行环境（outside-function）\" class=\"headerlink\" title=\"全局执行环境（outside function）\"></a>全局执行环境（outside function）</h2><p>在全局执行环境中，this一直指向全局对象（global object），不管是在严格模式还是在非严格模式中。</p>\n<p><strong>代码1</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(this.document === document);   //true</div><div class=\"line\"></div><div class=\"line\">// 在浏览器中，window对象也就是全局对象（global object）</div><div class=\"line\">console.log(this === window);   //true</div><div class=\"line\"></div><div class=\"line\">this.a  = 37;</div><div class=\"line\">console.log(window.a);   //37</div></pre></td></tr></table></figure>\n<h2 id=\"函数执行环境（inside-function）\"><a href=\"#函数执行环境（inside-function）\" class=\"headerlink\" title=\"函数执行环境（inside function）\"></a>函数执行环境（inside function）</h2><p>在函数执行环境中，this的值取决于函数的调用方式。</p>\n<p><strong>而函数的调用方式主要有4种：</strong></p>\n<ul>\n<li>函数直接调用</li>\n<li>对象方法调用</li>\n<li>构造函数调用</li>\n<li>call / apply / bind</li>\n<li>箭头函数（ES6）</li>\n</ul>\n<h3 id=\"函数直接调用\"><a href=\"#函数直接调用\" class=\"headerlink\" title=\"函数直接调用\"></a>函数直接调用</h3><p>下面的代码在非严格模式执行时，this的值会指向全局对象；而在严格模式中，this的值将会默认为undefined。</p>\n<p><strong>代码2</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* 非严格模式 */</div><div class=\"line\">function f1 () &#123;</div><div class=\"line\">  return this;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(f1() === window);   //true</div><div class=\"line\"></div><div class=\"line\">// in node;</div><div class=\"line\">console.log(f1() === global);   //true</div><div class=\"line\"></div><div class=\"line\">/* 严格模式 */</div><div class=\"line\">function f2 () &#123;</div><div class=\"line\">  &apos;use strict&apos;</div><div class=\"line\">  return this;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(f1() === undefined);   //true</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"call-apply-bind-改变this的指向\"><a href=\"#call-apply-bind-改变this的指向\" class=\"headerlink\" title=\"call / apply / bind 改变this的指向\"></a>call / apply / bind 改变this的指向</h3><h4 id=\"call-apply\"><a href=\"#call-apply\" class=\"headerlink\" title=\"call / apply\"></a>call / apply</h4><p>call和apply的用法很像，只是后面参数的传入形式不同。</p>\n<p><strong>代码3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(c, d) &#123;</div><div class=\"line\">  return this.a + this.b + c + d;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var o = &#123;a: 1, b: 3&#125;;</div><div class=\"line\"></div><div class=\"line\">// call的第一个参数 是对象，也就是this的指向对象。后面的参数就是函数arguments对象的成员</div><div class=\"line\">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</div><div class=\"line\"></div><div class=\"line\">// call的第一个参数 是对象，也就是this的指向对象。后面的参数是数组，数组里的成员也就是函数arguments对象成员</div><div class=\"line\">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</div></pre></td></tr></table></figure>\n<p><strong>使用call和apply时需要注意的是</strong>，当传入的第一个参数的值不是对象时，JavaScript会尝试使用ToObject 操作将其转化为对象。</p>\n<p><strong>代码4</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function bar() &#123;</div><div class=\"line\">  console.log(Object.prototype.toString.call(this));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar.call(7); // [object Number]</div></pre></td></tr></table></figure>\n<h4 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind 方法\"></a>bind 方法</h4><p>ECMAScript 5 引入了 <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"external\">Function.prototype.bind</a>。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。</p>\n<p><strong>代码5</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f() &#123;</div><div class=\"line\">  return this.a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var g = f.bind(&#123;a: &apos;azerty&apos;&#125;); //生成一个绑定函数g</div><div class=\"line\">console.log(g()); // azerty</div><div class=\"line\"></div><div class=\"line\">var o = &#123;a: 10, f: f, g: g&#125;;</div><div class=\"line\">console.log(o.f(), o.g());   //10, azerty</div><div class=\"line\"></div><div class=\"line\">//需要注意的是，绑定函数不可以再bind</div><div class=\"line\">var h = g.bind(&#123;a: &apos;foo&apos;&#125;);</div><div class=\"line\">console.log(h());  //azerty，不会变成foo</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"对象方法调用\"><a href=\"#对象方法调用\" class=\"headerlink\" title=\"对象方法调用\"></a>对象方法调用</h3><p>当以对象里的方法的方式调用函数时，它们的 this 是调用该函数的对象.</p>\n<p>下面的例子中，当 o.f() 被调用时，函数内的this将绑定到o对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var prop = 36;</div><div class=\"line\">var o = &#123;</div><div class=\"line\">  prop: 37,</div><div class=\"line\">  bar: function() &#123;</div><div class=\"line\">    return this.prop;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">console.log(o.bar());  //37</div></pre></td></tr></table></figure>\n<h3 id=\"构造函数调用\"><a href=\"#构造函数调用\" class=\"headerlink\" title=\"构造函数调用\"></a>构造函数调用</h3><p><strong>代码6</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person(name, age) &#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.age = age;</div><div class=\"line\">  this.introduce = function () &#123;</div><div class=\"line\">    console.log(&apos;My name is &apos; + this.name + &apos;, I\\&apos;m &apos; + this.age);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">var Joseph = new Person(&apos;Joseph&apos;, 19);</div><div class=\"line\">Joseph.introduce();  // &quot;My name is Joseph, I&apos;m 19&quot;</div></pre></td></tr></table></figure>\n<p>由上述代码可以清晰的看到this与被新创建的对象绑定了。</p>\n<p><em>注意</em>：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。（这句话看起来比较难理解，我们看下一个例子）。</p>\n<p><strong>代码7</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Fn2() &#123;</div><div class=\"line\">  this.a = 9;  // dead code</div><div class=\"line\">  return &#123;a: 10&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">var o = new Fn2();</div><div class=\"line\">console.log(o.a);  // 10</div></pre></td></tr></table></figure>\n<p>这个例子说明了当构造函数返回的是一个对象的话，此时this的值会变成此时返回的对象。‘this.a = 9’成了僵尸代码。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>在箭头函数（ <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"external\">Arrow functions</a>）中，this的值是封闭执行环境决定的。在全局环境中，那么被赋值为全局对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var globalObject = this;</div><div class=\"line\">var foo = (() =&gt; this);</div><div class=\"line\">console.log(foo() === globalObject); // true</div></pre></td></tr></table></figure>\n<p>更重要的是它与其他情况不同的是，不管函数如何调用，上面this的值一直都是全局对象。call / bind 也不能改变它的值。</p>\n<p><strong>代码8</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 作为对象方法被调用</div><div class=\"line\">var obj = &#123;foo: foo&#125;;</div><div class=\"line\">console.log(obj.foo() === globalObject); // true</div><div class=\"line\"></div><div class=\"line\">// 尝试用 call 改变this的值</div><div class=\"line\">console.log(foo.call(obj) === globalObject); // true //this的值并未变成obj</div><div class=\"line\"></div><div class=\"line\">// 尝试用 bind 改变this的值</div><div class=\"line\">foo = foo.bind(obj);</div><div class=\"line\">console.log(foo() === globalObject); // true</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h2><p>本文知识点都看完了。让我们看几个案例，检查自己的掌握情况。</p>\n<p>例1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var prop = 36;</div><div class=\"line\">var o = &#123;</div><div class=\"line\">  prop: 37,</div><div class=\"line\">  bar1: function() &#123;</div><div class=\"line\">    function foo1() &#123;</div><div class=\"line\">      return this.prop;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return foo1;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  bar2: function() &#123;</div><div class=\"line\">    var foo2  = (() =&gt; this.prop); //ES6箭头函数</div><div class=\"line\">    return foo2;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">console.log(&apos;result1:&apos;+o.bar1()()); // result1 ?</div><div class=\"line\">console.log(&apos;result2:&apos;+o.bar2()()); // result2 ?</div><div class=\"line\">var fn2 = o.bar2;</div><div class=\"line\">console.log(&apos;result3:&apos;+fn2()()); // result3 ?</div></pre></td></tr></table></figure>\n<p>先揭晓答案：例1 result1 = 36，result2 = 37，result3 = 36。我的理解是，在result1中，o.bar1()执行导致foo函数return到了全局环境中，然后执行就变成了在全局中执行，所以得到的是全局中36的值。result2呢？因为this在箭头函数中。它的值不会改变。所以this仍指向o。那为什么result3又重新变了呢？因为此时‘var fn2  = o.bar2’相当于重新定义了一个函数，而this的值当然也就变为了全局对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 相当于这样</div><div class=\"line\">var fn2 = function() &#123;</div><div class=\"line\">    function foo1() &#123;</div><div class=\"line\">      return this.prop;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return foo1;</div><div class=\"line\">  &#125;</div><div class=\"line\">fn2()();</div></pre></td></tr></table></figure></p>\n<p>例2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sum(a,b) &#123;</div><div class=\"line\"> return a+b;</div><div class=\"line\">&#125;;</div><div class=\"line\">var o = &#123;</div><div class=\"line\">  num: 1,</div><div class=\"line\">  fn: function() &#123;</div><div class=\"line\">        function handle() &#123;</div><div class=\"line\">          return this.num = sum(this.num, this.num);</div><div class=\"line\">        &#125;</div><div class=\"line\">    handle();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">console.log(&apos;result:&apos;+o.fn());  // result ?</div></pre></td></tr></table></figure>\n<p>同样先揭晓答案：result = undefined，用控制台可以看到此时this指向window，而不是o。这是个比较容易掉进去的坑。看似函数是由对象方法调用的，其实细心的话，我们可以看到。handle函数的执行，前面的没有对象的。这种情况下，this指向全局对象。解决办法也很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1、取消 handle函数的定义，直接在对象的方法中使用this</div><div class=\"line\">fn2: function() &#123;</div><div class=\"line\">    this.value = sum(this.value, this.value);  //2</div><div class=\"line\">&#125;,</div><div class=\"line\">///2、使用变量保存外部函数的this。</div><div class=\"line\">fn3: function() &#123;</div><div class=\"line\">    var that = this;   // that == o</div><div class=\"line\">    function handle() &#123;</div><div class=\"line\">        that.value = add(that.value, that.value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    handle();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000006150835\" target=\"_blank\" rel=\"external\">Javascript中this与闭包学习笔记</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004905145\" target=\"_blank\" rel=\"external\">理解JS中的this</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此文参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">MDN_this</a> 写成</p>\n</blockquote>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>this是函数运行时自动生成的内部对象，即调用函数的那个对象。（不一定很准确的定义，但还算通俗易懂）<br> 在大多数情况下，this的值由函数调用方式决定，它不能在执行期间赋值来设置，它在每次执行下可能都有不同的值。</p>\n<h2 id=\"全局执行环境（outside-function）\"><a href=\"#全局执行环境（outside-function）\" class=\"headerlink\" title=\"全局执行环境（outside function）\"></a>全局执行环境（outside function）</h2><p>在全局执行环境中，this一直指向全局对象（global object），不管是在严格模式还是在非严格模式中。</p>\n<p><strong>代码1</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(this.document === document);   //true</div><div class=\"line\"></div><div class=\"line\">// 在浏览器中，window对象也就是全局对象（global object）</div><div class=\"line\">console.log(this === window);   //true</div><div class=\"line\"></div><div class=\"line\">this.a  = 37;</div><div class=\"line\">console.log(window.a);   //37</div></pre></td></tr></table></figure>\n<h2 id=\"函数执行环境（inside-function）\"><a href=\"#函数执行环境（inside-function）\" class=\"headerlink\" title=\"函数执行环境（inside function）\"></a>函数执行环境（inside function）</h2><p>在函数执行环境中，this的值取决于函数的调用方式。</p>\n<p><strong>而函数的调用方式主要有4种：</strong></p>\n<ul>\n<li>函数直接调用</li>\n<li>对象方法调用</li>\n<li>构造函数调用</li>\n<li>call / apply / bind</li>\n<li>箭头函数（ES6）</li>\n</ul>\n<h3 id=\"函数直接调用\"><a href=\"#函数直接调用\" class=\"headerlink\" title=\"函数直接调用\"></a>函数直接调用</h3><p>下面的代码在非严格模式执行时，this的值会指向全局对象；而在严格模式中，this的值将会默认为undefined。</p>\n<p><strong>代码2</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* 非严格模式 */</div><div class=\"line\">function f1 () &#123;</div><div class=\"line\">  return this;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(f1() === window);   //true</div><div class=\"line\"></div><div class=\"line\">// in node;</div><div class=\"line\">console.log(f1() === global);   //true</div><div class=\"line\"></div><div class=\"line\">/* 严格模式 */</div><div class=\"line\">function f2 () &#123;</div><div class=\"line\">  &apos;use strict&apos;</div><div class=\"line\">  return this;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(f1() === undefined);   //true</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"call-apply-bind-改变this的指向\"><a href=\"#call-apply-bind-改变this的指向\" class=\"headerlink\" title=\"call / apply / bind 改变this的指向\"></a>call / apply / bind 改变this的指向</h3><h4 id=\"call-apply\"><a href=\"#call-apply\" class=\"headerlink\" title=\"call / apply\"></a>call / apply</h4><p>call和apply的用法很像，只是后面参数的传入形式不同。</p>\n<p><strong>代码3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(c, d) &#123;</div><div class=\"line\">  return this.a + this.b + c + d;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var o = &#123;a: 1, b: 3&#125;;</div><div class=\"line\"></div><div class=\"line\">// call的第一个参数 是对象，也就是this的指向对象。后面的参数就是函数arguments对象的成员</div><div class=\"line\">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</div><div class=\"line\"></div><div class=\"line\">// call的第一个参数 是对象，也就是this的指向对象。后面的参数是数组，数组里的成员也就是函数arguments对象成员</div><div class=\"line\">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</div></pre></td></tr></table></figure>\n<p><strong>使用call和apply时需要注意的是</strong>，当传入的第一个参数的值不是对象时，JavaScript会尝试使用ToObject 操作将其转化为对象。</p>\n<p><strong>代码4</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function bar() &#123;</div><div class=\"line\">  console.log(Object.prototype.toString.call(this));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar.call(7); // [object Number]</div></pre></td></tr></table></figure>\n<h4 id=\"bind-方法\"><a href=\"#bind-方法\" class=\"headerlink\" title=\"bind 方法\"></a>bind 方法</h4><p>ECMAScript 5 引入了 <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind\">Function.prototype.bind</a>。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。</p>\n<p><strong>代码5</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f() &#123;</div><div class=\"line\">  return this.a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var g = f.bind(&#123;a: &apos;azerty&apos;&#125;); //生成一个绑定函数g</div><div class=\"line\">console.log(g()); // azerty</div><div class=\"line\"></div><div class=\"line\">var o = &#123;a: 10, f: f, g: g&#125;;</div><div class=\"line\">console.log(o.f(), o.g());   //10, azerty</div><div class=\"line\"></div><div class=\"line\">//需要注意的是，绑定函数不可以再bind</div><div class=\"line\">var h = g.bind(&#123;a: &apos;foo&apos;&#125;);</div><div class=\"line\">console.log(h());  //azerty，不会变成foo</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"对象方法调用\"><a href=\"#对象方法调用\" class=\"headerlink\" title=\"对象方法调用\"></a>对象方法调用</h3><p>当以对象里的方法的方式调用函数时，它们的 this 是调用该函数的对象.</p>\n<p>下面的例子中，当 o.f() 被调用时，函数内的this将绑定到o对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var prop = 36;</div><div class=\"line\">var o = &#123;</div><div class=\"line\">  prop: 37,</div><div class=\"line\">  bar: function() &#123;</div><div class=\"line\">    return this.prop;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">console.log(o.bar());  //37</div></pre></td></tr></table></figure>\n<h3 id=\"构造函数调用\"><a href=\"#构造函数调用\" class=\"headerlink\" title=\"构造函数调用\"></a>构造函数调用</h3><p><strong>代码6</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person(name, age) &#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">  this.age = age;</div><div class=\"line\">  this.introduce = function () &#123;</div><div class=\"line\">    console.log(&apos;My name is &apos; + this.name + &apos;, I\\&apos;m &apos; + this.age);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">var Joseph = new Person(&apos;Joseph&apos;, 19);</div><div class=\"line\">Joseph.introduce();  // &quot;My name is Joseph, I&apos;m 19&quot;</div></pre></td></tr></table></figure>\n<p>由上述代码可以清晰的看到this与被新创建的对象绑定了。</p>\n<p><em>注意</em>：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。（这句话看起来比较难理解，我们看下一个例子）。</p>\n<p><strong>代码7</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Fn2() &#123;</div><div class=\"line\">  this.a = 9;  // dead code</div><div class=\"line\">  return &#123;a: 10&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">var o = new Fn2();</div><div class=\"line\">console.log(o.a);  // 10</div></pre></td></tr></table></figure>\n<p>这个例子说明了当构造函数返回的是一个对象的话，此时this的值会变成此时返回的对象。‘this.a = 9’成了僵尸代码。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>在箭头函数（ <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">Arrow functions</a>）中，this的值是封闭执行环境决定的。在全局环境中，那么被赋值为全局对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var globalObject = this;</div><div class=\"line\">var foo = (() =&gt; this);</div><div class=\"line\">console.log(foo() === globalObject); // true</div></pre></td></tr></table></figure>\n<p>更重要的是它与其他情况不同的是，不管函数如何调用，上面this的值一直都是全局对象。call / bind 也不能改变它的值。</p>\n<p><strong>代码8</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 作为对象方法被调用</div><div class=\"line\">var obj = &#123;foo: foo&#125;;</div><div class=\"line\">console.log(obj.foo() === globalObject); // true</div><div class=\"line\"></div><div class=\"line\">// 尝试用 call 改变this的值</div><div class=\"line\">console.log(foo.call(obj) === globalObject); // true //this的值并未变成obj</div><div class=\"line\"></div><div class=\"line\">// 尝试用 bind 改变this的值</div><div class=\"line\">foo = foo.bind(obj);</div><div class=\"line\">console.log(foo() === globalObject); // true</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h2><p>本文知识点都看完了。让我们看几个案例，检查自己的掌握情况。</p>\n<p>例1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var prop = 36;</div><div class=\"line\">var o = &#123;</div><div class=\"line\">  prop: 37,</div><div class=\"line\">  bar1: function() &#123;</div><div class=\"line\">    function foo1() &#123;</div><div class=\"line\">      return this.prop;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return foo1;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  bar2: function() &#123;</div><div class=\"line\">    var foo2  = (() =&gt; this.prop); //ES6箭头函数</div><div class=\"line\">    return foo2;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">console.log(&apos;result1:&apos;+o.bar1()()); // result1 ?</div><div class=\"line\">console.log(&apos;result2:&apos;+o.bar2()()); // result2 ?</div><div class=\"line\">var fn2 = o.bar2;</div><div class=\"line\">console.log(&apos;result3:&apos;+fn2()()); // result3 ?</div></pre></td></tr></table></figure>\n<p>先揭晓答案：例1 result1 = 36，result2 = 37，result3 = 36。我的理解是，在result1中，o.bar1()执行导致foo函数return到了全局环境中，然后执行就变成了在全局中执行，所以得到的是全局中36的值。result2呢？因为this在箭头函数中。它的值不会改变。所以this仍指向o。那为什么result3又重新变了呢？因为此时‘var fn2  = o.bar2’相当于重新定义了一个函数，而this的值当然也就变为了全局对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 相当于这样</div><div class=\"line\">var fn2 = function() &#123;</div><div class=\"line\">    function foo1() &#123;</div><div class=\"line\">      return this.prop;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return foo1;</div><div class=\"line\">  &#125;</div><div class=\"line\">fn2()();</div></pre></td></tr></table></figure></p>\n<p>例2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sum(a,b) &#123;</div><div class=\"line\"> return a+b;</div><div class=\"line\">&#125;;</div><div class=\"line\">var o = &#123;</div><div class=\"line\">  num: 1,</div><div class=\"line\">  fn: function() &#123;</div><div class=\"line\">        function handle() &#123;</div><div class=\"line\">          return this.num = sum(this.num, this.num);</div><div class=\"line\">        &#125;</div><div class=\"line\">    handle();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">console.log(&apos;result:&apos;+o.fn());  // result ?</div></pre></td></tr></table></figure>\n<p>同样先揭晓答案：result = undefined，用控制台可以看到此时this指向window，而不是o。这是个比较容易掉进去的坑。看似函数是由对象方法调用的，其实细心的话，我们可以看到。handle函数的执行，前面的没有对象的。这种情况下，this指向全局对象。解决办法也很简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1、取消 handle函数的定义，直接在对象的方法中使用this</div><div class=\"line\">fn2: function() &#123;</div><div class=\"line\">    this.value = sum(this.value, this.value);  //2</div><div class=\"line\">&#125;,</div><div class=\"line\">///2、使用变量保存外部函数的this。</div><div class=\"line\">fn3: function() &#123;</div><div class=\"line\">    var that = this;   // that == o</div><div class=\"line\">    function handle() &#123;</div><div class=\"line\">        that.value = add(that.value, that.value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    handle();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000006150835\">Javascript中this与闭包学习笔记</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004905145\">理解JS中的this</a></li>\n</ul>\n"},{"date":"2016-08-25T11:45:00.000Z","status":"public","description":"在javascript的学习中，执行环境、作用域是2个非常非常重要和基本的概念，理解了这2个概念对于javsacript中很多脚本的运行结果就能明白其中的道理了，比如搞清作用域和执行环境对于闭包的理解至关重要。","title":"JavaScript之理解作用域","_content":"\n>在javascript的学习中，执行环境、作用域是2个非常非常重要和基本的概念，理解了这2个概念对于javsacript中很多脚本的运行结果就能明白其中的道理了，比如搞清作用域和执行环境对于闭包的理解至关重要。\n\n## 一、执行环境（exection context,也有称之为执行上下文）\n>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象** (variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器会处理数据时会在后台使用它。                                  ---《JavaScript高程》\n\n当这个执行环境是函数的时候，这个变量对象就是函数的活动对象。活动对象最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。\n## 二、作用域链（scope chain）\n了解了变量对象之后，理解作用域链就容易了。\n>在代码在一个环境执行时，会创建变量对象的一个 **作用域链**。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。\n\n**整个作用域链是由不同执行位置上的变量对象（Variable Object）按照规则所构建一个链表。**\n\n作用域链的前端，始终都是当前执行的代码所在环境的变量对象。下一个变量对象来自包含（外部）环境，而下一个变量对象则来自下一个包含对象。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链的最后一个对象。\n\n引用高程中的例子：\n\n```\n var color=\"blue\";\n function changecolor(){\n    var anothercolor=\"red\";\n    function swapcolors(){\n\tvar tempcolor=anothercolor;\n\tanothercolor=color;\n\tcolor=tempcolor;\n       // Todo something\t\t\n     }\n    swapcolors();\n}\nchangecolor();\n //这里不能访问tempcolor和anocolor;但是可以访问color;\nalert(\"Color is now  \"+color);\n```\n上面例子涉及了3个执行环境：全局变量、changeColor()的局部变量环境和swapColors()的局部变量环境。swapcolor（）的局部环境开始先在自己的Variable Object中搜索变量和函数名，找不到，则向上搜索changecolor作用域链。。。。。以此类推。但是，changecolor()函数是无法访问swapcolor中的变量。\n\n![作用域链](http://upload-images.jianshu.io/upload_images/2575359-31c07041f11d1e92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n***\n通过上面的分析，我们可以得知内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间是线性、有次序的。每个环境都可以向上搜索作用域链，以便查询变量和函数名；\n\ntip:通过下面两种情况，即当执行流进入下列任何语句时，作用域链就会得到加长：\n- try-catch 语句的 catch 块;\n- with 语句。\n\n## 三、没有块级作用域（在 let 出现以前）\n\n看两个例子\n\n```\n情况1：\nfor (var i = 0;i<10;i++) {\n  // do something\n}\nconsole.info(i);  // 10\n情况2：\nfor (let i = 0;i<10;i++) {\n  // do something\n}\nconsole.info(i);  // error\n```\n\n从上面的例子中可以看出，JavaScript没有像其他类C的语言（由花括号封闭的代码块都有自己的作用域）一样。在使用for语句时尤其记住这点。\n\n## 四、声明变量\n\n使用var声明变量时，这个变量将被自动添加到距离最近的可用环境中。对于函数而言，自然声明的变量就会被添加到函数的局部环境中，变量在整个函数环境内都是可用的。\n\n   但是，如果变量没有是用var进行声明，将会被添加到全局环境，也就是说成位全局变量了。（只有当执行流执行到该语句时，才会被添加到全局变量的变量对象中）\n\n看一个例子：\n\n```\n情况1：\nvar x = 1;\nfunction rain() {\n  console.info(x);  // 1\n}\nrain(); \n情况2：\nvar x = 1;\nfunction rain() {\n  console.info(x);  //undefined\n  var x = 10;\n  console.info(x); // 10 \n}\nrain(); \n```\n\n情况1中得到的1 和 情况2中得到的10，通过上述作用域链的关系，我们较为容易理解。那情况2中的 undefined 是怎么回事儿呢？答案是预解析，我们看下面一段代码，和上面的代码等价\n\n```\nvar x = 1;\nfunction rain() {\n  var x;\n  console.info(x);  //undefined\n  x = 10;\n  console.info(x); // 10 \n}\nrain(); \n```\n因为JavaScript引擎会预解析代码中变量和函数的定义。导致调用x的时候，局部执行环境已经有了x，就不向上继续寻找x，也就访问不到全局变量的x。而此时局部变量x还未赋值，这时候输出也就是 undefined 了。","source":"_posts/JavaScript之理解作用域.md","raw":"---\ndate: 2016-08-25 19:45\nstatus: public\ndescription: 在javascript的学习中，执行环境、作用域是2个非常非常重要和基本的概念，理解了这2个概念对于javsacript中很多脚本的运行结果就能明白其中的道理了，比如搞清作用域和执行环境对于闭包的理解至关重要。\ntitle: JavaScript之理解作用域\n---\n\n>在javascript的学习中，执行环境、作用域是2个非常非常重要和基本的概念，理解了这2个概念对于javsacript中很多脚本的运行结果就能明白其中的道理了，比如搞清作用域和执行环境对于闭包的理解至关重要。\n\n## 一、执行环境（exection context,也有称之为执行上下文）\n>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象** (variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器会处理数据时会在后台使用它。                                  ---《JavaScript高程》\n\n当这个执行环境是函数的时候，这个变量对象就是函数的活动对象。活动对象最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。\n## 二、作用域链（scope chain）\n了解了变量对象之后，理解作用域链就容易了。\n>在代码在一个环境执行时，会创建变量对象的一个 **作用域链**。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。\n\n**整个作用域链是由不同执行位置上的变量对象（Variable Object）按照规则所构建一个链表。**\n\n作用域链的前端，始终都是当前执行的代码所在环境的变量对象。下一个变量对象来自包含（外部）环境，而下一个变量对象则来自下一个包含对象。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链的最后一个对象。\n\n引用高程中的例子：\n\n```\n var color=\"blue\";\n function changecolor(){\n    var anothercolor=\"red\";\n    function swapcolors(){\n\tvar tempcolor=anothercolor;\n\tanothercolor=color;\n\tcolor=tempcolor;\n       // Todo something\t\t\n     }\n    swapcolors();\n}\nchangecolor();\n //这里不能访问tempcolor和anocolor;但是可以访问color;\nalert(\"Color is now  \"+color);\n```\n上面例子涉及了3个执行环境：全局变量、changeColor()的局部变量环境和swapColors()的局部变量环境。swapcolor（）的局部环境开始先在自己的Variable Object中搜索变量和函数名，找不到，则向上搜索changecolor作用域链。。。。。以此类推。但是，changecolor()函数是无法访问swapcolor中的变量。\n\n![作用域链](http://upload-images.jianshu.io/upload_images/2575359-31c07041f11d1e92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n***\n通过上面的分析，我们可以得知内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间是线性、有次序的。每个环境都可以向上搜索作用域链，以便查询变量和函数名；\n\ntip:通过下面两种情况，即当执行流进入下列任何语句时，作用域链就会得到加长：\n- try-catch 语句的 catch 块;\n- with 语句。\n\n## 三、没有块级作用域（在 let 出现以前）\n\n看两个例子\n\n```\n情况1：\nfor (var i = 0;i<10;i++) {\n  // do something\n}\nconsole.info(i);  // 10\n情况2：\nfor (let i = 0;i<10;i++) {\n  // do something\n}\nconsole.info(i);  // error\n```\n\n从上面的例子中可以看出，JavaScript没有像其他类C的语言（由花括号封闭的代码块都有自己的作用域）一样。在使用for语句时尤其记住这点。\n\n## 四、声明变量\n\n使用var声明变量时，这个变量将被自动添加到距离最近的可用环境中。对于函数而言，自然声明的变量就会被添加到函数的局部环境中，变量在整个函数环境内都是可用的。\n\n   但是，如果变量没有是用var进行声明，将会被添加到全局环境，也就是说成位全局变量了。（只有当执行流执行到该语句时，才会被添加到全局变量的变量对象中）\n\n看一个例子：\n\n```\n情况1：\nvar x = 1;\nfunction rain() {\n  console.info(x);  // 1\n}\nrain(); \n情况2：\nvar x = 1;\nfunction rain() {\n  console.info(x);  //undefined\n  var x = 10;\n  console.info(x); // 10 \n}\nrain(); \n```\n\n情况1中得到的1 和 情况2中得到的10，通过上述作用域链的关系，我们较为容易理解。那情况2中的 undefined 是怎么回事儿呢？答案是预解析，我们看下面一段代码，和上面的代码等价\n\n```\nvar x = 1;\nfunction rain() {\n  var x;\n  console.info(x);  //undefined\n  x = 10;\n  console.info(x); // 10 \n}\nrain(); \n```\n因为JavaScript引擎会预解析代码中变量和函数的定义。导致调用x的时候，局部执行环境已经有了x，就不向上继续寻找x，也就访问不到全局变量的x。而此时局部变量x还未赋值，这时候输出也就是 undefined 了。","slug":"JavaScript之理解作用域","published":1,"updated":"2017-03-29T14:24:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca5t0008ib1c54nutg5w","content":"<blockquote>\n<p>在javascript的学习中，执行环境、作用域是2个非常非常重要和基本的概念，理解了这2个概念对于javsacript中很多脚本的运行结果就能明白其中的道理了，比如搞清作用域和执行环境对于闭包的理解至关重要。</p>\n</blockquote>\n<h2 id=\"一、执行环境（exection-context-也有称之为执行上下文）\"><a href=\"#一、执行环境（exection-context-也有称之为执行上下文）\" class=\"headerlink\" title=\"一、执行环境（exection context,也有称之为执行上下文）\"></a>一、执行环境（exection context,也有称之为执行上下文）</h2><blockquote>\n<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的<strong>变量对象</strong> (variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器会处理数据时会在后台使用它。                                  —《JavaScript高程》</p>\n</blockquote>\n<p>当这个执行环境是函数的时候，这个变量对象就是函数的活动对象。活动对象最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。</p>\n<h2 id=\"二、作用域链（scope-chain）\"><a href=\"#二、作用域链（scope-chain）\" class=\"headerlink\" title=\"二、作用域链（scope chain）\"></a>二、作用域链（scope chain）</h2><p>了解了变量对象之后，理解作用域链就容易了。</p>\n<blockquote>\n<p>在代码在一个环境执行时，会创建变量对象的一个 <strong>作用域链</strong>。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。</p>\n</blockquote>\n<p><strong>整个作用域链是由不同执行位置上的变量对象（Variable Object）按照规则所构建一个链表。</strong></p>\n<p>作用域链的前端，始终都是当前执行的代码所在环境的变量对象。下一个变量对象来自包含（外部）环境，而下一个变量对象则来自下一个包含对象。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链的最后一个对象。</p>\n<p>引用高程中的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var color=&quot;blue&quot;;</div><div class=\"line\"> function changecolor()&#123;</div><div class=\"line\">    var anothercolor=&quot;red&quot;;</div><div class=\"line\">    function swapcolors()&#123;</div><div class=\"line\">\tvar tempcolor=anothercolor;</div><div class=\"line\">\tanothercolor=color;</div><div class=\"line\">\tcolor=tempcolor;</div><div class=\"line\">       // Todo something\t\t</div><div class=\"line\">     &#125;</div><div class=\"line\">    swapcolors();</div><div class=\"line\">&#125;</div><div class=\"line\">changecolor();</div><div class=\"line\"> //这里不能访问tempcolor和anocolor;但是可以访问color;</div><div class=\"line\">alert(&quot;Color is now  &quot;+color);</div></pre></td></tr></table></figure>\n<p>上面例子涉及了3个执行环境：全局变量、changeColor()的局部变量环境和swapColors()的局部变量环境。swapcolor（）的局部环境开始先在自己的Variable Object中搜索变量和函数名，找不到，则向上搜索changecolor作用域链。。。。。以此类推。但是，changecolor()函数是无法访问swapcolor中的变量。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2575359-31c07041f11d1e92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域链\"></p>\n<hr>\n<p>通过上面的分析，我们可以得知内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间是线性、有次序的。每个环境都可以向上搜索作用域链，以便查询变量和函数名；</p>\n<p>tip:通过下面两种情况，即当执行流进入下列任何语句时，作用域链就会得到加长：</p>\n<ul>\n<li>try-catch 语句的 catch 块;</li>\n<li>with 语句。</li>\n</ul>\n<h2 id=\"三、没有块级作用域（在-let-出现以前）\"><a href=\"#三、没有块级作用域（在-let-出现以前）\" class=\"headerlink\" title=\"三、没有块级作用域（在 let 出现以前）\"></a>三、没有块级作用域（在 let 出现以前）</h2><p>看两个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">情况1：</div><div class=\"line\">for (var i = 0;i&lt;10;i++) &#123;</div><div class=\"line\">  // do something</div><div class=\"line\">&#125;</div><div class=\"line\">console.info(i);  // 10</div><div class=\"line\">情况2：</div><div class=\"line\">for (let i = 0;i&lt;10;i++) &#123;</div><div class=\"line\">  // do something</div><div class=\"line\">&#125;</div><div class=\"line\">console.info(i);  // error</div></pre></td></tr></table></figure>\n<p>从上面的例子中可以看出，JavaScript没有像其他类C的语言（由花括号封闭的代码块都有自己的作用域）一样。在使用for语句时尤其记住这点。</p>\n<h2 id=\"四、声明变量\"><a href=\"#四、声明变量\" class=\"headerlink\" title=\"四、声明变量\"></a>四、声明变量</h2><p>使用var声明变量时，这个变量将被自动添加到距离最近的可用环境中。对于函数而言，自然声明的变量就会被添加到函数的局部环境中，变量在整个函数环境内都是可用的。</p>\n<p>   但是，如果变量没有是用var进行声明，将会被添加到全局环境，也就是说成位全局变量了。（只有当执行流执行到该语句时，才会被添加到全局变量的变量对象中）</p>\n<p>看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">情况1：</div><div class=\"line\">var x = 1;</div><div class=\"line\">function rain() &#123;</div><div class=\"line\">  console.info(x);  // 1</div><div class=\"line\">&#125;</div><div class=\"line\">rain(); </div><div class=\"line\">情况2：</div><div class=\"line\">var x = 1;</div><div class=\"line\">function rain() &#123;</div><div class=\"line\">  console.info(x);  //undefined</div><div class=\"line\">  var x = 10;</div><div class=\"line\">  console.info(x); // 10 </div><div class=\"line\">&#125;</div><div class=\"line\">rain();</div></pre></td></tr></table></figure>\n<p>情况1中得到的1 和 情况2中得到的10，通过上述作用域链的关系，我们较为容易理解。那情况2中的 undefined 是怎么回事儿呢？答案是预解析，我们看下面一段代码，和上面的代码等价</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var x = 1;</div><div class=\"line\">function rain() &#123;</div><div class=\"line\">  var x;</div><div class=\"line\">  console.info(x);  //undefined</div><div class=\"line\">  x = 10;</div><div class=\"line\">  console.info(x); // 10 </div><div class=\"line\">&#125;</div><div class=\"line\">rain();</div></pre></td></tr></table></figure>\n<p>因为JavaScript引擎会预解析代码中变量和函数的定义。导致调用x的时候，局部执行环境已经有了x，就不向上继续寻找x，也就访问不到全局变量的x。而此时局部变量x还未赋值，这时候输出也就是 undefined 了。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在javascript的学习中，执行环境、作用域是2个非常非常重要和基本的概念，理解了这2个概念对于javsacript中很多脚本的运行结果就能明白其中的道理了，比如搞清作用域和执行环境对于闭包的理解至关重要。</p>\n</blockquote>\n<h2 id=\"一、执行环境（exection-context-也有称之为执行上下文）\"><a href=\"#一、执行环境（exection-context-也有称之为执行上下文）\" class=\"headerlink\" title=\"一、执行环境（exection context,也有称之为执行上下文）\"></a>一、执行环境（exection context,也有称之为执行上下文）</h2><blockquote>\n<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的<strong>变量对象</strong> (variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器会处理数据时会在后台使用它。                                  —《JavaScript高程》</p>\n</blockquote>\n<p>当这个执行环境是函数的时候，这个变量对象就是函数的活动对象。活动对象最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。</p>\n<h2 id=\"二、作用域链（scope-chain）\"><a href=\"#二、作用域链（scope-chain）\" class=\"headerlink\" title=\"二、作用域链（scope chain）\"></a>二、作用域链（scope chain）</h2><p>了解了变量对象之后，理解作用域链就容易了。</p>\n<blockquote>\n<p>在代码在一个环境执行时，会创建变量对象的一个 <strong>作用域链</strong>。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。</p>\n</blockquote>\n<p><strong>整个作用域链是由不同执行位置上的变量对象（Variable Object）按照规则所构建一个链表。</strong></p>\n<p>作用域链的前端，始终都是当前执行的代码所在环境的变量对象。下一个变量对象来自包含（外部）环境，而下一个变量对象则来自下一个包含对象。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链的最后一个对象。</p>\n<p>引用高程中的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var color=&quot;blue&quot;;</div><div class=\"line\"> function changecolor()&#123;</div><div class=\"line\">    var anothercolor=&quot;red&quot;;</div><div class=\"line\">    function swapcolors()&#123;</div><div class=\"line\">\tvar tempcolor=anothercolor;</div><div class=\"line\">\tanothercolor=color;</div><div class=\"line\">\tcolor=tempcolor;</div><div class=\"line\">       // Todo something\t\t</div><div class=\"line\">     &#125;</div><div class=\"line\">    swapcolors();</div><div class=\"line\">&#125;</div><div class=\"line\">changecolor();</div><div class=\"line\"> //这里不能访问tempcolor和anocolor;但是可以访问color;</div><div class=\"line\">alert(&quot;Color is now  &quot;+color);</div></pre></td></tr></table></figure>\n<p>上面例子涉及了3个执行环境：全局变量、changeColor()的局部变量环境和swapColors()的局部变量环境。swapcolor（）的局部环境开始先在自己的Variable Object中搜索变量和函数名，找不到，则向上搜索changecolor作用域链。。。。。以此类推。但是，changecolor()函数是无法访问swapcolor中的变量。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2575359-31c07041f11d1e92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"作用域链\"></p>\n<hr>\n<p>通过上面的分析，我们可以得知内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间是线性、有次序的。每个环境都可以向上搜索作用域链，以便查询变量和函数名；</p>\n<p>tip:通过下面两种情况，即当执行流进入下列任何语句时，作用域链就会得到加长：</p>\n<ul>\n<li>try-catch 语句的 catch 块;</li>\n<li>with 语句。</li>\n</ul>\n<h2 id=\"三、没有块级作用域（在-let-出现以前）\"><a href=\"#三、没有块级作用域（在-let-出现以前）\" class=\"headerlink\" title=\"三、没有块级作用域（在 let 出现以前）\"></a>三、没有块级作用域（在 let 出现以前）</h2><p>看两个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">情况1：</div><div class=\"line\">for (var i = 0;i&lt;10;i++) &#123;</div><div class=\"line\">  // do something</div><div class=\"line\">&#125;</div><div class=\"line\">console.info(i);  // 10</div><div class=\"line\">情况2：</div><div class=\"line\">for (let i = 0;i&lt;10;i++) &#123;</div><div class=\"line\">  // do something</div><div class=\"line\">&#125;</div><div class=\"line\">console.info(i);  // error</div></pre></td></tr></table></figure>\n<p>从上面的例子中可以看出，JavaScript没有像其他类C的语言（由花括号封闭的代码块都有自己的作用域）一样。在使用for语句时尤其记住这点。</p>\n<h2 id=\"四、声明变量\"><a href=\"#四、声明变量\" class=\"headerlink\" title=\"四、声明变量\"></a>四、声明变量</h2><p>使用var声明变量时，这个变量将被自动添加到距离最近的可用环境中。对于函数而言，自然声明的变量就会被添加到函数的局部环境中，变量在整个函数环境内都是可用的。</p>\n<p>   但是，如果变量没有是用var进行声明，将会被添加到全局环境，也就是说成位全局变量了。（只有当执行流执行到该语句时，才会被添加到全局变量的变量对象中）</p>\n<p>看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">情况1：</div><div class=\"line\">var x = 1;</div><div class=\"line\">function rain() &#123;</div><div class=\"line\">  console.info(x);  // 1</div><div class=\"line\">&#125;</div><div class=\"line\">rain(); </div><div class=\"line\">情况2：</div><div class=\"line\">var x = 1;</div><div class=\"line\">function rain() &#123;</div><div class=\"line\">  console.info(x);  //undefined</div><div class=\"line\">  var x = 10;</div><div class=\"line\">  console.info(x); // 10 </div><div class=\"line\">&#125;</div><div class=\"line\">rain();</div></pre></td></tr></table></figure>\n<p>情况1中得到的1 和 情况2中得到的10，通过上述作用域链的关系，我们较为容易理解。那情况2中的 undefined 是怎么回事儿呢？答案是预解析，我们看下面一段代码，和上面的代码等价</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var x = 1;</div><div class=\"line\">function rain() &#123;</div><div class=\"line\">  var x;</div><div class=\"line\">  console.info(x);  //undefined</div><div class=\"line\">  x = 10;</div><div class=\"line\">  console.info(x); // 10 </div><div class=\"line\">&#125;</div><div class=\"line\">rain();</div></pre></td></tr></table></figure>\n<p>因为JavaScript引擎会预解析代码中变量和函数的定义。导致调用x的时候，局部执行环境已经有了x，就不向上继续寻找x，也就访问不到全局变量的x。而此时局部变量x还未赋值，这时候输出也就是 undefined 了。</p>\n"},{"date":"2016-07-02T11:45:00.000Z","status":"public","description":"CSS常用到的选择器，做一个整理","title":"CSS系列之选择器","_content":"\n#CSS选择器\n\n---\n\n\n\n### 二、多元素的组合选择器\n\n序号\t选择器\t含义\n\n1.\tE,F\t多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔\n\n2.\tE F\t后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔\n\n3.\tE > F\t子元素选择器，匹配所有E元素的子元素F\n4.\tE + F\t毗邻元素选择器，匹配所有紧随E元素之后的同级元素F\n\n实例：\n\n```\ndiv p { color:#f00; }\n#nav li { display:inline; }\n#nav a { font-weight:bold; }\ndiv > strong { color:#f00; }\np + p { color:#f00; }\n```\n\n### 三、css 2.1 属性选择器\n\n\n序号\t选择器\t含义\n\n5.\tE[att]\t匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如\"[cheacked]\"。以下同。）\n6.\tE[att=val]\t匹配所有att属性等于\"val\"的E元素\n7.\tE[att~=val]\t匹配所有att属性具有多个空格分隔的值、其中一个值等于\"val\"的E元素\n8.\tE[att|=val]\t匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以\"val\"开头的E元素，主要用于lang属性，比如\"en\"、\"en-us\"、\"en-gb\"等等\n\n实例：\n\n```\np:first-line { font-weight:bold; color;#600; }\n.preamble:first-letter { font-size:1.5em; font-weight:bold; }\n.cbb:before { content:\"\"; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; }\na:link:after { content: \" (\" attr(href) \") \"; }\n```\n\n### 四、CSS 2.1中的伪类\n\n13.\tE:first-child\t匹配父元素的第一个子元素\n14.\tE:link\t匹配所有未被点击的链接\n15.\tE:visited\t匹配所有已被点击的链接\n16.\tE:active\t匹配鼠标已经其上按下、还没有释放的E元素\n17.\tE:hover\t匹配鼠标悬停其上的E元素\n18.\tE:focus\t匹配获得当前焦点的E元素\n19.\tE:lang(c)\t匹配lang属性等于c的E元素\n\n实例：\n\n```\np:first-child { font-style:italic; }\ninput[type=text]:focus { color:#000; background:#ffe; }\ninput[type=text]:focus:hover { background:#fff; }\nq:lang(sv) { quotes: \"\\201D\" \"\\201D\" \"\\2019\" \"\\2019\"; }\n```\n\n### 五、 CSS 2.1中的伪元素\n\n20.\tE:first-line\t匹配E元素的第一行\n21.\tE:first-letter\t匹配E元素的第一个字母\n22.\tE:before\t在E元素之前插入生成的内容\n23.\tE:after\t在E元素之后插入生成的内容\n\n实例：\n```\np:first-line { font-weight:bold; color;#600; }\n.preamble:first-letter { font-size:1.5em; font-weight:bold; }\n.cbb:before { content:\"\"; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; }\na:link:after { content: \" (\" attr(href) \") \"; }\n```\n\n### 六、CSS 3的同级元素通用选择器\n\n1. E ~ F\t匹配任何在E元素之后的同级F元素\n\n```\np ~ ul { background:#ff0; }\n```\n\n### 七、CSS 3 属性选择器\n\n25.\tE[att^=\"val\"]\t属性att的值以\"val\"开头的元素\n26.\tE[att$=\"val\"]\t属性att的值以\"val\"结尾的元素\n27.\tE[att*=\"val\"]\t属性att的值包含\"val\"字符串的元素\n\n实例：\n```\ndiv[id^=\"nav\"] { background:#ff0; }\n```\n\n### 八、CSS 3中与用户界面有关的伪类\n\n28.\tE:enabled\t匹配表单中激活的元素\n29.\tE:disabled\t匹配表单中禁用的元素\n30.\tE:checked\t匹配表单中被选中的radio（单选框）或checkbox（复选框）元素\n31.\tE::selection\t匹配用户当前选中的元素\n\n实例：\n\n```\ninput[type=\"text\"]:disabled { background:#ddd; }\n```\n\n### 九、CSS 3中的结构性伪类\n\n32.\tE:root\t匹配文档的根元素，对于HTML文档，就是HTML元素\n33.\tE:nth-child(n)\t匹配其父元素的第n个子元素，第一个编号为1\n34.\tE:nth-last-child(n)\t匹配其父元素的倒数第n个子元素，第一个编号为1\n35.\tE:nth-of-type(n)\t与:nth-child()作用类似，但是仅匹配使用同种标签的元素\n36.\tE:nth-last-of-type(n)\t与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素\n37.\tE:last-child\t匹配父元素的最后一个子元素，等同于:nth-last-child(1)\n38.\tE:first-of-type\t匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)\n39.\tE:last-of-type\t匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)\n40.\tE:only-child\t匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)\n41.\tE:only-of-type\t匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)\n42.\tE:empty\t匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素\n\n\n实例：\n\n```\np:nth-child(3) { color:#f00; }\np:nth-child(odd) { color:#f00; }\np:nth-child(even) { color:#f00; }\np:nth-child(3n+0) { color:#f00; }\np:nth-child(3n) { color:#f00; }\ntr:nth-child(2n+11) { background:#ff0; }\ntr:nth-last-child(2) { background:#ff0; }\np:last-child { background:#ff0; }\np:only-child { background:#ff0; }\np:empty { background:#ff0; }\n```\n\n### 十、CSS 3的反选伪类\n\n43.\tE:not(s)\t匹配不符合当前选择器的任何元素\n\n```\n:not(p) { border:1px solid #ccc; }\n```\n\n### 十一、CSS 3中的 :target 伪类\n\n44.\tE:target\t匹配文档中特定\"id\"点击后的效果\n\n\n收藏自 [阮老师的文章:CSS选择器](http://www.ruanyifeng.com/blog/2009/03/css_selectors.html)","source":"_posts/CSS系列之选择器.md","raw":"---\ndate: 2016-07-02 19:45\nstatus: public\ndescription: CSS常用到的选择器，做一个整理\ntitle: CSS系列之选择器\n---\n\n#CSS选择器\n\n---\n\n\n\n### 二、多元素的组合选择器\n\n序号\t选择器\t含义\n\n1.\tE,F\t多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔\n\n2.\tE F\t后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔\n\n3.\tE > F\t子元素选择器，匹配所有E元素的子元素F\n4.\tE + F\t毗邻元素选择器，匹配所有紧随E元素之后的同级元素F\n\n实例：\n\n```\ndiv p { color:#f00; }\n#nav li { display:inline; }\n#nav a { font-weight:bold; }\ndiv > strong { color:#f00; }\np + p { color:#f00; }\n```\n\n### 三、css 2.1 属性选择器\n\n\n序号\t选择器\t含义\n\n5.\tE[att]\t匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如\"[cheacked]\"。以下同。）\n6.\tE[att=val]\t匹配所有att属性等于\"val\"的E元素\n7.\tE[att~=val]\t匹配所有att属性具有多个空格分隔的值、其中一个值等于\"val\"的E元素\n8.\tE[att|=val]\t匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以\"val\"开头的E元素，主要用于lang属性，比如\"en\"、\"en-us\"、\"en-gb\"等等\n\n实例：\n\n```\np:first-line { font-weight:bold; color;#600; }\n.preamble:first-letter { font-size:1.5em; font-weight:bold; }\n.cbb:before { content:\"\"; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; }\na:link:after { content: \" (\" attr(href) \") \"; }\n```\n\n### 四、CSS 2.1中的伪类\n\n13.\tE:first-child\t匹配父元素的第一个子元素\n14.\tE:link\t匹配所有未被点击的链接\n15.\tE:visited\t匹配所有已被点击的链接\n16.\tE:active\t匹配鼠标已经其上按下、还没有释放的E元素\n17.\tE:hover\t匹配鼠标悬停其上的E元素\n18.\tE:focus\t匹配获得当前焦点的E元素\n19.\tE:lang(c)\t匹配lang属性等于c的E元素\n\n实例：\n\n```\np:first-child { font-style:italic; }\ninput[type=text]:focus { color:#000; background:#ffe; }\ninput[type=text]:focus:hover { background:#fff; }\nq:lang(sv) { quotes: \"\\201D\" \"\\201D\" \"\\2019\" \"\\2019\"; }\n```\n\n### 五、 CSS 2.1中的伪元素\n\n20.\tE:first-line\t匹配E元素的第一行\n21.\tE:first-letter\t匹配E元素的第一个字母\n22.\tE:before\t在E元素之前插入生成的内容\n23.\tE:after\t在E元素之后插入生成的内容\n\n实例：\n```\np:first-line { font-weight:bold; color;#600; }\n.preamble:first-letter { font-size:1.5em; font-weight:bold; }\n.cbb:before { content:\"\"; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; }\na:link:after { content: \" (\" attr(href) \") \"; }\n```\n\n### 六、CSS 3的同级元素通用选择器\n\n1. E ~ F\t匹配任何在E元素之后的同级F元素\n\n```\np ~ ul { background:#ff0; }\n```\n\n### 七、CSS 3 属性选择器\n\n25.\tE[att^=\"val\"]\t属性att的值以\"val\"开头的元素\n26.\tE[att$=\"val\"]\t属性att的值以\"val\"结尾的元素\n27.\tE[att*=\"val\"]\t属性att的值包含\"val\"字符串的元素\n\n实例：\n```\ndiv[id^=\"nav\"] { background:#ff0; }\n```\n\n### 八、CSS 3中与用户界面有关的伪类\n\n28.\tE:enabled\t匹配表单中激活的元素\n29.\tE:disabled\t匹配表单中禁用的元素\n30.\tE:checked\t匹配表单中被选中的radio（单选框）或checkbox（复选框）元素\n31.\tE::selection\t匹配用户当前选中的元素\n\n实例：\n\n```\ninput[type=\"text\"]:disabled { background:#ddd; }\n```\n\n### 九、CSS 3中的结构性伪类\n\n32.\tE:root\t匹配文档的根元素，对于HTML文档，就是HTML元素\n33.\tE:nth-child(n)\t匹配其父元素的第n个子元素，第一个编号为1\n34.\tE:nth-last-child(n)\t匹配其父元素的倒数第n个子元素，第一个编号为1\n35.\tE:nth-of-type(n)\t与:nth-child()作用类似，但是仅匹配使用同种标签的元素\n36.\tE:nth-last-of-type(n)\t与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素\n37.\tE:last-child\t匹配父元素的最后一个子元素，等同于:nth-last-child(1)\n38.\tE:first-of-type\t匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)\n39.\tE:last-of-type\t匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)\n40.\tE:only-child\t匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)\n41.\tE:only-of-type\t匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)\n42.\tE:empty\t匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素\n\n\n实例：\n\n```\np:nth-child(3) { color:#f00; }\np:nth-child(odd) { color:#f00; }\np:nth-child(even) { color:#f00; }\np:nth-child(3n+0) { color:#f00; }\np:nth-child(3n) { color:#f00; }\ntr:nth-child(2n+11) { background:#ff0; }\ntr:nth-last-child(2) { background:#ff0; }\np:last-child { background:#ff0; }\np:only-child { background:#ff0; }\np:empty { background:#ff0; }\n```\n\n### 十、CSS 3的反选伪类\n\n43.\tE:not(s)\t匹配不符合当前选择器的任何元素\n\n```\n:not(p) { border:1px solid #ccc; }\n```\n\n### 十一、CSS 3中的 :target 伪类\n\n44.\tE:target\t匹配文档中特定\"id\"点击后的效果\n\n\n收藏自 [阮老师的文章:CSS选择器](http://www.ruanyifeng.com/blog/2009/03/css_selectors.html)","slug":"CSS系列之选择器","published":1,"updated":"2017-03-29T14:23:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca5v0009ib1c07zzddzo","content":"<p>#CSS选择器</p>\n<hr>\n<h3 id=\"二、多元素的组合选择器\"><a href=\"#二、多元素的组合选择器\" class=\"headerlink\" title=\"二、多元素的组合选择器\"></a>二、多元素的组合选择器</h3><p>序号    选择器    含义</p>\n<ol>\n<li><p>E,F    多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔</p>\n</li>\n<li><p>E F    后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔</p>\n</li>\n<li><p>E &gt; F    子元素选择器，匹配所有E元素的子元素F</p>\n</li>\n<li>E + F    毗邻元素选择器，匹配所有紧随E元素之后的同级元素F</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">div p &#123; color:#f00; &#125;</div><div class=\"line\">#nav li &#123; display:inline; &#125;</div><div class=\"line\">#nav a &#123; font-weight:bold; &#125;</div><div class=\"line\">div &gt; strong &#123; color:#f00; &#125;</div><div class=\"line\">p + p &#123; color:#f00; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"三、css-2-1-属性选择器\"><a href=\"#三、css-2-1-属性选择器\" class=\"headerlink\" title=\"三、css 2.1 属性选择器\"></a>三、css 2.1 属性选择器</h3><p>序号    选择器    含义</p>\n<ol>\n<li>E[att]    匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如”[cheacked]”。以下同。）</li>\n<li>E[att=val]    匹配所有att属性等于”val”的E元素</li>\n<li>E[att~=val]    匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素</li>\n<li>E[att|=val]    匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-line &#123; font-weight:bold; color;#600; &#125;</div><div class=\"line\">.preamble:first-letter &#123; font-size:1.5em; font-weight:bold; &#125;</div><div class=\"line\">.cbb:before &#123; content:&quot;&quot;; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; &#125;</div><div class=\"line\">a:link:after &#123; content: &quot; (&quot; attr(href) &quot;) &quot;; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四、CSS-2-1中的伪类\"><a href=\"#四、CSS-2-1中的伪类\" class=\"headerlink\" title=\"四、CSS 2.1中的伪类\"></a>四、CSS 2.1中的伪类</h3><ol>\n<li>E:first-child    匹配父元素的第一个子元素</li>\n<li>E:link    匹配所有未被点击的链接</li>\n<li>E:visited    匹配所有已被点击的链接</li>\n<li>E:active    匹配鼠标已经其上按下、还没有释放的E元素</li>\n<li>E:hover    匹配鼠标悬停其上的E元素</li>\n<li>E:focus    匹配获得当前焦点的E元素</li>\n<li>E:lang(c)    匹配lang属性等于c的E元素</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-child &#123; font-style:italic; &#125;</div><div class=\"line\">input[type=text]:focus &#123; color:#000; background:#ffe; &#125;</div><div class=\"line\">input[type=text]:focus:hover &#123; background:#fff; &#125;</div><div class=\"line\">q:lang(sv) &#123; quotes: &quot;\\201D&quot; &quot;\\201D&quot; &quot;\\2019&quot; &quot;\\2019&quot;; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"五、-CSS-2-1中的伪元素\"><a href=\"#五、-CSS-2-1中的伪元素\" class=\"headerlink\" title=\"五、 CSS 2.1中的伪元素\"></a>五、 CSS 2.1中的伪元素</h3><ol>\n<li>E:first-line    匹配E元素的第一行</li>\n<li>E:first-letter    匹配E元素的第一个字母</li>\n<li>E:before    在E元素之前插入生成的内容</li>\n<li>E:after    在E元素之后插入生成的内容</li>\n</ol>\n<p>实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-line &#123; font-weight:bold; color;#600; &#125;</div><div class=\"line\">.preamble:first-letter &#123; font-size:1.5em; font-weight:bold; &#125;</div><div class=\"line\">.cbb:before &#123; content:&quot;&quot;; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; &#125;</div><div class=\"line\">a:link:after &#123; content: &quot; (&quot; attr(href) &quot;) &quot;; &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"六、CSS-3的同级元素通用选择器\"><a href=\"#六、CSS-3的同级元素通用选择器\" class=\"headerlink\" title=\"六、CSS 3的同级元素通用选择器\"></a>六、CSS 3的同级元素通用选择器</h3><ol>\n<li>E ~ F    匹配任何在E元素之后的同级F元素</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">p ~ ul &#123; background:#ff0; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"七、CSS-3-属性选择器\"><a href=\"#七、CSS-3-属性选择器\" class=\"headerlink\" title=\"七、CSS 3 属性选择器\"></a>七、CSS 3 属性选择器</h3><ol>\n<li>E[att^=”val”]    属性att的值以”val”开头的元素</li>\n<li>E[att$=”val”]    属性att的值以”val”结尾的元素</li>\n<li>E[att*=”val”]    属性att的值包含”val”字符串的元素</li>\n</ol>\n<p>实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">div[id^=&quot;nav&quot;] &#123; background:#ff0; &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"八、CSS-3中与用户界面有关的伪类\"><a href=\"#八、CSS-3中与用户界面有关的伪类\" class=\"headerlink\" title=\"八、CSS 3中与用户界面有关的伪类\"></a>八、CSS 3中与用户界面有关的伪类</h3><ol>\n<li>E:enabled    匹配表单中激活的元素</li>\n<li>E:disabled    匹配表单中禁用的元素</li>\n<li>E:checked    匹配表单中被选中的radio（单选框）或checkbox（复选框）元素</li>\n<li>E::selection    匹配用户当前选中的元素</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">input[type=&quot;text&quot;]:disabled &#123; background:#ddd; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"九、CSS-3中的结构性伪类\"><a href=\"#九、CSS-3中的结构性伪类\" class=\"headerlink\" title=\"九、CSS 3中的结构性伪类\"></a>九、CSS 3中的结构性伪类</h3><ol>\n<li>E:root    匹配文档的根元素，对于HTML文档，就是HTML元素</li>\n<li>E:nth-child(n)    匹配其父元素的第n个子元素，第一个编号为1</li>\n<li>E:nth-last-child(n)    匹配其父元素的倒数第n个子元素，第一个编号为1</li>\n<li>E:nth-of-type(n)    与:nth-child()作用类似，但是仅匹配使用同种标签的元素</li>\n<li>E:nth-last-of-type(n)    与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</li>\n<li>E:last-child    匹配父元素的最后一个子元素，等同于:nth-last-child(1)</li>\n<li>E:first-of-type    匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</li>\n<li>E:last-of-type    匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</li>\n<li>E:only-child    匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</li>\n<li>E:only-of-type    匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</li>\n<li>E:empty    匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:nth-child(3) &#123; color:#f00; &#125;</div><div class=\"line\">p:nth-child(odd) &#123; color:#f00; &#125;</div><div class=\"line\">p:nth-child(even) &#123; color:#f00; &#125;</div><div class=\"line\">p:nth-child(3n+0) &#123; color:#f00; &#125;</div><div class=\"line\">p:nth-child(3n) &#123; color:#f00; &#125;</div><div class=\"line\">tr:nth-child(2n+11) &#123; background:#ff0; &#125;</div><div class=\"line\">tr:nth-last-child(2) &#123; background:#ff0; &#125;</div><div class=\"line\">p:last-child &#123; background:#ff0; &#125;</div><div class=\"line\">p:only-child &#123; background:#ff0; &#125;</div><div class=\"line\">p:empty &#123; background:#ff0; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"十、CSS-3的反选伪类\"><a href=\"#十、CSS-3的反选伪类\" class=\"headerlink\" title=\"十、CSS 3的反选伪类\"></a>十、CSS 3的反选伪类</h3><ol>\n<li>E:not(s)    匹配不符合当前选择器的任何元素</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">:not(p) &#123; border:1px solid #ccc; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"十一、CSS-3中的-target-伪类\"><a href=\"#十一、CSS-3中的-target-伪类\" class=\"headerlink\" title=\"十一、CSS 3中的 :target 伪类\"></a>十一、CSS 3中的 :target 伪类</h3><ol>\n<li>E:target    匹配文档中特定”id”点击后的效果</li>\n</ol>\n<p>收藏自 <a href=\"http://www.ruanyifeng.com/blog/2009/03/css_selectors.html\" target=\"_blank\" rel=\"external\">阮老师的文章:CSS选择器</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>#CSS选择器</p>\n<hr>\n<h3 id=\"二、多元素的组合选择器\"><a href=\"#二、多元素的组合选择器\" class=\"headerlink\" title=\"二、多元素的组合选择器\"></a>二、多元素的组合选择器</h3><p>序号    选择器    含义</p>\n<ol>\n<li><p>E,F    多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔</p>\n</li>\n<li><p>E F    后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔</p>\n</li>\n<li><p>E &gt; F    子元素选择器，匹配所有E元素的子元素F</p>\n</li>\n<li>E + F    毗邻元素选择器，匹配所有紧随E元素之后的同级元素F</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">div p &#123; color:#f00; &#125;</div><div class=\"line\">#nav li &#123; display:inline; &#125;</div><div class=\"line\">#nav a &#123; font-weight:bold; &#125;</div><div class=\"line\">div &gt; strong &#123; color:#f00; &#125;</div><div class=\"line\">p + p &#123; color:#f00; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"三、css-2-1-属性选择器\"><a href=\"#三、css-2-1-属性选择器\" class=\"headerlink\" title=\"三、css 2.1 属性选择器\"></a>三、css 2.1 属性选择器</h3><p>序号    选择器    含义</p>\n<ol>\n<li>E[att]    匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如”[cheacked]”。以下同。）</li>\n<li>E[att=val]    匹配所有att属性等于”val”的E元素</li>\n<li>E[att~=val]    匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素</li>\n<li>E[att|=val]    匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-line &#123; font-weight:bold; color;#600; &#125;</div><div class=\"line\">.preamble:first-letter &#123; font-size:1.5em; font-weight:bold; &#125;</div><div class=\"line\">.cbb:before &#123; content:&quot;&quot;; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; &#125;</div><div class=\"line\">a:link:after &#123; content: &quot; (&quot; attr(href) &quot;) &quot;; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"四、CSS-2-1中的伪类\"><a href=\"#四、CSS-2-1中的伪类\" class=\"headerlink\" title=\"四、CSS 2.1中的伪类\"></a>四、CSS 2.1中的伪类</h3><ol>\n<li>E:first-child    匹配父元素的第一个子元素</li>\n<li>E:link    匹配所有未被点击的链接</li>\n<li>E:visited    匹配所有已被点击的链接</li>\n<li>E:active    匹配鼠标已经其上按下、还没有释放的E元素</li>\n<li>E:hover    匹配鼠标悬停其上的E元素</li>\n<li>E:focus    匹配获得当前焦点的E元素</li>\n<li>E:lang(c)    匹配lang属性等于c的E元素</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-child &#123; font-style:italic; &#125;</div><div class=\"line\">input[type=text]:focus &#123; color:#000; background:#ffe; &#125;</div><div class=\"line\">input[type=text]:focus:hover &#123; background:#fff; &#125;</div><div class=\"line\">q:lang(sv) &#123; quotes: &quot;\\201D&quot; &quot;\\201D&quot; &quot;\\2019&quot; &quot;\\2019&quot;; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"五、-CSS-2-1中的伪元素\"><a href=\"#五、-CSS-2-1中的伪元素\" class=\"headerlink\" title=\"五、 CSS 2.1中的伪元素\"></a>五、 CSS 2.1中的伪元素</h3><ol>\n<li>E:first-line    匹配E元素的第一行</li>\n<li>E:first-letter    匹配E元素的第一个字母</li>\n<li>E:before    在E元素之前插入生成的内容</li>\n<li>E:after    在E元素之后插入生成的内容</li>\n</ol>\n<p>实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:first-line &#123; font-weight:bold; color;#600; &#125;</div><div class=\"line\">.preamble:first-letter &#123; font-size:1.5em; font-weight:bold; &#125;</div><div class=\"line\">.cbb:before &#123; content:&quot;&quot;; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; &#125;</div><div class=\"line\">a:link:after &#123; content: &quot; (&quot; attr(href) &quot;) &quot;; &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"六、CSS-3的同级元素通用选择器\"><a href=\"#六、CSS-3的同级元素通用选择器\" class=\"headerlink\" title=\"六、CSS 3的同级元素通用选择器\"></a>六、CSS 3的同级元素通用选择器</h3><ol>\n<li>E ~ F    匹配任何在E元素之后的同级F元素</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">p ~ ul &#123; background:#ff0; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"七、CSS-3-属性选择器\"><a href=\"#七、CSS-3-属性选择器\" class=\"headerlink\" title=\"七、CSS 3 属性选择器\"></a>七、CSS 3 属性选择器</h3><ol>\n<li>E[att^=”val”]    属性att的值以”val”开头的元素</li>\n<li>E[att$=”val”]    属性att的值以”val”结尾的元素</li>\n<li>E[att*=”val”]    属性att的值包含”val”字符串的元素</li>\n</ol>\n<p>实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">div[id^=&quot;nav&quot;] &#123; background:#ff0; &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"八、CSS-3中与用户界面有关的伪类\"><a href=\"#八、CSS-3中与用户界面有关的伪类\" class=\"headerlink\" title=\"八、CSS 3中与用户界面有关的伪类\"></a>八、CSS 3中与用户界面有关的伪类</h3><ol>\n<li>E:enabled    匹配表单中激活的元素</li>\n<li>E:disabled    匹配表单中禁用的元素</li>\n<li>E:checked    匹配表单中被选中的radio（单选框）或checkbox（复选框）元素</li>\n<li>E::selection    匹配用户当前选中的元素</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">input[type=&quot;text&quot;]:disabled &#123; background:#ddd; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"九、CSS-3中的结构性伪类\"><a href=\"#九、CSS-3中的结构性伪类\" class=\"headerlink\" title=\"九、CSS 3中的结构性伪类\"></a>九、CSS 3中的结构性伪类</h3><ol>\n<li>E:root    匹配文档的根元素，对于HTML文档，就是HTML元素</li>\n<li>E:nth-child(n)    匹配其父元素的第n个子元素，第一个编号为1</li>\n<li>E:nth-last-child(n)    匹配其父元素的倒数第n个子元素，第一个编号为1</li>\n<li>E:nth-of-type(n)    与:nth-child()作用类似，但是仅匹配使用同种标签的元素</li>\n<li>E:nth-last-of-type(n)    与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</li>\n<li>E:last-child    匹配父元素的最后一个子元素，等同于:nth-last-child(1)</li>\n<li>E:first-of-type    匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</li>\n<li>E:last-of-type    匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</li>\n<li>E:only-child    匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</li>\n<li>E:only-of-type    匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</li>\n<li>E:empty    匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</li>\n</ol>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">p:nth-child(3) &#123; color:#f00; &#125;</div><div class=\"line\">p:nth-child(odd) &#123; color:#f00; &#125;</div><div class=\"line\">p:nth-child(even) &#123; color:#f00; &#125;</div><div class=\"line\">p:nth-child(3n+0) &#123; color:#f00; &#125;</div><div class=\"line\">p:nth-child(3n) &#123; color:#f00; &#125;</div><div class=\"line\">tr:nth-child(2n+11) &#123; background:#ff0; &#125;</div><div class=\"line\">tr:nth-last-child(2) &#123; background:#ff0; &#125;</div><div class=\"line\">p:last-child &#123; background:#ff0; &#125;</div><div class=\"line\">p:only-child &#123; background:#ff0; &#125;</div><div class=\"line\">p:empty &#123; background:#ff0; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"十、CSS-3的反选伪类\"><a href=\"#十、CSS-3的反选伪类\" class=\"headerlink\" title=\"十、CSS 3的反选伪类\"></a>十、CSS 3的反选伪类</h3><ol>\n<li>E:not(s)    匹配不符合当前选择器的任何元素</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">:not(p) &#123; border:1px solid #ccc; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"十一、CSS-3中的-target-伪类\"><a href=\"#十一、CSS-3中的-target-伪类\" class=\"headerlink\" title=\"十一、CSS 3中的 :target 伪类\"></a>十一、CSS 3中的 :target 伪类</h3><ol>\n<li>E:target    匹配文档中特定”id”点击后的效果</li>\n</ol>\n<p>收藏自 <a href=\"http://www.ruanyifeng.com/blog/2009/03/css_selectors.html\">阮老师的文章:CSS选择器</a></p>\n"},{"date":"2016-09-15T16:00:00.000Z","status":"public","description":"作为软件开发者，我们要能够用编程语言和数据结构来解决问题。对于任何方向的编程人员来说数据结构和算法都是极其重要的，称之为程序的灵魂也不为过。然许多前端人员对由于错误的理解，认为前端不需学习算法，只需要熟练的实现网页布局和特效，便可万事大吉。首先持这种想法的前端人员显然是认为自己还是10年前的前端。面对如今日新月异的技术发展和前端职责。如果抱着这种思想工作的话，离被行业淘汰也就不远了。本系列将简要介绍JavaScript实现基本的数据结构和常见的算法。也是自己对这方面的知识做个简单的整理","title":"JavaScript基本数据结构","_content":"\n> 作为软件开发者，我们要能够用编程语言和数据结构来解决问题。对于任何方向的编程人员来说数据结构和算法都是极其重要的，称之为程序的灵魂也不为过。然许多前端人员对由于错误的理解，认为前端不需学习算法，只需要熟练的实现网页布局和特效，便可万事大吉。首先持这种想法的前端人员显然是认为自己还是10年前的前端。面对如今日新月异的技术发展和前端职责。如果抱着这种思想工作的话，离被行业淘汰也就不远了。本系列将简要介绍JavaScript实现基本的数据结构和常见的算法。也是自己对这方面的知识做个简单的整理。\n\n> 本书主要参考[《学习JavaScript数据结构与算法》](https://book.douban.com/subject/26639401/)一书写成。文章如有错误，欢迎指出。\n\n## JavaScript中的数组\n> 几乎所有编程语言都原生支持数组类型，它是一段线性分配的内存，通过整数计算偏移并访问其中的元素。但JavaScript中的数组和我们常见如Java中的数组有些不同，众所周知，“JavaScript中，一切皆为对象”。JavaScript中的数组是一种拥有类数组（array-like）特性的对象，它比一个真正的数组慢，但它使用起来十分方便。\n\n### 数组的创建与初始化\n\n```\nvar arr = [];   // var arr = new Array();\n```\n其中很重要的点是与大多数其它语言不同，JavaScript数组的length是没有上界的。\n```\nvar arr = [1, 2, 3];\narr[10] = 10;  // 如果添加元素，它会动态增长\nconsole.log(arr.length);  //  11，也就是除了前3个和最后定义的10。中间的是8个undefined。\n```\n如果给数组的length设小，则将导致下标大于等于新length的属性被删除\n```\nvar arr = [1, 2, 3, 4];\narr.length = 2;\nconsole.log(arr);  // [1, 2]\n```\n数组的的常见增删方法就不一一介绍了，大家可以看[MDN Array的详细介绍](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n\n### 二维数组及多维数组\nJavaScript只支持一维数组，并不支持矩阵。但我们可以使用数组套数组实现多维数组。\n```\nvar Matrix = [\n  [1, 2, 2],\n  [2, 5, 7],\n  [2, 6, 8]\n];\nMatrix[2][1];  //6\n```\nJavaScript应该对矩阵提供更好的支持，我们可以自己定义一个。\n```\nArray.Matrix = function () {\n\n};\n```","source":"_posts/JavaScript基本数据结构.md","raw":"---\ndate: 2016-09-16\nstatus: public\ntags: [JavaScript]\ndescription: 作为软件开发者，我们要能够用编程语言和数据结构来解决问题。对于任何方向的编程人员来说数据结构和算法都是极其重要的，称之为程序的灵魂也不为过。然许多前端人员对由于错误的理解，认为前端不需学习算法，只需要熟练的实现网页布局和特效，便可万事大吉。首先持这种想法的前端人员显然是认为自己还是10年前的前端。面对如今日新月异的技术发展和前端职责。如果抱着这种思想工作的话，离被行业淘汰也就不远了。本系列将简要介绍JavaScript实现基本的数据结构和常见的算法。也是自己对这方面的知识做个简单的整理\ntitle: JavaScript基本数据结构\n---\n\n> 作为软件开发者，我们要能够用编程语言和数据结构来解决问题。对于任何方向的编程人员来说数据结构和算法都是极其重要的，称之为程序的灵魂也不为过。然许多前端人员对由于错误的理解，认为前端不需学习算法，只需要熟练的实现网页布局和特效，便可万事大吉。首先持这种想法的前端人员显然是认为自己还是10年前的前端。面对如今日新月异的技术发展和前端职责。如果抱着这种思想工作的话，离被行业淘汰也就不远了。本系列将简要介绍JavaScript实现基本的数据结构和常见的算法。也是自己对这方面的知识做个简单的整理。\n\n> 本书主要参考[《学习JavaScript数据结构与算法》](https://book.douban.com/subject/26639401/)一书写成。文章如有错误，欢迎指出。\n\n## JavaScript中的数组\n> 几乎所有编程语言都原生支持数组类型，它是一段线性分配的内存，通过整数计算偏移并访问其中的元素。但JavaScript中的数组和我们常见如Java中的数组有些不同，众所周知，“JavaScript中，一切皆为对象”。JavaScript中的数组是一种拥有类数组（array-like）特性的对象，它比一个真正的数组慢，但它使用起来十分方便。\n\n### 数组的创建与初始化\n\n```\nvar arr = [];   // var arr = new Array();\n```\n其中很重要的点是与大多数其它语言不同，JavaScript数组的length是没有上界的。\n```\nvar arr = [1, 2, 3];\narr[10] = 10;  // 如果添加元素，它会动态增长\nconsole.log(arr.length);  //  11，也就是除了前3个和最后定义的10。中间的是8个undefined。\n```\n如果给数组的length设小，则将导致下标大于等于新length的属性被删除\n```\nvar arr = [1, 2, 3, 4];\narr.length = 2;\nconsole.log(arr);  // [1, 2]\n```\n数组的的常见增删方法就不一一介绍了，大家可以看[MDN Array的详细介绍](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n\n### 二维数组及多维数组\nJavaScript只支持一维数组，并不支持矩阵。但我们可以使用数组套数组实现多维数组。\n```\nvar Matrix = [\n  [1, 2, 2],\n  [2, 5, 7],\n  [2, 6, 8]\n];\nMatrix[2][1];  //6\n```\nJavaScript应该对矩阵提供更好的支持，我们可以自己定义一个。\n```\nArray.Matrix = function () {\n\n};\n```","slug":"JavaScript基本数据结构","published":1,"updated":"2017-04-22T15:18:32.000Z","_id":"cj1teca5y000bib1c6tnmqzcx","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>作为软件开发者，我们要能够用编程语言和数据结构来解决问题。对于任何方向的编程人员来说数据结构和算法都是极其重要的，称之为程序的灵魂也不为过。然许多前端人员对由于错误的理解，认为前端不需学习算法，只需要熟练的实现网页布局和特效，便可万事大吉。首先持这种想法的前端人员显然是认为自己还是10年前的前端。面对如今日新月异的技术发展和前端职责。如果抱着这种思想工作的话，离被行业淘汰也就不远了。本系列将简要介绍JavaScript实现基本的数据结构和常见的算法。也是自己对这方面的知识做个简单的整理。</p>\n<p>本书主要参考<a href=\"https://book.douban.com/subject/26639401/\" target=\"_blank\" rel=\"external\">《学习JavaScript数据结构与算法》</a>一书写成。文章如有错误，欢迎指出。</p>\n</blockquote>\n<h2 id=\"JavaScript中的数组\"><a href=\"#JavaScript中的数组\" class=\"headerlink\" title=\"JavaScript中的数组\"></a>JavaScript中的数组</h2><blockquote>\n<p>几乎所有编程语言都原生支持数组类型，它是一段线性分配的内存，通过整数计算偏移并访问其中的元素。但JavaScript中的数组和我们常见如Java中的数组有些不同，众所周知，“JavaScript中，一切皆为对象”。JavaScript中的数组是一种拥有类数组（array-like）特性的对象，它比一个真正的数组慢，但它使用起来十分方便。</p>\n</blockquote>\n<h3 id=\"数组的创建与初始化\"><a href=\"#数组的创建与初始化\" class=\"headerlink\" title=\"数组的创建与初始化\"></a>数组的创建与初始化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [];   // var arr = new Array();</div></pre></td></tr></table></figure>\n<p>其中很重要的点是与大多数其它语言不同，JavaScript数组的length是没有上界的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [1, 2, 3];</div><div class=\"line\">arr[10] = 10;  // 如果添加元素，它会动态增长</div><div class=\"line\">console.log(arr.length);  //  11，也就是除了前3个和最后定义的10。中间的是8个undefined。</div></pre></td></tr></table></figure></p>\n<p>如果给数组的length设小，则将导致下标大于等于新length的属性被删除<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [1, 2, 3, 4];</div><div class=\"line\">arr.length = 2;</div><div class=\"line\">console.log(arr);  // [1, 2]</div></pre></td></tr></table></figure></p>\n<p>数组的的常见增删方法就不一一介绍了，大家可以看<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\" target=\"_blank\" rel=\"external\">MDN Array的详细介绍</a></p>\n<h3 id=\"二维数组及多维数组\"><a href=\"#二维数组及多维数组\" class=\"headerlink\" title=\"二维数组及多维数组\"></a>二维数组及多维数组</h3><p>JavaScript只支持一维数组，并不支持矩阵。但我们可以使用数组套数组实现多维数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Matrix = [</div><div class=\"line\">  [1, 2, 2],</div><div class=\"line\">  [2, 5, 7],</div><div class=\"line\">  [2, 6, 8]</div><div class=\"line\">];</div><div class=\"line\">Matrix[2][1];  //6</div></pre></td></tr></table></figure></p>\n<p>JavaScript应该对矩阵提供更好的支持，我们可以自己定义一个。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Array.Matrix = function () &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>作为软件开发者，我们要能够用编程语言和数据结构来解决问题。对于任何方向的编程人员来说数据结构和算法都是极其重要的，称之为程序的灵魂也不为过。然许多前端人员对由于错误的理解，认为前端不需学习算法，只需要熟练的实现网页布局和特效，便可万事大吉。首先持这种想法的前端人员显然是认为自己还是10年前的前端。面对如今日新月异的技术发展和前端职责。如果抱着这种思想工作的话，离被行业淘汰也就不远了。本系列将简要介绍JavaScript实现基本的数据结构和常见的算法。也是自己对这方面的知识做个简单的整理。</p>\n<p>本书主要参考<a href=\"https://book.douban.com/subject/26639401/\">《学习JavaScript数据结构与算法》</a>一书写成。文章如有错误，欢迎指出。</p>\n</blockquote>\n<h2 id=\"JavaScript中的数组\"><a href=\"#JavaScript中的数组\" class=\"headerlink\" title=\"JavaScript中的数组\"></a>JavaScript中的数组</h2><blockquote>\n<p>几乎所有编程语言都原生支持数组类型，它是一段线性分配的内存，通过整数计算偏移并访问其中的元素。但JavaScript中的数组和我们常见如Java中的数组有些不同，众所周知，“JavaScript中，一切皆为对象”。JavaScript中的数组是一种拥有类数组（array-like）特性的对象，它比一个真正的数组慢，但它使用起来十分方便。</p>\n</blockquote>\n<h3 id=\"数组的创建与初始化\"><a href=\"#数组的创建与初始化\" class=\"headerlink\" title=\"数组的创建与初始化\"></a>数组的创建与初始化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [];   // var arr = new Array();</div></pre></td></tr></table></figure>\n<p>其中很重要的点是与大多数其它语言不同，JavaScript数组的length是没有上界的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [1, 2, 3];</div><div class=\"line\">arr[10] = 10;  // 如果添加元素，它会动态增长</div><div class=\"line\">console.log(arr.length);  //  11，也就是除了前3个和最后定义的10。中间的是8个undefined。</div></pre></td></tr></table></figure></p>\n<p>如果给数组的length设小，则将导致下标大于等于新length的属性被删除<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [1, 2, 3, 4];</div><div class=\"line\">arr.length = 2;</div><div class=\"line\">console.log(arr);  // [1, 2]</div></pre></td></tr></table></figure></p>\n<p>数组的的常见增删方法就不一一介绍了，大家可以看<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">MDN Array的详细介绍</a></p>\n<h3 id=\"二维数组及多维数组\"><a href=\"#二维数组及多维数组\" class=\"headerlink\" title=\"二维数组及多维数组\"></a>二维数组及多维数组</h3><p>JavaScript只支持一维数组，并不支持矩阵。但我们可以使用数组套数组实现多维数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Matrix = [</div><div class=\"line\">  [1, 2, 2],</div><div class=\"line\">  [2, 5, 7],</div><div class=\"line\">  [2, 6, 8]</div><div class=\"line\">];</div><div class=\"line\">Matrix[2][1];  //6</div></pre></td></tr></table></figure></p>\n<p>JavaScript应该对矩阵提供更好的支持，我们可以自己定义一个。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Array.Matrix = function () &#123;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n"},{"date":"2016-09-12T11:45:00.000Z","status":"public","title":"JavaScript详解跨域","_content":"\n对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。\n它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\n首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。","source":"_posts/JavaScript详解跨域.md","raw":"---\ndate: 2016-09-12 19:45\nstatus: public\ntags: [JavaScript CORS]\ntitle: JavaScript详解跨域\n---\n\n对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。\n它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\n首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。","slug":"JavaScript详解跨域","published":1,"updated":"2017-04-22T14:13:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca61000dib1ckjrjjngq","content":"<p>对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。</p>\n"},{"date":"2016-08-29T11:45:00.000Z","status":"public","description":"闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。","title":"JavaScript之理解闭包","_content":"## 一个简单的闭包\n\n例1\n\n```\nfunction sayHello(name) {\n  var text = 'Hello ' + name;\n  var say = function() { console.log(text); }  \n  //say()是个内部函数，\n  //a closures use variable declared in the parent function \n  say();\n}\nsayHello('Joe');\n```\n## 理解闭包\n闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。\n\n闭包是一个集合（combination）；它由两部分组成：函数，以及**创建**该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。\n\n在我们的例子中say就是个闭包，因为它含有创建函数的环境，而环境中有着被定义的变量 text，所以它能使用该变量。\n\n## 闭包的用途\n 可以访问函数内部的量，闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。\n\n因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包\n\n例2\n\n```\nfunction makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\n\nvar add5 = makeAdder(5);  //闭包\nvar add10 = makeAdder(10);  //闭包\n\nconsole.log(add5(2));  // 7\nconsole.log(add10(2)); // 12\n```\n\n例3\n\n```\nvar invrement,decrement,value;\n\nvar makeCounter = function() {\n  var privateCounter = 0;\n  increment = function (){\n    privateCounter += 1;\n  };\n  decrement = function (){\n    privateCounter -= 1;\n  };\n  setCounter = function (x) {\n    privateCounter = x;\n  };\n  value = function () {\n    return privateCounter;\n  };\n};\n\nmakeCounter();\nincrement();\nconsole.log(value());  //1\n\nsetCounter(5);\nconsole.log(value());  //5\n\nvar oldCounter = value;\n\nmakeCounter();\ndecrement();\nconsole.log(value());  //-1\n\nconsole.log(oldCounter());  //5\n```\n从例3我们可以看到，setupSomeGlobals每次执行，都会重新创建一个闭包。而且两个闭包互不影响。即它们具有独立性。\n\n我们将例3稍稍改变一下，就可以看到如何用闭包**模仿私有方法**\n\n例4\n\n```\nvar makeCounter = function() {\n  var privateCounter = 0;\n  function changeBy(val) {\n    privateCounter += val;\n  }\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    setCouter: function(x) {\n      privateCounter = x;\n    },\n    value: function() {\n      return privateCounter;\n    }\n  }  \n};\n\nvar Counter1 = makeCounter();\nvar Counter2 = makeCounter();\nconsole.log(Counter1.value()); /* logs 0 */\nCounter1.increment();\nCounter1.increment();\nconsole.log(Counter1.value()); /* logs 2 */\nCounter1.decrement();\nconsole.log(Counter1.value()); /* logs 1 */\nconsole.log(Counter2.value()); /* logs 0 */\n```\n在例4中，changeBy就是一个私有方法，无法从外部直接调用。\n\n\n\n\n另一特点就是 保存变量。这是通俗的说法。\n\n从根本上说，闭包是函数开始执行的时候被分配的一个[栈帧](http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_)，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)\n\n\n例5 \n\n```\nfunction say667() {\n  var num = 42;\n    num+=1;\n  \n  var say3 = function() {\n    console.log(num+=1);\n  };\n  say3();\n  var say4 = function() {\n    console.log(num+=1);\n  };\n  return say4;\n}\nsay667(); //44\nsay667(); //44，并未自增，是因为这又重新创建了一个闭包。\nvar sayt = say667(); //44\nsayt(); //45\nsayt(); //46， 自增了，是因为say667并未重新创建闭包。\n         //sayt引用了里面的闭包，而且造成了num的值被保存了。在函数执行完后并未被销毁。\n```\n> 注意：正是因为闭包有这些特点，它给我们带来了便利。但我们仍需要\n小心使用。它有两个缺点：\n- 1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除；\n- 2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\n\n## 闭包的循环陷阱及补救方法\n\n例6\n\n```\nvar arr = [];\nfor(var i=0;i<3;i++) {\n arr.push(function(){console.log(i);});\n } \narr[0](); //?\narr[1](); //?\narr[2](); //?\n```\n\n例6输出的结果：三个 \"3\" ，详情解析可以看这个[知乎问答](https://www.zhihu.com/question/33468703)，里面有人解释的很清楚。简要来说就是，由于执行顺序的关系，在三个闭包执行前，for循环早已循环完毕（for循环没有块级作用域），i 已经自增到3。到闭包执行时，取到的i自然是3。\n\n解决方案：\n\n```\n//方案一\nfor(var i=0,arr=[];i<3;i++) {\n\t\tarr.push(\n  //既然是执行顺序的问题，那我们给闭包加上一个自执行函数\n  //内部函数引用自执行函数传入的 i ，这里的 i\n 是正常的\n\t\t\t(function(i){\n\t\t\t\treturn function(){\n\t\t\t\t\tconsole.log(i);\n\t\t\t\t}\n\t\t\t})(i)\n\t\t);\n\t}\narr[0](); //0\narr[1](); //1\narr[2](); //2\n\n//方案2\nfor(let i=0,arr=[];i<3;i++)\n//把 i 的定义换成 let 就行，因为 let 定义的变量具有块级作用域，同样解决了这个问题\n```\n\n## 总结：\n- 闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。\n- 每当你在另一个函数里使用了关键字function，一个闭包就被创建了\n- JavaScript中的闭包，就像一个副本，将某函数在退出时候的所有局部变量复制保存其中。\n- 使用闭包前，需要性能考量\n\n-------------------------------------\n\n参考文章：\n- [闭包 ---MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#Performance_considerations)\n- [Javascript中this与闭包学习笔记](https://segmentfault.com/a/1190000006150835)\n- [JavaScript 闭包入门（译文）](https://gold.xitu.io/post/58832fe72f301e00697b672d)\n- [JavaScript的闭包](http://imweb.io/topic/566567e4d91952db73b41f5d)\n- [js关于for循环中的闭包问题？](https://www.zhihu.com/question/33468703)","source":"_posts/JavaScript之理解闭包.md","raw":"---\ndate: 2016-08-29 19:45\nstatus: public\ndescription: 闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。\ntitle: JavaScript之理解闭包\n---\n## 一个简单的闭包\n\n例1\n\n```\nfunction sayHello(name) {\n  var text = 'Hello ' + name;\n  var say = function() { console.log(text); }  \n  //say()是个内部函数，\n  //a closures use variable declared in the parent function \n  say();\n}\nsayHello('Joe');\n```\n## 理解闭包\n闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。\n\n闭包是一个集合（combination）；它由两部分组成：函数，以及**创建**该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。\n\n在我们的例子中say就是个闭包，因为它含有创建函数的环境，而环境中有着被定义的变量 text，所以它能使用该变量。\n\n## 闭包的用途\n 可以访问函数内部的量，闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。\n\n因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包\n\n例2\n\n```\nfunction makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\n\nvar add5 = makeAdder(5);  //闭包\nvar add10 = makeAdder(10);  //闭包\n\nconsole.log(add5(2));  // 7\nconsole.log(add10(2)); // 12\n```\n\n例3\n\n```\nvar invrement,decrement,value;\n\nvar makeCounter = function() {\n  var privateCounter = 0;\n  increment = function (){\n    privateCounter += 1;\n  };\n  decrement = function (){\n    privateCounter -= 1;\n  };\n  setCounter = function (x) {\n    privateCounter = x;\n  };\n  value = function () {\n    return privateCounter;\n  };\n};\n\nmakeCounter();\nincrement();\nconsole.log(value());  //1\n\nsetCounter(5);\nconsole.log(value());  //5\n\nvar oldCounter = value;\n\nmakeCounter();\ndecrement();\nconsole.log(value());  //-1\n\nconsole.log(oldCounter());  //5\n```\n从例3我们可以看到，setupSomeGlobals每次执行，都会重新创建一个闭包。而且两个闭包互不影响。即它们具有独立性。\n\n我们将例3稍稍改变一下，就可以看到如何用闭包**模仿私有方法**\n\n例4\n\n```\nvar makeCounter = function() {\n  var privateCounter = 0;\n  function changeBy(val) {\n    privateCounter += val;\n  }\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    setCouter: function(x) {\n      privateCounter = x;\n    },\n    value: function() {\n      return privateCounter;\n    }\n  }  \n};\n\nvar Counter1 = makeCounter();\nvar Counter2 = makeCounter();\nconsole.log(Counter1.value()); /* logs 0 */\nCounter1.increment();\nCounter1.increment();\nconsole.log(Counter1.value()); /* logs 2 */\nCounter1.decrement();\nconsole.log(Counter1.value()); /* logs 1 */\nconsole.log(Counter2.value()); /* logs 0 */\n```\n在例4中，changeBy就是一个私有方法，无法从外部直接调用。\n\n\n\n\n另一特点就是 保存变量。这是通俗的说法。\n\n从根本上说，闭包是函数开始执行的时候被分配的一个[栈帧](http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_)，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)\n\n\n例5 \n\n```\nfunction say667() {\n  var num = 42;\n    num+=1;\n  \n  var say3 = function() {\n    console.log(num+=1);\n  };\n  say3();\n  var say4 = function() {\n    console.log(num+=1);\n  };\n  return say4;\n}\nsay667(); //44\nsay667(); //44，并未自增，是因为这又重新创建了一个闭包。\nvar sayt = say667(); //44\nsayt(); //45\nsayt(); //46， 自增了，是因为say667并未重新创建闭包。\n         //sayt引用了里面的闭包，而且造成了num的值被保存了。在函数执行完后并未被销毁。\n```\n> 注意：正是因为闭包有这些特点，它给我们带来了便利。但我们仍需要\n小心使用。它有两个缺点：\n- 1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除；\n- 2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\n\n## 闭包的循环陷阱及补救方法\n\n例6\n\n```\nvar arr = [];\nfor(var i=0;i<3;i++) {\n arr.push(function(){console.log(i);});\n } \narr[0](); //?\narr[1](); //?\narr[2](); //?\n```\n\n例6输出的结果：三个 \"3\" ，详情解析可以看这个[知乎问答](https://www.zhihu.com/question/33468703)，里面有人解释的很清楚。简要来说就是，由于执行顺序的关系，在三个闭包执行前，for循环早已循环完毕（for循环没有块级作用域），i 已经自增到3。到闭包执行时，取到的i自然是3。\n\n解决方案：\n\n```\n//方案一\nfor(var i=0,arr=[];i<3;i++) {\n\t\tarr.push(\n  //既然是执行顺序的问题，那我们给闭包加上一个自执行函数\n  //内部函数引用自执行函数传入的 i ，这里的 i\n 是正常的\n\t\t\t(function(i){\n\t\t\t\treturn function(){\n\t\t\t\t\tconsole.log(i);\n\t\t\t\t}\n\t\t\t})(i)\n\t\t);\n\t}\narr[0](); //0\narr[1](); //1\narr[2](); //2\n\n//方案2\nfor(let i=0,arr=[];i<3;i++)\n//把 i 的定义换成 let 就行，因为 let 定义的变量具有块级作用域，同样解决了这个问题\n```\n\n## 总结：\n- 闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。\n- 每当你在另一个函数里使用了关键字function，一个闭包就被创建了\n- JavaScript中的闭包，就像一个副本，将某函数在退出时候的所有局部变量复制保存其中。\n- 使用闭包前，需要性能考量\n\n-------------------------------------\n\n参考文章：\n- [闭包 ---MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#Performance_considerations)\n- [Javascript中this与闭包学习笔记](https://segmentfault.com/a/1190000006150835)\n- [JavaScript 闭包入门（译文）](https://gold.xitu.io/post/58832fe72f301e00697b672d)\n- [JavaScript的闭包](http://imweb.io/topic/566567e4d91952db73b41f5d)\n- [js关于for循环中的闭包问题？](https://www.zhihu.com/question/33468703)","slug":"JavaScript之理解闭包","published":1,"updated":"2017-03-29T14:24:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca65000gib1c0bcewcse","content":"<h2 id=\"一个简单的闭包\"><a href=\"#一个简单的闭包\" class=\"headerlink\" title=\"一个简单的闭包\"></a>一个简单的闭包</h2><p>例1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sayHello(name) &#123;</div><div class=\"line\">  var text = &apos;Hello &apos; + name;</div><div class=\"line\">  var say = function() &#123; console.log(text); &#125;  </div><div class=\"line\">  //say()是个内部函数，</div><div class=\"line\">  //a closures use variable declared in the parent function </div><div class=\"line\">  say();</div><div class=\"line\">&#125;</div><div class=\"line\">sayHello(&apos;Joe&apos;);</div></pre></td></tr></table></figure>\n<h2 id=\"理解闭包\"><a href=\"#理解闭包\" class=\"headerlink\" title=\"理解闭包\"></a>理解闭包</h2><p>闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</p>\n<p>闭包是一个集合（combination）；它由两部分组成：函数，以及<strong>创建</strong>该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。</p>\n<p>在我们的例子中say就是个闭包，因为它含有创建函数的环境，而环境中有着被定义的变量 text，所以它能使用该变量。</p>\n<h2 id=\"闭包的用途\"><a href=\"#闭包的用途\" class=\"headerlink\" title=\"闭包的用途\"></a>闭包的用途</h2><p> 可以访问函数内部的量，闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p>\n<p>因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包</p>\n<p>例2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function makeAdder(x) &#123;</div><div class=\"line\">  return function(y) &#123;</div><div class=\"line\">    return x + y;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var add5 = makeAdder(5);  //闭包</div><div class=\"line\">var add10 = makeAdder(10);  //闭包</div><div class=\"line\"></div><div class=\"line\">console.log(add5(2));  // 7</div><div class=\"line\">console.log(add10(2)); // 12</div></pre></td></tr></table></figure>\n<p>例3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">var invrement,decrement,value;</div><div class=\"line\"></div><div class=\"line\">var makeCounter = function() &#123;</div><div class=\"line\">  var privateCounter = 0;</div><div class=\"line\">  increment = function ()&#123;</div><div class=\"line\">    privateCounter += 1;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  decrement = function ()&#123;</div><div class=\"line\">    privateCounter -= 1;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  setCounter = function (x) &#123;</div><div class=\"line\">    privateCounter = x;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  value = function () &#123;</div><div class=\"line\">    return privateCounter;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">makeCounter();</div><div class=\"line\">increment();</div><div class=\"line\">console.log(value());  //1</div><div class=\"line\"></div><div class=\"line\">setCounter(5);</div><div class=\"line\">console.log(value());  //5</div><div class=\"line\"></div><div class=\"line\">var oldCounter = value;</div><div class=\"line\"></div><div class=\"line\">makeCounter();</div><div class=\"line\">decrement();</div><div class=\"line\">console.log(value());  //-1</div><div class=\"line\"></div><div class=\"line\">console.log(oldCounter());  //5</div></pre></td></tr></table></figure>\n<p>从例3我们可以看到，setupSomeGlobals每次执行，都会重新创建一个闭包。而且两个闭包互不影响。即它们具有独立性。</p>\n<p>我们将例3稍稍改变一下，就可以看到如何用闭包<strong>模仿私有方法</strong></p>\n<p>例4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">var makeCounter = function() &#123;</div><div class=\"line\">  var privateCounter = 0;</div><div class=\"line\">  function changeBy(val) &#123;</div><div class=\"line\">    privateCounter += val;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return &#123;</div><div class=\"line\">    increment: function() &#123;</div><div class=\"line\">      changeBy(1);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    decrement: function() &#123;</div><div class=\"line\">      changeBy(-1);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    setCouter: function(x) &#123;</div><div class=\"line\">      privateCounter = x;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    value: function() &#123;</div><div class=\"line\">      return privateCounter;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;  </div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var Counter1 = makeCounter();</div><div class=\"line\">var Counter2 = makeCounter();</div><div class=\"line\">console.log(Counter1.value()); /* logs 0 */</div><div class=\"line\">Counter1.increment();</div><div class=\"line\">Counter1.increment();</div><div class=\"line\">console.log(Counter1.value()); /* logs 2 */</div><div class=\"line\">Counter1.decrement();</div><div class=\"line\">console.log(Counter1.value()); /* logs 1 */</div><div class=\"line\">console.log(Counter2.value()); /* logs 0 */</div></pre></td></tr></table></figure>\n<p>在例4中，changeBy就是一个私有方法，无法从外部直接调用。</p>\n<p>另一特点就是 保存变量。这是通俗的说法。</p>\n<p>从根本上说，闭包是函数开始执行的时候被分配的一个<a href=\"http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_\" target=\"_blank\" rel=\"external\">栈帧</a>，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)</p>\n<p>例5 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function say667() &#123;</div><div class=\"line\">  var num = 42;</div><div class=\"line\">    num+=1;</div><div class=\"line\">  </div><div class=\"line\">  var say3 = function() &#123;</div><div class=\"line\">    console.log(num+=1);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  say3();</div><div class=\"line\">  var say4 = function() &#123;</div><div class=\"line\">    console.log(num+=1);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  return say4;</div><div class=\"line\">&#125;</div><div class=\"line\">say667(); //44</div><div class=\"line\">say667(); //44，并未自增，是因为这又重新创建了一个闭包。</div><div class=\"line\">var sayt = say667(); //44</div><div class=\"line\">sayt(); //45</div><div class=\"line\">sayt(); //46， 自增了，是因为say667并未重新创建闭包。</div><div class=\"line\">         //sayt引用了里面的闭包，而且造成了num的值被保存了。在函数执行完后并未被销毁。</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：正是因为闭包有这些特点，它给我们带来了便利。但我们仍需要<br>小心使用。它有两个缺点：</p>\n<ul>\n<li>1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除；</li>\n<li>2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>\n</ul>\n</blockquote>\n<h2 id=\"闭包的循环陷阱及补救方法\"><a href=\"#闭包的循环陷阱及补救方法\" class=\"headerlink\" title=\"闭包的循环陷阱及补救方法\"></a>闭包的循环陷阱及补救方法</h2><p>例6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [];</div><div class=\"line\">for(var i=0;i&lt;3;i++) &#123;</div><div class=\"line\"> arr.push(function()&#123;console.log(i);&#125;);</div><div class=\"line\"> &#125; </div><div class=\"line\">arr[0](); //?</div><div class=\"line\">arr[1](); //?</div><div class=\"line\">arr[2](); //?</div></pre></td></tr></table></figure>\n<p>例6输出的结果：三个 “3” ，详情解析可以看这个<a href=\"https://www.zhihu.com/question/33468703\" target=\"_blank\" rel=\"external\">知乎问答</a>，里面有人解释的很清楚。简要来说就是，由于执行顺序的关系，在三个闭包执行前，for循环早已循环完毕（for循环没有块级作用域），i 已经自增到3。到闭包执行时，取到的i自然是3。</p>\n<p>解决方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//方案一</div><div class=\"line\">for(var i=0,arr=[];i&lt;3;i++) &#123;</div><div class=\"line\">\t\tarr.push(</div><div class=\"line\">  //既然是执行顺序的问题，那我们给闭包加上一个自执行函数</div><div class=\"line\">  //内部函数引用自执行函数传入的 i ，这里的 i</div><div class=\"line\"> 是正常的</div><div class=\"line\">\t\t\t(function(i)&#123;</div><div class=\"line\">\t\t\t\treturn function()&#123;</div><div class=\"line\">\t\t\t\t\tconsole.log(i);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;)(i)</div><div class=\"line\">\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">arr[0](); //0</div><div class=\"line\">arr[1](); //1</div><div class=\"line\">arr[2](); //2</div><div class=\"line\"></div><div class=\"line\">//方案2</div><div class=\"line\">for(let i=0,arr=[];i&lt;3;i++)</div><div class=\"line\">//把 i 的定义换成 let 就行，因为 let 定义的变量具有块级作用域，同样解决了这个问题</div></pre></td></tr></table></figure>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ul>\n<li>闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</li>\n<li>每当你在另一个函数里使用了关键字function，一个闭包就被创建了</li>\n<li>JavaScript中的闭包，就像一个副本，将某函数在退出时候的所有局部变量复制保存其中。</li>\n<li>使用闭包前，需要性能考量</li>\n</ul>\n<hr>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#Performance_considerations\" target=\"_blank\" rel=\"external\">闭包 —MDN</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006150835\" target=\"_blank\" rel=\"external\">Javascript中this与闭包学习笔记</a></li>\n<li><a href=\"https://gold.xitu.io/post/58832fe72f301e00697b672d\" target=\"_blank\" rel=\"external\">JavaScript 闭包入门（译文）</a></li>\n<li><a href=\"http://imweb.io/topic/566567e4d91952db73b41f5d\" target=\"_blank\" rel=\"external\">JavaScript的闭包</a></li>\n<li><a href=\"https://www.zhihu.com/question/33468703\" target=\"_blank\" rel=\"external\">js关于for循环中的闭包问题？</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一个简单的闭包\"><a href=\"#一个简单的闭包\" class=\"headerlink\" title=\"一个简单的闭包\"></a>一个简单的闭包</h2><p>例1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sayHello(name) &#123;</div><div class=\"line\">  var text = &apos;Hello &apos; + name;</div><div class=\"line\">  var say = function() &#123; console.log(text); &#125;  </div><div class=\"line\">  //say()是个内部函数，</div><div class=\"line\">  //a closures use variable declared in the parent function </div><div class=\"line\">  say();</div><div class=\"line\">&#125;</div><div class=\"line\">sayHello(&apos;Joe&apos;);</div></pre></td></tr></table></figure>\n<h2 id=\"理解闭包\"><a href=\"#理解闭包\" class=\"headerlink\" title=\"理解闭包\"></a>理解闭包</h2><p>闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</p>\n<p>闭包是一个集合（combination）；它由两部分组成：函数，以及<strong>创建</strong>该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。</p>\n<p>在我们的例子中say就是个闭包，因为它含有创建函数的环境，而环境中有着被定义的变量 text，所以它能使用该变量。</p>\n<h2 id=\"闭包的用途\"><a href=\"#闭包的用途\" class=\"headerlink\" title=\"闭包的用途\"></a>闭包的用途</h2><p> 可以访问函数内部的量，闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p>\n<p>因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包</p>\n<p>例2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function makeAdder(x) &#123;</div><div class=\"line\">  return function(y) &#123;</div><div class=\"line\">    return x + y;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var add5 = makeAdder(5);  //闭包</div><div class=\"line\">var add10 = makeAdder(10);  //闭包</div><div class=\"line\"></div><div class=\"line\">console.log(add5(2));  // 7</div><div class=\"line\">console.log(add10(2)); // 12</div></pre></td></tr></table></figure>\n<p>例3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">var invrement,decrement,value;</div><div class=\"line\"></div><div class=\"line\">var makeCounter = function() &#123;</div><div class=\"line\">  var privateCounter = 0;</div><div class=\"line\">  increment = function ()&#123;</div><div class=\"line\">    privateCounter += 1;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  decrement = function ()&#123;</div><div class=\"line\">    privateCounter -= 1;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  setCounter = function (x) &#123;</div><div class=\"line\">    privateCounter = x;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  value = function () &#123;</div><div class=\"line\">    return privateCounter;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">makeCounter();</div><div class=\"line\">increment();</div><div class=\"line\">console.log(value());  //1</div><div class=\"line\"></div><div class=\"line\">setCounter(5);</div><div class=\"line\">console.log(value());  //5</div><div class=\"line\"></div><div class=\"line\">var oldCounter = value;</div><div class=\"line\"></div><div class=\"line\">makeCounter();</div><div class=\"line\">decrement();</div><div class=\"line\">console.log(value());  //-1</div><div class=\"line\"></div><div class=\"line\">console.log(oldCounter());  //5</div></pre></td></tr></table></figure>\n<p>从例3我们可以看到，setupSomeGlobals每次执行，都会重新创建一个闭包。而且两个闭包互不影响。即它们具有独立性。</p>\n<p>我们将例3稍稍改变一下，就可以看到如何用闭包<strong>模仿私有方法</strong></p>\n<p>例4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">var makeCounter = function() &#123;</div><div class=\"line\">  var privateCounter = 0;</div><div class=\"line\">  function changeBy(val) &#123;</div><div class=\"line\">    privateCounter += val;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return &#123;</div><div class=\"line\">    increment: function() &#123;</div><div class=\"line\">      changeBy(1);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    decrement: function() &#123;</div><div class=\"line\">      changeBy(-1);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    setCouter: function(x) &#123;</div><div class=\"line\">      privateCounter = x;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    value: function() &#123;</div><div class=\"line\">      return privateCounter;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;  </div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var Counter1 = makeCounter();</div><div class=\"line\">var Counter2 = makeCounter();</div><div class=\"line\">console.log(Counter1.value()); /* logs 0 */</div><div class=\"line\">Counter1.increment();</div><div class=\"line\">Counter1.increment();</div><div class=\"line\">console.log(Counter1.value()); /* logs 2 */</div><div class=\"line\">Counter1.decrement();</div><div class=\"line\">console.log(Counter1.value()); /* logs 1 */</div><div class=\"line\">console.log(Counter2.value()); /* logs 0 */</div></pre></td></tr></table></figure>\n<p>在例4中，changeBy就是一个私有方法，无法从外部直接调用。</p>\n<p>另一特点就是 保存变量。这是通俗的说法。</p>\n<p>从根本上说，闭包是函数开始执行的时候被分配的一个<a href=\"http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_\">栈帧</a>，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)</p>\n<p>例5 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function say667() &#123;</div><div class=\"line\">  var num = 42;</div><div class=\"line\">    num+=1;</div><div class=\"line\">  </div><div class=\"line\">  var say3 = function() &#123;</div><div class=\"line\">    console.log(num+=1);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  say3();</div><div class=\"line\">  var say4 = function() &#123;</div><div class=\"line\">    console.log(num+=1);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  return say4;</div><div class=\"line\">&#125;</div><div class=\"line\">say667(); //44</div><div class=\"line\">say667(); //44，并未自增，是因为这又重新创建了一个闭包。</div><div class=\"line\">var sayt = say667(); //44</div><div class=\"line\">sayt(); //45</div><div class=\"line\">sayt(); //46， 自增了，是因为say667并未重新创建闭包。</div><div class=\"line\">         //sayt引用了里面的闭包，而且造成了num的值被保存了。在函数执行完后并未被销毁。</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：正是因为闭包有这些特点，它给我们带来了便利。但我们仍需要<br>小心使用。它有两个缺点：</p>\n<ul>\n<li>1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除；</li>\n<li>2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>\n</ul>\n</blockquote>\n<h2 id=\"闭包的循环陷阱及补救方法\"><a href=\"#闭包的循环陷阱及补救方法\" class=\"headerlink\" title=\"闭包的循环陷阱及补救方法\"></a>闭包的循环陷阱及补救方法</h2><p>例6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [];</div><div class=\"line\">for(var i=0;i&lt;3;i++) &#123;</div><div class=\"line\"> arr.push(function()&#123;console.log(i);&#125;);</div><div class=\"line\"> &#125; </div><div class=\"line\">arr[0](); //?</div><div class=\"line\">arr[1](); //?</div><div class=\"line\">arr[2](); //?</div></pre></td></tr></table></figure>\n<p>例6输出的结果：三个 “3” ，详情解析可以看这个<a href=\"https://www.zhihu.com/question/33468703\">知乎问答</a>，里面有人解释的很清楚。简要来说就是，由于执行顺序的关系，在三个闭包执行前，for循环早已循环完毕（for循环没有块级作用域），i 已经自增到3。到闭包执行时，取到的i自然是3。</p>\n<p>解决方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//方案一</div><div class=\"line\">for(var i=0,arr=[];i&lt;3;i++) &#123;</div><div class=\"line\">\t\tarr.push(</div><div class=\"line\">  //既然是执行顺序的问题，那我们给闭包加上一个自执行函数</div><div class=\"line\">  //内部函数引用自执行函数传入的 i ，这里的 i</div><div class=\"line\"> 是正常的</div><div class=\"line\">\t\t\t(function(i)&#123;</div><div class=\"line\">\t\t\t\treturn function()&#123;</div><div class=\"line\">\t\t\t\t\tconsole.log(i);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;)(i)</div><div class=\"line\">\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">arr[0](); //0</div><div class=\"line\">arr[1](); //1</div><div class=\"line\">arr[2](); //2</div><div class=\"line\"></div><div class=\"line\">//方案2</div><div class=\"line\">for(let i=0,arr=[];i&lt;3;i++)</div><div class=\"line\">//把 i 的定义换成 let 就行，因为 let 定义的变量具有块级作用域，同样解决了这个问题</div></pre></td></tr></table></figure>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ul>\n<li>闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</li>\n<li>每当你在另一个函数里使用了关键字function，一个闭包就被创建了</li>\n<li>JavaScript中的闭包，就像一个副本，将某函数在退出时候的所有局部变量复制保存其中。</li>\n<li>使用闭包前，需要性能考量</li>\n</ul>\n<hr>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#Performance_considerations\">闭包 —MDN</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006150835\">Javascript中this与闭包学习笔记</a></li>\n<li><a href=\"https://gold.xitu.io/post/58832fe72f301e00697b672d\">JavaScript 闭包入门（译文）</a></li>\n<li><a href=\"http://imweb.io/topic/566567e4d91952db73b41f5d\">JavaScript的闭包</a></li>\n<li><a href=\"https://www.zhihu.com/question/33468703\">js关于for循环中的闭包问题？</a></li>\n</ul>\n"},{"date":"2016-07-27T08:40:00.000Z","status":"public","description":"css基础布局","title":"css系列之常见布局","_content":"\n> 在项目工作中，有几种经常需要用到的布局方式，下面列举在实现这些布局常用的几种方式。https://segmentfault.com/a/1190000003931851#articleHeader2\n\n## 一、水平居中\n水平居中的页面布局中最为常见的一种布局形式，多出现于标题，以及内容区域的组织形式，下面介绍四种实现水平居中的方法（注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素）\n\n#### 1、使用inline-block 和 text-align实现\n\n    .parent{text-align: center;} .child{display: inline-block;}\n    优点：兼容性好；  \n    不足：需要同时设置子元素和父元素\n\n#### 2、使用margin:0 auto来实现\n\n    .child{width: 200px; margin: 0 auto;}\n    优点：兼容性好  \n    缺点: 需要指定宽度\n\n#### 3、使用table实现\n\n    .child{display: table; margin: 0 auto;}\n    优点:只需要对自身进行设置  \n    不足:IE6,7需要调整结构\n\n#### 4、使用绝对定位实现\n\n    .parent{position:relative;}\n    /*或者实用margin-left的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好*/\n    .child{position:absolute; left:50%; transform:translate(-50%);}\n    不足：兼容性差,IE9及以上可用\n\n#### 5、实用flex布局实现\n\n    /*第一种方法*/ .parent{display:flex; justify-content:center;}\n    /*第二种方法*/ .parent{display:flex;} .child{margin:0 auto;}\n    缺点：兼容性差，如果进行大面积的布局可能会影响效率\n    \n> 知识点1：margin:0 auto;只对块级元素起作用；\n> 知识点2：text-align适用于块级**父**容器，在子元素为内联元素时才会起作用\n  \n## 二、垂直居中\n#### 1、vertical-align\n    父容器需要定高\n    /*第一种方法*/ \n    .parent{display:table-cell;vertical-align:middle;height:20px;}\n    /*第二种方法*/ \n    .parent{display:inline-block;vertical-align:middle;line-height:20px;}\n    \n> vertical-alignbi必须配合内联型元素（`inline`、`inline-block`、`table-cell`）使用\n\n#### 2、使用绝对定位\n    .parent{position:relative;}\n    .child{positon:absolute; top:50%; transform:translate(0,-50%);}\n#### 3、使用flex实现\n    .parent{display:flex; align-items:center;}\n    /*父元素必须设置确定的高度才能有效果*/\n    \n## 三、水平垂直居中\n#### 1、利用vertical-align,text-align,inline-block实现\n\n    .parent{display:table-cell; vertical-align:middle; text-align:center;}\n     .child{display:inline-block;}\n     缺点：必须设置定宽和定高才有效果\n#### 2、利用绝对定位实现\n    .parent{position:relative;}\n    .child{position:absolute;top:50%;left:50%;\n    transform:translate(-50%,-50%);}\n    优点是子元素不用设置定宽定高，可以用百分比形式\n#### 3、利用flex实现\n    父容器需要定高    \n    /*第一种方法*/\n    .parent{display:flex;justify-content:center;align-items:center;}\n    /*第二种方法*/\n    .parent{display:flex;}\n    .child{margin:auto;}\n\n## 四、多列布局\n### 左列定宽，右列自适应\n\n该布局方式非常常见，适用于定宽的一侧常为导航，自适应的一侧为内容的布局  \n![](https://segmentfault.com/img/bVqEeN)\n\n#### 利用float+margin实现\n\n    .left{float:left;width:100px;}\n    .right{margin-left:100px;}\n    注：IE6会有3px的bug\n\n#### 利用float+margin(fix)实现\n\n![](https://segmentfault.com/img/bVqEh4)\n\n    <div class=\"parent\">\n        <div class=\"left\"></div>\n        <div class=\"right-fix\">\n            <div class=\"right\"></div>\n        </div>\n    </div>\n    .left{width:100px;float:left;}\n    .right-fix{width:100%;margin-left:-100px;float:right;}\n    .right{margin-left:100px;}\n#### 使用float+overflow实现\n\n    .left{width:100px;float:left;}\n    .right{overflow:hidden;}    overflow:hidden，触发bfc模式，浮动无法影响，隔离其他元素，IE6不支持，左侧left设置margin-left当作left与right之间的边距，右侧利用overflow:hidden 进行形成bfc模式  \n如果我们需要将两列设置为等高，可以用下述方法将“背景”设置为等高，其实并不是内容的等高\n\n    .left{width:100px;float:left;}\n    .right{overflow:hidden;}\n    .parent{overflow:hidden;}\n    .left,.right{padding-bottom:9999px;margin-bottom:-9999px;}\n#### 使用table实现\n\n    .parent{display:table;table-layout:fixed;width:100%;}\n    .left{width:100px;}\n    .right,.left{display:table-cell;}\n#### 实用flex实现\n    .parent{display:flex;}\n    .left{width:100px;}\n    .right{flex:1;}\n    利用右侧容器的flex:1，均分了剩余的宽度，也实现了同样的效果。而align-items 默认值为stretch，故二者高度相等\n### 右列定宽，左列自适应\n与上述相似。\n### 左右定宽，中间自适应\nhttps://segmentfault.com/a/1190000002438802\nhttps://segmentfault.com/a/1190000005116275\nhttps://segmentfault.com/a/1190000004317590\nhttp://www.w3cplus.com/css/vertically-center-content-with-css\n","source":"_posts/css系列之常见布局.md","raw":"---\ndate: 2016-07-27 16:40\nstatus: public\ntags: [ css, 布局]\ndescription: css基础布局\ntitle: css系列之常见布局\n---\n\n> 在项目工作中，有几种经常需要用到的布局方式，下面列举在实现这些布局常用的几种方式。https://segmentfault.com/a/1190000003931851#articleHeader2\n\n## 一、水平居中\n水平居中的页面布局中最为常见的一种布局形式，多出现于标题，以及内容区域的组织形式，下面介绍四种实现水平居中的方法（注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素）\n\n#### 1、使用inline-block 和 text-align实现\n\n    .parent{text-align: center;} .child{display: inline-block;}\n    优点：兼容性好；  \n    不足：需要同时设置子元素和父元素\n\n#### 2、使用margin:0 auto来实现\n\n    .child{width: 200px; margin: 0 auto;}\n    优点：兼容性好  \n    缺点: 需要指定宽度\n\n#### 3、使用table实现\n\n    .child{display: table; margin: 0 auto;}\n    优点:只需要对自身进行设置  \n    不足:IE6,7需要调整结构\n\n#### 4、使用绝对定位实现\n\n    .parent{position:relative;}\n    /*或者实用margin-left的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好*/\n    .child{position:absolute; left:50%; transform:translate(-50%);}\n    不足：兼容性差,IE9及以上可用\n\n#### 5、实用flex布局实现\n\n    /*第一种方法*/ .parent{display:flex; justify-content:center;}\n    /*第二种方法*/ .parent{display:flex;} .child{margin:0 auto;}\n    缺点：兼容性差，如果进行大面积的布局可能会影响效率\n    \n> 知识点1：margin:0 auto;只对块级元素起作用；\n> 知识点2：text-align适用于块级**父**容器，在子元素为内联元素时才会起作用\n  \n## 二、垂直居中\n#### 1、vertical-align\n    父容器需要定高\n    /*第一种方法*/ \n    .parent{display:table-cell;vertical-align:middle;height:20px;}\n    /*第二种方法*/ \n    .parent{display:inline-block;vertical-align:middle;line-height:20px;}\n    \n> vertical-alignbi必须配合内联型元素（`inline`、`inline-block`、`table-cell`）使用\n\n#### 2、使用绝对定位\n    .parent{position:relative;}\n    .child{positon:absolute; top:50%; transform:translate(0,-50%);}\n#### 3、使用flex实现\n    .parent{display:flex; align-items:center;}\n    /*父元素必须设置确定的高度才能有效果*/\n    \n## 三、水平垂直居中\n#### 1、利用vertical-align,text-align,inline-block实现\n\n    .parent{display:table-cell; vertical-align:middle; text-align:center;}\n     .child{display:inline-block;}\n     缺点：必须设置定宽和定高才有效果\n#### 2、利用绝对定位实现\n    .parent{position:relative;}\n    .child{position:absolute;top:50%;left:50%;\n    transform:translate(-50%,-50%);}\n    优点是子元素不用设置定宽定高，可以用百分比形式\n#### 3、利用flex实现\n    父容器需要定高    \n    /*第一种方法*/\n    .parent{display:flex;justify-content:center;align-items:center;}\n    /*第二种方法*/\n    .parent{display:flex;}\n    .child{margin:auto;}\n\n## 四、多列布局\n### 左列定宽，右列自适应\n\n该布局方式非常常见，适用于定宽的一侧常为导航，自适应的一侧为内容的布局  \n![](https://segmentfault.com/img/bVqEeN)\n\n#### 利用float+margin实现\n\n    .left{float:left;width:100px;}\n    .right{margin-left:100px;}\n    注：IE6会有3px的bug\n\n#### 利用float+margin(fix)实现\n\n![](https://segmentfault.com/img/bVqEh4)\n\n    <div class=\"parent\">\n        <div class=\"left\"></div>\n        <div class=\"right-fix\">\n            <div class=\"right\"></div>\n        </div>\n    </div>\n    .left{width:100px;float:left;}\n    .right-fix{width:100%;margin-left:-100px;float:right;}\n    .right{margin-left:100px;}\n#### 使用float+overflow实现\n\n    .left{width:100px;float:left;}\n    .right{overflow:hidden;}    overflow:hidden，触发bfc模式，浮动无法影响，隔离其他元素，IE6不支持，左侧left设置margin-left当作left与right之间的边距，右侧利用overflow:hidden 进行形成bfc模式  \n如果我们需要将两列设置为等高，可以用下述方法将“背景”设置为等高，其实并不是内容的等高\n\n    .left{width:100px;float:left;}\n    .right{overflow:hidden;}\n    .parent{overflow:hidden;}\n    .left,.right{padding-bottom:9999px;margin-bottom:-9999px;}\n#### 使用table实现\n\n    .parent{display:table;table-layout:fixed;width:100%;}\n    .left{width:100px;}\n    .right,.left{display:table-cell;}\n#### 实用flex实现\n    .parent{display:flex;}\n    .left{width:100px;}\n    .right{flex:1;}\n    利用右侧容器的flex:1，均分了剩余的宽度，也实现了同样的效果。而align-items 默认值为stretch，故二者高度相等\n### 右列定宽，左列自适应\n与上述相似。\n### 左右定宽，中间自适应\nhttps://segmentfault.com/a/1190000002438802\nhttps://segmentfault.com/a/1190000005116275\nhttps://segmentfault.com/a/1190000004317590\nhttp://www.w3cplus.com/css/vertically-center-content-with-css\n","slug":"css系列之常见布局","published":1,"updated":"2017-03-26T15:51:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca6d000jib1c7flgmh6p","content":"<blockquote>\n<p>在项目工作中，有几种经常需要用到的布局方式，下面列举在实现这些布局常用的几种方式。<a href=\"https://segmentfault.com/a/1190000003931851#articleHeader2\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000003931851#articleHeader2</a></p>\n</blockquote>\n<h2 id=\"一、水平居中\"><a href=\"#一、水平居中\" class=\"headerlink\" title=\"一、水平居中\"></a>一、水平居中</h2><p>水平居中的页面布局中最为常见的一种布局形式，多出现于标题，以及内容区域的组织形式，下面介绍四种实现水平居中的方法（注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素）</p>\n<h4 id=\"1、使用inline-block-和-text-align实现\"><a href=\"#1、使用inline-block-和-text-align实现\" class=\"headerlink\" title=\"1、使用inline-block 和 text-align实现\"></a>1、使用inline-block 和 text-align实现</h4><pre><code>.parent{text-align: center;} .child{display: inline-block;}\n优点：兼容性好；  \n不足：需要同时设置子元素和父元素\n</code></pre><h4 id=\"2、使用margin-0-auto来实现\"><a href=\"#2、使用margin-0-auto来实现\" class=\"headerlink\" title=\"2、使用margin:0 auto来实现\"></a>2、使用margin:0 auto来实现</h4><pre><code>.child{width: 200px; margin: 0 auto;}\n优点：兼容性好  \n缺点: 需要指定宽度\n</code></pre><h4 id=\"3、使用table实现\"><a href=\"#3、使用table实现\" class=\"headerlink\" title=\"3、使用table实现\"></a>3、使用table实现</h4><pre><code>.child{display: table; margin: 0 auto;}\n优点:只需要对自身进行设置  \n不足:IE6,7需要调整结构\n</code></pre><h4 id=\"4、使用绝对定位实现\"><a href=\"#4、使用绝对定位实现\" class=\"headerlink\" title=\"4、使用绝对定位实现\"></a>4、使用绝对定位实现</h4><pre><code>.parent{position:relative;}\n/*或者实用margin-left的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好*/\n.child{position:absolute; left:50%; transform:translate(-50%);}\n不足：兼容性差,IE9及以上可用\n</code></pre><h4 id=\"5、实用flex布局实现\"><a href=\"#5、实用flex布局实现\" class=\"headerlink\" title=\"5、实用flex布局实现\"></a>5、实用flex布局实现</h4><pre><code>/*第一种方法*/ .parent{display:flex; justify-content:center;}\n/*第二种方法*/ .parent{display:flex;} .child{margin:0 auto;}\n缺点：兼容性差，如果进行大面积的布局可能会影响效率\n</code></pre><blockquote>\n<p>知识点1：margin:0 auto;只对块级元素起作用；<br>知识点2：text-align适用于块级<strong>父</strong>容器，在子元素为内联元素时才会起作用</p>\n</blockquote>\n<h2 id=\"二、垂直居中\"><a href=\"#二、垂直居中\" class=\"headerlink\" title=\"二、垂直居中\"></a>二、垂直居中</h2><h4 id=\"1、vertical-align\"><a href=\"#1、vertical-align\" class=\"headerlink\" title=\"1、vertical-align\"></a>1、vertical-align</h4><pre><code>父容器需要定高\n/*第一种方法*/ \n.parent{display:table-cell;vertical-align:middle;height:20px;}\n/*第二种方法*/ \n.parent{display:inline-block;vertical-align:middle;line-height:20px;}\n</code></pre><blockquote>\n<p>vertical-alignbi必须配合内联型元素（<code>inline</code>、<code>inline-block</code>、<code>table-cell</code>）使用</p>\n</blockquote>\n<h4 id=\"2、使用绝对定位\"><a href=\"#2、使用绝对定位\" class=\"headerlink\" title=\"2、使用绝对定位\"></a>2、使用绝对定位</h4><pre><code>.parent{position:relative;}\n.child{positon:absolute; top:50%; transform:translate(0,-50%);}\n</code></pre><h4 id=\"3、使用flex实现\"><a href=\"#3、使用flex实现\" class=\"headerlink\" title=\"3、使用flex实现\"></a>3、使用flex实现</h4><pre><code>.parent{display:flex; align-items:center;}\n/*父元素必须设置确定的高度才能有效果*/\n</code></pre><h2 id=\"三、水平垂直居中\"><a href=\"#三、水平垂直居中\" class=\"headerlink\" title=\"三、水平垂直居中\"></a>三、水平垂直居中</h2><h4 id=\"1、利用vertical-align-text-align-inline-block实现\"><a href=\"#1、利用vertical-align-text-align-inline-block实现\" class=\"headerlink\" title=\"1、利用vertical-align,text-align,inline-block实现\"></a>1、利用vertical-align,text-align,inline-block实现</h4><pre><code>.parent{display:table-cell; vertical-align:middle; text-align:center;}\n .child{display:inline-block;}\n 缺点：必须设置定宽和定高才有效果\n</code></pre><h4 id=\"2、利用绝对定位实现\"><a href=\"#2、利用绝对定位实现\" class=\"headerlink\" title=\"2、利用绝对定位实现\"></a>2、利用绝对定位实现</h4><pre><code>.parent{position:relative;}\n.child{position:absolute;top:50%;left:50%;\ntransform:translate(-50%,-50%);}\n优点是子元素不用设置定宽定高，可以用百分比形式\n</code></pre><h4 id=\"3、利用flex实现\"><a href=\"#3、利用flex实现\" class=\"headerlink\" title=\"3、利用flex实现\"></a>3、利用flex实现</h4><pre><code>父容器需要定高    \n/*第一种方法*/\n.parent{display:flex;justify-content:center;align-items:center;}\n/*第二种方法*/\n.parent{display:flex;}\n.child{margin:auto;}\n</code></pre><h2 id=\"四、多列布局\"><a href=\"#四、多列布局\" class=\"headerlink\" title=\"四、多列布局\"></a>四、多列布局</h2><h3 id=\"左列定宽，右列自适应\"><a href=\"#左列定宽，右列自适应\" class=\"headerlink\" title=\"左列定宽，右列自适应\"></a>左列定宽，右列自适应</h3><p>该布局方式非常常见，适用于定宽的一侧常为导航，自适应的一侧为内容的布局<br><img src=\"https://segmentfault.com/img/bVqEeN\" alt=\"\"></p>\n<h4 id=\"利用float-margin实现\"><a href=\"#利用float-margin实现\" class=\"headerlink\" title=\"利用float+margin实现\"></a>利用float+margin实现</h4><pre><code>.left{float:left;width:100px;}\n.right{margin-left:100px;}\n注：IE6会有3px的bug\n</code></pre><h4 id=\"利用float-margin-fix-实现\"><a href=\"#利用float-margin-fix-实现\" class=\"headerlink\" title=\"利用float+margin(fix)实现\"></a>利用float+margin(fix)实现</h4><p><img src=\"https://segmentfault.com/img/bVqEh4\" alt=\"\"></p>\n<pre><code>&lt;div class=&quot;parent&quot;&gt;\n    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;right-fix&quot;&gt;\n        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n.left{width:100px;float:left;}\n.right-fix{width:100%;margin-left:-100px;float:right;}\n.right{margin-left:100px;}\n</code></pre><h4 id=\"使用float-overflow实现\"><a href=\"#使用float-overflow实现\" class=\"headerlink\" title=\"使用float+overflow实现\"></a>使用float+overflow实现</h4><pre><code>.left{width:100px;float:left;}\n.right{overflow:hidden;}    overflow:hidden，触发bfc模式，浮动无法影响，隔离其他元素，IE6不支持，左侧left设置margin-left当作left与right之间的边距，右侧利用overflow:hidden 进行形成bfc模式  \n</code></pre><p>如果我们需要将两列设置为等高，可以用下述方法将“背景”设置为等高，其实并不是内容的等高</p>\n<pre><code>.left{width:100px;float:left;}\n.right{overflow:hidden;}\n.parent{overflow:hidden;}\n.left,.right{padding-bottom:9999px;margin-bottom:-9999px;}\n</code></pre><h4 id=\"使用table实现\"><a href=\"#使用table实现\" class=\"headerlink\" title=\"使用table实现\"></a>使用table实现</h4><pre><code>.parent{display:table;table-layout:fixed;width:100%;}\n.left{width:100px;}\n.right,.left{display:table-cell;}\n</code></pre><h4 id=\"实用flex实现\"><a href=\"#实用flex实现\" class=\"headerlink\" title=\"实用flex实现\"></a>实用flex实现</h4><pre><code>.parent{display:flex;}\n.left{width:100px;}\n.right{flex:1;}\n利用右侧容器的flex:1，均分了剩余的宽度，也实现了同样的效果。而align-items 默认值为stretch，故二者高度相等\n</code></pre><h3 id=\"右列定宽，左列自适应\"><a href=\"#右列定宽，左列自适应\" class=\"headerlink\" title=\"右列定宽，左列自适应\"></a>右列定宽，左列自适应</h3><p>与上述相似。</p>\n<h3 id=\"左右定宽，中间自适应\"><a href=\"#左右定宽，中间自适应\" class=\"headerlink\" title=\"左右定宽，中间自适应\"></a>左右定宽，中间自适应</h3><p><a href=\"https://segmentfault.com/a/1190000002438802\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000002438802</a><br><a href=\"https://segmentfault.com/a/1190000005116275\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000005116275</a><br><a href=\"https://segmentfault.com/a/1190000004317590\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000004317590</a><br><a href=\"http://www.w3cplus.com/css/vertically-center-content-with-css\" target=\"_blank\" rel=\"external\">http://www.w3cplus.com/css/vertically-center-content-with-css</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在项目工作中，有几种经常需要用到的布局方式，下面列举在实现这些布局常用的几种方式。<a href=\"https://segmentfault.com/a/1190000003931851#articleHeader2\">https://segmentfault.com/a/1190000003931851#articleHeader2</a></p>\n</blockquote>\n<h2 id=\"一、水平居中\"><a href=\"#一、水平居中\" class=\"headerlink\" title=\"一、水平居中\"></a>一、水平居中</h2><p>水平居中的页面布局中最为常见的一种布局形式，多出现于标题，以及内容区域的组织形式，下面介绍四种实现水平居中的方法（注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素）</p>\n<h4 id=\"1、使用inline-block-和-text-align实现\"><a href=\"#1、使用inline-block-和-text-align实现\" class=\"headerlink\" title=\"1、使用inline-block 和 text-align实现\"></a>1、使用inline-block 和 text-align实现</h4><pre><code>.parent{text-align: center;} .child{display: inline-block;}\n优点：兼容性好；  \n不足：需要同时设置子元素和父元素\n</code></pre><h4 id=\"2、使用margin-0-auto来实现\"><a href=\"#2、使用margin-0-auto来实现\" class=\"headerlink\" title=\"2、使用margin:0 auto来实现\"></a>2、使用margin:0 auto来实现</h4><pre><code>.child{width: 200px; margin: 0 auto;}\n优点：兼容性好  \n缺点: 需要指定宽度\n</code></pre><h4 id=\"3、使用table实现\"><a href=\"#3、使用table实现\" class=\"headerlink\" title=\"3、使用table实现\"></a>3、使用table实现</h4><pre><code>.child{display: table; margin: 0 auto;}\n优点:只需要对自身进行设置  \n不足:IE6,7需要调整结构\n</code></pre><h4 id=\"4、使用绝对定位实现\"><a href=\"#4、使用绝对定位实现\" class=\"headerlink\" title=\"4、使用绝对定位实现\"></a>4、使用绝对定位实现</h4><pre><code>.parent{position:relative;}\n/*或者实用margin-left的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好*/\n.child{position:absolute; left:50%; transform:translate(-50%);}\n不足：兼容性差,IE9及以上可用\n</code></pre><h4 id=\"5、实用flex布局实现\"><a href=\"#5、实用flex布局实现\" class=\"headerlink\" title=\"5、实用flex布局实现\"></a>5、实用flex布局实现</h4><pre><code>/*第一种方法*/ .parent{display:flex; justify-content:center;}\n/*第二种方法*/ .parent{display:flex;} .child{margin:0 auto;}\n缺点：兼容性差，如果进行大面积的布局可能会影响效率\n</code></pre><blockquote>\n<p>知识点1：margin:0 auto;只对块级元素起作用；<br>知识点2：text-align适用于块级<strong>父</strong>容器，在子元素为内联元素时才会起作用</p>\n</blockquote>\n<h2 id=\"二、垂直居中\"><a href=\"#二、垂直居中\" class=\"headerlink\" title=\"二、垂直居中\"></a>二、垂直居中</h2><h4 id=\"1、vertical-align\"><a href=\"#1、vertical-align\" class=\"headerlink\" title=\"1、vertical-align\"></a>1、vertical-align</h4><pre><code>父容器需要定高\n/*第一种方法*/ \n.parent{display:table-cell;vertical-align:middle;height:20px;}\n/*第二种方法*/ \n.parent{display:inline-block;vertical-align:middle;line-height:20px;}\n</code></pre><blockquote>\n<p>vertical-alignbi必须配合内联型元素（<code>inline</code>、<code>inline-block</code>、<code>table-cell</code>）使用</p>\n</blockquote>\n<h4 id=\"2、使用绝对定位\"><a href=\"#2、使用绝对定位\" class=\"headerlink\" title=\"2、使用绝对定位\"></a>2、使用绝对定位</h4><pre><code>.parent{position:relative;}\n.child{positon:absolute; top:50%; transform:translate(0,-50%);}\n</code></pre><h4 id=\"3、使用flex实现\"><a href=\"#3、使用flex实现\" class=\"headerlink\" title=\"3、使用flex实现\"></a>3、使用flex实现</h4><pre><code>.parent{display:flex; align-items:center;}\n/*父元素必须设置确定的高度才能有效果*/\n</code></pre><h2 id=\"三、水平垂直居中\"><a href=\"#三、水平垂直居中\" class=\"headerlink\" title=\"三、水平垂直居中\"></a>三、水平垂直居中</h2><h4 id=\"1、利用vertical-align-text-align-inline-block实现\"><a href=\"#1、利用vertical-align-text-align-inline-block实现\" class=\"headerlink\" title=\"1、利用vertical-align,text-align,inline-block实现\"></a>1、利用vertical-align,text-align,inline-block实现</h4><pre><code>.parent{display:table-cell; vertical-align:middle; text-align:center;}\n .child{display:inline-block;}\n 缺点：必须设置定宽和定高才有效果\n</code></pre><h4 id=\"2、利用绝对定位实现\"><a href=\"#2、利用绝对定位实现\" class=\"headerlink\" title=\"2、利用绝对定位实现\"></a>2、利用绝对定位实现</h4><pre><code>.parent{position:relative;}\n.child{position:absolute;top:50%;left:50%;\ntransform:translate(-50%,-50%);}\n优点是子元素不用设置定宽定高，可以用百分比形式\n</code></pre><h4 id=\"3、利用flex实现\"><a href=\"#3、利用flex实现\" class=\"headerlink\" title=\"3、利用flex实现\"></a>3、利用flex实现</h4><pre><code>父容器需要定高    \n/*第一种方法*/\n.parent{display:flex;justify-content:center;align-items:center;}\n/*第二种方法*/\n.parent{display:flex;}\n.child{margin:auto;}\n</code></pre><h2 id=\"四、多列布局\"><a href=\"#四、多列布局\" class=\"headerlink\" title=\"四、多列布局\"></a>四、多列布局</h2><h3 id=\"左列定宽，右列自适应\"><a href=\"#左列定宽，右列自适应\" class=\"headerlink\" title=\"左列定宽，右列自适应\"></a>左列定宽，右列自适应</h3><p>该布局方式非常常见，适用于定宽的一侧常为导航，自适应的一侧为内容的布局<br><img src=\"https://segmentfault.com/img/bVqEeN\" alt=\"\"></p>\n<h4 id=\"利用float-margin实现\"><a href=\"#利用float-margin实现\" class=\"headerlink\" title=\"利用float+margin实现\"></a>利用float+margin实现</h4><pre><code>.left{float:left;width:100px;}\n.right{margin-left:100px;}\n注：IE6会有3px的bug\n</code></pre><h4 id=\"利用float-margin-fix-实现\"><a href=\"#利用float-margin-fix-实现\" class=\"headerlink\" title=\"利用float+margin(fix)实现\"></a>利用float+margin(fix)实现</h4><p><img src=\"https://segmentfault.com/img/bVqEh4\" alt=\"\"></p>\n<pre><code>&lt;div class=&quot;parent&quot;&gt;\n    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;right-fix&quot;&gt;\n        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n.left{width:100px;float:left;}\n.right-fix{width:100%;margin-left:-100px;float:right;}\n.right{margin-left:100px;}\n</code></pre><h4 id=\"使用float-overflow实现\"><a href=\"#使用float-overflow实现\" class=\"headerlink\" title=\"使用float+overflow实现\"></a>使用float+overflow实现</h4><pre><code>.left{width:100px;float:left;}\n.right{overflow:hidden;}    overflow:hidden，触发bfc模式，浮动无法影响，隔离其他元素，IE6不支持，左侧left设置margin-left当作left与right之间的边距，右侧利用overflow:hidden 进行形成bfc模式  \n</code></pre><p>如果我们需要将两列设置为等高，可以用下述方法将“背景”设置为等高，其实并不是内容的等高</p>\n<pre><code>.left{width:100px;float:left;}\n.right{overflow:hidden;}\n.parent{overflow:hidden;}\n.left,.right{padding-bottom:9999px;margin-bottom:-9999px;}\n</code></pre><h4 id=\"使用table实现\"><a href=\"#使用table实现\" class=\"headerlink\" title=\"使用table实现\"></a>使用table实现</h4><pre><code>.parent{display:table;table-layout:fixed;width:100%;}\n.left{width:100px;}\n.right,.left{display:table-cell;}\n</code></pre><h4 id=\"实用flex实现\"><a href=\"#实用flex实现\" class=\"headerlink\" title=\"实用flex实现\"></a>实用flex实现</h4><pre><code>.parent{display:flex;}\n.left{width:100px;}\n.right{flex:1;}\n利用右侧容器的flex:1，均分了剩余的宽度，也实现了同样的效果。而align-items 默认值为stretch，故二者高度相等\n</code></pre><h3 id=\"右列定宽，左列自适应\"><a href=\"#右列定宽，左列自适应\" class=\"headerlink\" title=\"右列定宽，左列自适应\"></a>右列定宽，左列自适应</h3><p>与上述相似。</p>\n<h3 id=\"左右定宽，中间自适应\"><a href=\"#左右定宽，中间自适应\" class=\"headerlink\" title=\"左右定宽，中间自适应\"></a>左右定宽，中间自适应</h3><p><a href=\"https://segmentfault.com/a/1190000002438802\">https://segmentfault.com/a/1190000002438802</a><br><a href=\"https://segmentfault.com/a/1190000005116275\">https://segmentfault.com/a/1190000005116275</a><br><a href=\"https://segmentfault.com/a/1190000004317590\">https://segmentfault.com/a/1190000004317590</a><br><a href=\"http://www.w3cplus.com/css/vertically-center-content-with-css\">http://www.w3cplus.com/css/vertically-center-content-with-css</a></p>\n"},{"date":"2017-03-10T11:45:00.000Z","status":"public","description":"我的简历","title":"web前端实习简历","_content":"\n求职意向：web前端实习生（能实习2-4个月）\n## 个人简介\n洪家伟，男，大三，2018年本科毕业，就读于江西南昌的华东交通大学软件工程专业\n\n| 手机      | email   |  github  | 个人博客 |\n| --------   | -----  | ----  | ---- |\n| 15279181729 | howell95@outlook.com |   <https://github.com/Howell5>     | <http://blog.josephong.me>|\n\n## 能力简述\n- 开发：于2016年开始学习前端，对前端领域知识有不错的掌握，能胜任大多数前端开发任务\n- 工具平台：主要开发平台 mac， 熟悉 git，熟悉 sublime，了解 atom\n- 开源爱好者：有十几个项目的代码托管在 github。\n- 自学能力强：喜欢阅读经典书籍，写博客。擅长使用 google、stackoverflow，阅读英文文档。\n\n## 项目经历\n\n### 大三下： HTML5 移动webapp阅读器\n> 在线地址：[HTML5 移动webapp阅读器](http://blog.josephong.me/ReaderH5/)\n\n\n- 文本数据由JSONP跨域请求获得\n- 可实现基本的翻页，更换背景色，更改字体大小等交互。且这些操作数据会存入localStorage中\n- 使用ES6的Promise解决了回调过多的问题，base64格式图片优化了性能\n\n### 大三上： 百度前端学院2015春季班任务\n> 在线地址: [IFE-2015-spring](http://blog.josephong.me/IFE-2015/intro.html)\n\n- task2实现了轮播图组件，运动框架组件，拖拽，Ajax，事件代理等常用方法的封装库\n- task3实现了一个SPA简易个人任务管理系统,数据存在localStorage中\n\n## 其它经历\n- 大三上 作为学院主力成员(10号)获得校足球杯赛第三名\n- 大二上 作为主要策划负责人举办了学校大型音乐节(与vivo合作)。经费8000元，现场人数800人左右\n- 大一 获院三等奖学金","source":"_posts/简历.md","raw":"---\ndate: 2017-03-10 19:45\nstatus: public\ntags: [resume]\ndescription: 我的简历\ntitle: web前端实习简历\n---\n\n求职意向：web前端实习生（能实习2-4个月）\n## 个人简介\n洪家伟，男，大三，2018年本科毕业，就读于江西南昌的华东交通大学软件工程专业\n\n| 手机      | email   |  github  | 个人博客 |\n| --------   | -----  | ----  | ---- |\n| 15279181729 | howell95@outlook.com |   <https://github.com/Howell5>     | <http://blog.josephong.me>|\n\n## 能力简述\n- 开发：于2016年开始学习前端，对前端领域知识有不错的掌握，能胜任大多数前端开发任务\n- 工具平台：主要开发平台 mac， 熟悉 git，熟悉 sublime，了解 atom\n- 开源爱好者：有十几个项目的代码托管在 github。\n- 自学能力强：喜欢阅读经典书籍，写博客。擅长使用 google、stackoverflow，阅读英文文档。\n\n## 项目经历\n\n### 大三下： HTML5 移动webapp阅读器\n> 在线地址：[HTML5 移动webapp阅读器](http://blog.josephong.me/ReaderH5/)\n\n\n- 文本数据由JSONP跨域请求获得\n- 可实现基本的翻页，更换背景色，更改字体大小等交互。且这些操作数据会存入localStorage中\n- 使用ES6的Promise解决了回调过多的问题，base64格式图片优化了性能\n\n### 大三上： 百度前端学院2015春季班任务\n> 在线地址: [IFE-2015-spring](http://blog.josephong.me/IFE-2015/intro.html)\n\n- task2实现了轮播图组件，运动框架组件，拖拽，Ajax，事件代理等常用方法的封装库\n- task3实现了一个SPA简易个人任务管理系统,数据存在localStorage中\n\n## 其它经历\n- 大三上 作为学院主力成员(10号)获得校足球杯赛第三名\n- 大二上 作为主要策划负责人举办了学校大型音乐节(与vivo合作)。经费8000元，现场人数800人左右\n- 大一 获院三等奖学金","slug":"简历","published":1,"updated":"2017-04-22T15:14:34.000Z","_id":"cj1teca6f000lib1c0111ecjx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>求职意向：web前端实习生（能实习2-4个月）</p>\n<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p>洪家伟，男，大三，2018年本科毕业，就读于江西南昌的华东交通大学软件工程专业</p>\n<table>\n<thead>\n<tr>\n<th>手机</th>\n<th>email</th>\n<th>github</th>\n<th>个人博客</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>15279181729</td>\n<td>howell95@outlook.com</td>\n<td><a href=\"https://github.com/Howell5\" target=\"_blank\" rel=\"external\">https://github.com/Howell5</a></td>\n<td><a href=\"http://blog.josephong.me\">http://blog.josephong.me</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"能力简述\"><a href=\"#能力简述\" class=\"headerlink\" title=\"能力简述\"></a>能力简述</h2><ul>\n<li>开发：于2016年开始学习前端，对前端领域知识有不错的掌握，能胜任大多数前端开发任务</li>\n<li>工具平台：主要开发平台 mac， 熟悉 git，熟悉 sublime，了解 atom</li>\n<li>开源爱好者：有十几个项目的代码托管在 github。</li>\n<li>自学能力强：喜欢阅读经典书籍，写博客。擅长使用 google、stackoverflow，阅读英文文档。</li>\n</ul>\n<h2 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h2><h3 id=\"大三下：-HTML5-移动webapp阅读器\"><a href=\"#大三下：-HTML5-移动webapp阅读器\" class=\"headerlink\" title=\"大三下： HTML5 移动webapp阅读器\"></a>大三下： HTML5 移动webapp阅读器</h3><blockquote>\n<p>在线地址：<a href=\"http://blog.josephong.me/ReaderH5/\">HTML5 移动webapp阅读器</a></p>\n</blockquote>\n<ul>\n<li>文本数据由JSONP跨域请求获得</li>\n<li>可实现基本的翻页，更换背景色，更改字体大小等交互。且这些操作数据会存入localStorage中</li>\n<li>使用ES6的Promise解决了回调过多的问题，base64格式图片优化了性能</li>\n</ul>\n<h3 id=\"大三上：-百度前端学院2015春季班任务\"><a href=\"#大三上：-百度前端学院2015春季班任务\" class=\"headerlink\" title=\"大三上： 百度前端学院2015春季班任务\"></a>大三上： 百度前端学院2015春季班任务</h3><blockquote>\n<p>在线地址: <a href=\"http://blog.josephong.me/IFE-2015/intro.html\">IFE-2015-spring</a></p>\n</blockquote>\n<ul>\n<li>task2实现了轮播图组件，运动框架组件，拖拽，Ajax，事件代理等常用方法的封装库</li>\n<li>task3实现了一个SPA简易个人任务管理系统,数据存在localStorage中</li>\n</ul>\n<h2 id=\"其它经历\"><a href=\"#其它经历\" class=\"headerlink\" title=\"其它经历\"></a>其它经历</h2><ul>\n<li>大三上 作为学院主力成员(10号)获得校足球杯赛第三名</li>\n<li>大二上 作为主要策划负责人举办了学校大型音乐节(与vivo合作)。经费8000元，现场人数800人左右</li>\n<li>大一 获院三等奖学金</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>求职意向：web前端实习生（能实习2-4个月）</p>\n<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p>洪家伟，男，大三，2018年本科毕业，就读于江西南昌的华东交通大学软件工程专业</p>\n<table>\n<thead>\n<tr>\n<th>手机</th>\n<th>email</th>\n<th>github</th>\n<th>个人博客</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>15279181729</td>\n<td>howell95@outlook.com</td>\n<td><a href=\"https://github.com/Howell5\">https://github.com/Howell5</a></td>\n<td><a href=\"http://blog.josephong.me\">http://blog.josephong.me</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"能力简述\"><a href=\"#能力简述\" class=\"headerlink\" title=\"能力简述\"></a>能力简述</h2><ul>\n<li>开发：于2016年开始学习前端，对前端领域知识有不错的掌握，能胜任大多数前端开发任务</li>\n<li>工具平台：主要开发平台 mac， 熟悉 git，熟悉 sublime，了解 atom</li>\n<li>开源爱好者：有十几个项目的代码托管在 github。</li>\n<li>自学能力强：喜欢阅读经典书籍，写博客。擅长使用 google、stackoverflow，阅读英文文档。</li>\n</ul>\n<h2 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h2><h3 id=\"大三下：-HTML5-移动webapp阅读器\"><a href=\"#大三下：-HTML5-移动webapp阅读器\" class=\"headerlink\" title=\"大三下： HTML5 移动webapp阅读器\"></a>大三下： HTML5 移动webapp阅读器</h3><blockquote>\n<p>在线地址：<a href=\"http://blog.josephong.me/ReaderH5/\">HTML5 移动webapp阅读器</a></p>\n</blockquote>\n<ul>\n<li>文本数据由JSONP跨域请求获得</li>\n<li>可实现基本的翻页，更换背景色，更改字体大小等交互。且这些操作数据会存入localStorage中</li>\n<li>使用ES6的Promise解决了回调过多的问题，base64格式图片优化了性能</li>\n</ul>\n<h3 id=\"大三上：-百度前端学院2015春季班任务\"><a href=\"#大三上：-百度前端学院2015春季班任务\" class=\"headerlink\" title=\"大三上： 百度前端学院2015春季班任务\"></a>大三上： 百度前端学院2015春季班任务</h3><blockquote>\n<p>在线地址: <a href=\"http://blog.josephong.me/IFE-2015/intro.html\">IFE-2015-spring</a></p>\n</blockquote>\n<ul>\n<li>task2实现了轮播图组件，运动框架组件，拖拽，Ajax，事件代理等常用方法的封装库</li>\n<li>task3实现了一个SPA简易个人任务管理系统,数据存在localStorage中</li>\n</ul>\n<h2 id=\"其它经历\"><a href=\"#其它经历\" class=\"headerlink\" title=\"其它经历\"></a>其它经历</h2><ul>\n<li>大三上 作为学院主力成员(10号)获得校足球杯赛第三名</li>\n<li>大二上 作为主要策划负责人举办了学校大型音乐节(与vivo合作)。经费8000元，现场人数800人左右</li>\n<li>大一 获院三等奖学金</li>\n</ul>\n"},{"date":"2016-08-10T11:43:00.000Z","status":"public","description":"近期学了较多移动web开发的相关知识，所以在这里写点东西，也算坐个简单总结。","title":"移动web学习笔记","_content":"\n---\n\n近期学了较多移动web开发的相关知识，所以在这里写点东西，也算坐个简单总结。\n\n---\n### pixel像素基础\n- px：CSS pixels 逻辑像素，浏览器使用的抽象单位\n- dp，pt：device independent pixels 设备独立像素\n- dpr：devicePixelRatio 设备像素缩放比\n\n> 计算公式：1px=(dpr)² * dp\n\n> 在JavaScript中，可以通过`window.devicePixelRatio`获取当前设备的dpr\n\n这里盗个图：\n\n![][1]\n\n\n\n- DPI:打印机每英寸可以喷的墨汁点（印刷行业）\n- PPI:屏幕每英寸的像素数量，即单位英寸内的像素密度(ppi越高，像素越高，图像越清晰)\n\n**这几个属性之间的关系，以iPhone5为例**：\niPhone5设备分辨率1136*640dp --> \n根号[(1136²+640²)]/4 = 326ppi --> 326ppi属于Retina屏幕,所以根据规定dpr=2 --> \n1px = dpr² * dp --> \niphone5的屏幕宽高为320*568px。\n> 例如这样，设计师可以根据`320px`为`基准`设计`视觉稿`。\n\n---\n\n### Viewport视图\n为了让手机能获得良好的网页浏览体验，Apple 找到了一个办法：在移动版的 Safari（iOS平台）中定义了 viewport meta 标签，它的作用就是创建一个虚拟的窗口（viewport），而且这个虚拟窗口的分辨率接近于桌面显示器，Apple 将其定位为 980px.\n手机浏览器默认为我们做了两件事情\n一、页面渲染在一个980px（ios）的Viewport\n二、缩放\n\n- visual viewport（度量/视口）\n = 窗口缩放 scalce，让手机页面可以看到多少\n- layout viewport（布局）\n  负责渲染底层页面\n\n\n**最常用移动web viewport设置**\n\n【布局viewport】=【设备宽度】=【度量viewport】\n\n```\n//常见viewport设置\n<meta name=\"viewport\" \ncontent=\"width=device-width, //根据设备调整width\ninitial-scale=1, //比例为1\nuser-scalable=no\" //不允许用户缩放\n\n//在开发调试过程中，可以通过JS代码获得当前layout和visual的值\ndocument.body.clientWidth //获得layout viewport值\nwindow.innerWidth //获得visual viewport值\n```\n\n### 设计移动Web\n- 方案一：根据设备的实际宽度来设计（常用）\n手机宽320 px，我们就拿320 px设计\n- 方案二：1px=1dp\n缩放0.5（initial-scale=0.5）。根据设备的物理像素 dp 等于抽象像素 px 来设计。1像素边框和高清图片都不需要额外处理。\n\n-------\n\n# 移动web特别样式\n\n\n---\n\n### 一像素边框\n比如想让border的线更细些，我们虽然会设置成border：1px；但在是retina屏幕下，1px使用2dp渲染。使之看起来有2px，那我们就用border：0.5px咯。但很可惜，这种语法只在ios8以上的情况下有用，所以不是好方案。\n这时我们就常用到scaleY(0.5),大致代码如下：\n\n```\n.scale{\n    position: relative;\n}\n.scale:after{\n    content:\"\";\n    position: absolute;\n    bottom:0px;\n    left:0px;\n    right:0px;\n    border-bottom:1px solid #ddd;\n    -webkit-transform:scaleY(.5);\n    -webkit-transform-origin:0 0;\n}\n```\n---\n\n### 相对单位 rem\n- 为了适应各大屏幕的手机，px略显固定,不能根据尺寸的大小而改变，使用相对单位更能体验页面兼容性\n\n    - em：是根据父节点的font-size为相对单位\n但em在多层嵌套下，变得非常难以操作\n\n    - rem：是根据html的font-size为相对单位\n    rem更加能作为全局统一设置的度量（但在实际产品交互体验上还需考量是否使用）\n\n- 引出另一个问题rem的基值设置多少好？\n回归我们的目的：为了适应各大手机屏幕\nrem = screen.width/20 \n有时我们也会看到在业界中会用如下方案：\n> 将`scale`设置为`1/dpr` , 而`<html>`的`font-size`计算为`screen.width * dpr / >10`,然后再以`less`将UE图上得到的尺寸透明转换为对应的`rem`值。\n\n关于这一方案的实现，推荐大家看看这篇文章： [数学方法解释 dpr/scale/rem 三者的关系][2]。\n\n- iphone5上的rem基值为32px，渲染一张64 * 64px的div，则用2rem * 2rem去渲染。换算公式非常简单：\nwidth：px/rem基值\nheight：px/rem基值\n\n- 不使用rem的情况：font-size\n    - 一般来说font-size是不应该使用rem等相对单位的。因为字体的大小是趋向于阅读的实用性，并不适合与排版布局。\n    - 同理趋向于一些固定的元素的特性。我们不使用rem而改为使用px去确保在不同屏幕上表现一致（和rem的目的相反）。\n\n---\n\n### 多行文本溢出···\n\n单行文本溢出，对title类的使用非常多，\n而多行文本类，在详情介绍则用的比较多。\n\n```\n//单行文本溢出...\n.inaline {\n    overflow: hidden;\n    white-space: nowrap;\n    text-flow: ellipsis;\n}\n\n//多行文本溢出...\n.intwoline {\n    display: -webkit-box !important;\n    overflow: hidden;\n    \n    text-overflow: ellipsis;\n    word-break: break-all; \n    \n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: 2; //关键属性，限制行数\n}\n```\n\n\n大概就是这些了，写的比较乱。如有错误欢迎指正。\n","source":"_posts/移动web学习笔记.md","raw":"---\ndate: 2016-08-10 19:43\nstatus: public\ndescription: 近期学了较多移动web开发的相关知识，所以在这里写点东西，也算坐个简单总结。\ntitle: 移动web学习笔记\n---\n\n---\n\n近期学了较多移动web开发的相关知识，所以在这里写点东西，也算坐个简单总结。\n\n---\n### pixel像素基础\n- px：CSS pixels 逻辑像素，浏览器使用的抽象单位\n- dp，pt：device independent pixels 设备独立像素\n- dpr：devicePixelRatio 设备像素缩放比\n\n> 计算公式：1px=(dpr)² * dp\n\n> 在JavaScript中，可以通过`window.devicePixelRatio`获取当前设备的dpr\n\n这里盗个图：\n\n![][1]\n\n\n\n- DPI:打印机每英寸可以喷的墨汁点（印刷行业）\n- PPI:屏幕每英寸的像素数量，即单位英寸内的像素密度(ppi越高，像素越高，图像越清晰)\n\n**这几个属性之间的关系，以iPhone5为例**：\niPhone5设备分辨率1136*640dp --> \n根号[(1136²+640²)]/4 = 326ppi --> 326ppi属于Retina屏幕,所以根据规定dpr=2 --> \n1px = dpr² * dp --> \niphone5的屏幕宽高为320*568px。\n> 例如这样，设计师可以根据`320px`为`基准`设计`视觉稿`。\n\n---\n\n### Viewport视图\n为了让手机能获得良好的网页浏览体验，Apple 找到了一个办法：在移动版的 Safari（iOS平台）中定义了 viewport meta 标签，它的作用就是创建一个虚拟的窗口（viewport），而且这个虚拟窗口的分辨率接近于桌面显示器，Apple 将其定位为 980px.\n手机浏览器默认为我们做了两件事情\n一、页面渲染在一个980px（ios）的Viewport\n二、缩放\n\n- visual viewport（度量/视口）\n = 窗口缩放 scalce，让手机页面可以看到多少\n- layout viewport（布局）\n  负责渲染底层页面\n\n\n**最常用移动web viewport设置**\n\n【布局viewport】=【设备宽度】=【度量viewport】\n\n```\n//常见viewport设置\n<meta name=\"viewport\" \ncontent=\"width=device-width, //根据设备调整width\ninitial-scale=1, //比例为1\nuser-scalable=no\" //不允许用户缩放\n\n//在开发调试过程中，可以通过JS代码获得当前layout和visual的值\ndocument.body.clientWidth //获得layout viewport值\nwindow.innerWidth //获得visual viewport值\n```\n\n### 设计移动Web\n- 方案一：根据设备的实际宽度来设计（常用）\n手机宽320 px，我们就拿320 px设计\n- 方案二：1px=1dp\n缩放0.5（initial-scale=0.5）。根据设备的物理像素 dp 等于抽象像素 px 来设计。1像素边框和高清图片都不需要额外处理。\n\n-------\n\n# 移动web特别样式\n\n\n---\n\n### 一像素边框\n比如想让border的线更细些，我们虽然会设置成border：1px；但在是retina屏幕下，1px使用2dp渲染。使之看起来有2px，那我们就用border：0.5px咯。但很可惜，这种语法只在ios8以上的情况下有用，所以不是好方案。\n这时我们就常用到scaleY(0.5),大致代码如下：\n\n```\n.scale{\n    position: relative;\n}\n.scale:after{\n    content:\"\";\n    position: absolute;\n    bottom:0px;\n    left:0px;\n    right:0px;\n    border-bottom:1px solid #ddd;\n    -webkit-transform:scaleY(.5);\n    -webkit-transform-origin:0 0;\n}\n```\n---\n\n### 相对单位 rem\n- 为了适应各大屏幕的手机，px略显固定,不能根据尺寸的大小而改变，使用相对单位更能体验页面兼容性\n\n    - em：是根据父节点的font-size为相对单位\n但em在多层嵌套下，变得非常难以操作\n\n    - rem：是根据html的font-size为相对单位\n    rem更加能作为全局统一设置的度量（但在实际产品交互体验上还需考量是否使用）\n\n- 引出另一个问题rem的基值设置多少好？\n回归我们的目的：为了适应各大手机屏幕\nrem = screen.width/20 \n有时我们也会看到在业界中会用如下方案：\n> 将`scale`设置为`1/dpr` , 而`<html>`的`font-size`计算为`screen.width * dpr / >10`,然后再以`less`将UE图上得到的尺寸透明转换为对应的`rem`值。\n\n关于这一方案的实现，推荐大家看看这篇文章： [数学方法解释 dpr/scale/rem 三者的关系][2]。\n\n- iphone5上的rem基值为32px，渲染一张64 * 64px的div，则用2rem * 2rem去渲染。换算公式非常简单：\nwidth：px/rem基值\nheight：px/rem基值\n\n- 不使用rem的情况：font-size\n    - 一般来说font-size是不应该使用rem等相对单位的。因为字体的大小是趋向于阅读的实用性，并不适合与排版布局。\n    - 同理趋向于一些固定的元素的特性。我们不使用rem而改为使用px去确保在不同屏幕上表现一致（和rem的目的相反）。\n\n---\n\n### 多行文本溢出···\n\n单行文本溢出，对title类的使用非常多，\n而多行文本类，在详情介绍则用的比较多。\n\n```\n//单行文本溢出...\n.inaline {\n    overflow: hidden;\n    white-space: nowrap;\n    text-flow: ellipsis;\n}\n\n//多行文本溢出...\n.intwoline {\n    display: -webkit-box !important;\n    overflow: hidden;\n    \n    text-overflow: ellipsis;\n    word-break: break-all; \n    \n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: 2; //关键属性，限制行数\n}\n```\n\n\n大概就是这些了，写的比较乱。如有错误欢迎指正。\n","slug":"移动web学习笔记","published":1,"updated":"2017-03-29T14:21:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1teca6m000oib1ciyhtzqhr","content":"<hr>\n<p>近期学了较多移动web开发的相关知识，所以在这里写点东西，也算坐个简单总结。</p>\n<hr>\n<h3 id=\"pixel像素基础\"><a href=\"#pixel像素基础\" class=\"headerlink\" title=\"pixel像素基础\"></a>pixel像素基础</h3><ul>\n<li>px：CSS pixels 逻辑像素，浏览器使用的抽象单位</li>\n<li>dp，pt：device independent pixels 设备独立像素</li>\n<li>dpr：devicePixelRatio 设备像素缩放比</li>\n</ul>\n<blockquote>\n<p>计算公式：1px=(dpr)² * dp</p>\n<p>在JavaScript中，可以通过<code>window.devicePixelRatio</code>获取当前设备的dpr</p>\n</blockquote>\n<p>这里盗个图：</p>\n<p>![][1]</p>\n<ul>\n<li>DPI:打印机每英寸可以喷的墨汁点（印刷行业）</li>\n<li>PPI:屏幕每英寸的像素数量，即单位英寸内的像素密度(ppi越高，像素越高，图像越清晰)</li>\n</ul>\n<p><strong>这几个属性之间的关系，以iPhone5为例</strong>：<br>iPhone5设备分辨率1136<em>640dp –&gt;<br>根号[(1136²+640²)]/4 = 326ppi –&gt; 326ppi属于Retina屏幕,所以根据规定dpr=2 –&gt;<br>1px = dpr² </em> dp –&gt;<br>iphone5的屏幕宽高为320*568px。</p>\n<blockquote>\n<p>例如这样，设计师可以根据<code>320px</code>为<code>基准</code>设计<code>视觉稿</code>。</p>\n</blockquote>\n<hr>\n<h3 id=\"Viewport视图\"><a href=\"#Viewport视图\" class=\"headerlink\" title=\"Viewport视图\"></a>Viewport视图</h3><p>为了让手机能获得良好的网页浏览体验，Apple 找到了一个办法：在移动版的 Safari（iOS平台）中定义了 viewport meta 标签，它的作用就是创建一个虚拟的窗口（viewport），而且这个虚拟窗口的分辨率接近于桌面显示器，Apple 将其定位为 980px.<br>手机浏览器默认为我们做了两件事情<br>一、页面渲染在一个980px（ios）的Viewport<br>二、缩放</p>\n<ul>\n<li>visual viewport（度量/视口）<br>= 窗口缩放 scalce，让手机页面可以看到多少</li>\n<li>layout viewport（布局）<br>负责渲染底层页面</li>\n</ul>\n<p><strong>最常用移动web viewport设置</strong></p>\n<p>【布局viewport】=【设备宽度】=【度量viewport】</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//常见viewport设置</div><div class=\"line\">&lt;meta name=&quot;viewport&quot; </div><div class=\"line\">content=&quot;width=device-width, //根据设备调整width</div><div class=\"line\">initial-scale=1, //比例为1</div><div class=\"line\">user-scalable=no&quot; //不允许用户缩放</div><div class=\"line\"></div><div class=\"line\">//在开发调试过程中，可以通过JS代码获得当前layout和visual的值</div><div class=\"line\">document.body.clientWidth //获得layout viewport值</div><div class=\"line\">window.innerWidth //获得visual viewport值</div></pre></td></tr></table></figure>\n<h3 id=\"设计移动Web\"><a href=\"#设计移动Web\" class=\"headerlink\" title=\"设计移动Web\"></a>设计移动Web</h3><ul>\n<li>方案一：根据设备的实际宽度来设计（常用）<br>手机宽320 px，我们就拿320 px设计</li>\n<li>方案二：1px=1dp<br>缩放0.5（initial-scale=0.5）。根据设备的物理像素 dp 等于抽象像素 px 来设计。1像素边框和高清图片都不需要额外处理。</li>\n</ul>\n<hr>\n<h1 id=\"移动web特别样式\"><a href=\"#移动web特别样式\" class=\"headerlink\" title=\"移动web特别样式\"></a>移动web特别样式</h1><hr>\n<h3 id=\"一像素边框\"><a href=\"#一像素边框\" class=\"headerlink\" title=\"一像素边框\"></a>一像素边框</h3><p>比如想让border的线更细些，我们虽然会设置成border：1px；但在是retina屏幕下，1px使用2dp渲染。使之看起来有2px，那我们就用border：0.5px咯。但很可惜，这种语法只在ios8以上的情况下有用，所以不是好方案。<br>这时我们就常用到scaleY(0.5),大致代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">.scale&#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.scale:after&#123;</div><div class=\"line\">    content:&quot;&quot;;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    bottom:0px;</div><div class=\"line\">    left:0px;</div><div class=\"line\">    right:0px;</div><div class=\"line\">    border-bottom:1px solid #ddd;</div><div class=\"line\">    -webkit-transform:scaleY(.5);</div><div class=\"line\">    -webkit-transform-origin:0 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"相对单位-rem\"><a href=\"#相对单位-rem\" class=\"headerlink\" title=\"相对单位 rem\"></a>相对单位 rem</h3><ul>\n<li><p>为了适应各大屏幕的手机，px略显固定,不能根据尺寸的大小而改变，使用相对单位更能体验页面兼容性</p>\n<ul>\n<li><p>em：是根据父节点的font-size为相对单位<br>但em在多层嵌套下，变得非常难以操作</p>\n</li>\n<li><p>rem：是根据html的font-size为相对单位<br>rem更加能作为全局统一设置的度量（但在实际产品交互体验上还需考量是否使用）</p>\n</li>\n</ul>\n</li>\n<li><p>引出另一个问题rem的基值设置多少好？<br>回归我们的目的：为了适应各大手机屏幕<br>rem = screen.width/20<br>有时我们也会看到在业界中会用如下方案：</p>\n<blockquote>\n<p>将<code>scale</code>设置为<code>1/dpr</code> , 而<code>&lt;html&gt;</code>的<code>font-size</code>计算为<code>screen.width * dpr / &gt;10</code>,然后再以<code>less</code>将UE图上得到的尺寸透明转换为对应的<code>rem</code>值。</p>\n</blockquote>\n</li>\n</ul>\n<p>关于这一方案的实现，推荐大家看看这篇文章： [数学方法解释 dpr/scale/rem 三者的关系][2]。</p>\n<ul>\n<li><p>iphone5上的rem基值为32px，渲染一张64 <em> 64px的div，则用2rem </em> 2rem去渲染。换算公式非常简单：<br>width：px/rem基值<br>height：px/rem基值</p>\n</li>\n<li><p>不使用rem的情况：font-size</p>\n<ul>\n<li>一般来说font-size是不应该使用rem等相对单位的。因为字体的大小是趋向于阅读的实用性，并不适合与排版布局。</li>\n<li>同理趋向于一些固定的元素的特性。我们不使用rem而改为使用px去确保在不同屏幕上表现一致（和rem的目的相反）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"多行文本溢出···\"><a href=\"#多行文本溢出···\" class=\"headerlink\" title=\"多行文本溢出···\"></a>多行文本溢出···</h3><p>单行文本溢出，对title类的使用非常多，<br>而多行文本类，在详情介绍则用的比较多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">//单行文本溢出...</div><div class=\"line\">.inaline &#123;</div><div class=\"line\">    overflow: hidden;</div><div class=\"line\">    white-space: nowrap;</div><div class=\"line\">    text-flow: ellipsis;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//多行文本溢出...</div><div class=\"line\">.intwoline &#123;</div><div class=\"line\">    display: -webkit-box !important;</div><div class=\"line\">    overflow: hidden;</div><div class=\"line\">    </div><div class=\"line\">    text-overflow: ellipsis;</div><div class=\"line\">    word-break: break-all; </div><div class=\"line\">    </div><div class=\"line\">    -webkit-box-orient: vertical;</div><div class=\"line\">    -webkit-line-clamp: 2; //关键属性，限制行数</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大概就是这些了，写的比较乱。如有错误欢迎指正。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>近期学了较多移动web开发的相关知识，所以在这里写点东西，也算坐个简单总结。</p>\n<hr>\n<h3 id=\"pixel像素基础\"><a href=\"#pixel像素基础\" class=\"headerlink\" title=\"pixel像素基础\"></a>pixel像素基础</h3><ul>\n<li>px：CSS pixels 逻辑像素，浏览器使用的抽象单位</li>\n<li>dp，pt：device independent pixels 设备独立像素</li>\n<li>dpr：devicePixelRatio 设备像素缩放比</li>\n</ul>\n<blockquote>\n<p>计算公式：1px=(dpr)² * dp</p>\n<p>在JavaScript中，可以通过<code>window.devicePixelRatio</code>获取当前设备的dpr</p>\n</blockquote>\n<p>这里盗个图：</p>\n<p>![][1]</p>\n<ul>\n<li>DPI:打印机每英寸可以喷的墨汁点（印刷行业）</li>\n<li>PPI:屏幕每英寸的像素数量，即单位英寸内的像素密度(ppi越高，像素越高，图像越清晰)</li>\n</ul>\n<p><strong>这几个属性之间的关系，以iPhone5为例</strong>：<br>iPhone5设备分辨率1136<em>640dp –&gt;<br>根号[(1136²+640²)]/4 = 326ppi –&gt; 326ppi属于Retina屏幕,所以根据规定dpr=2 –&gt;<br>1px = dpr² </em> dp –&gt;<br>iphone5的屏幕宽高为320*568px。</p>\n<blockquote>\n<p>例如这样，设计师可以根据<code>320px</code>为<code>基准</code>设计<code>视觉稿</code>。</p>\n</blockquote>\n<hr>\n<h3 id=\"Viewport视图\"><a href=\"#Viewport视图\" class=\"headerlink\" title=\"Viewport视图\"></a>Viewport视图</h3><p>为了让手机能获得良好的网页浏览体验，Apple 找到了一个办法：在移动版的 Safari（iOS平台）中定义了 viewport meta 标签，它的作用就是创建一个虚拟的窗口（viewport），而且这个虚拟窗口的分辨率接近于桌面显示器，Apple 将其定位为 980px.<br>手机浏览器默认为我们做了两件事情<br>一、页面渲染在一个980px（ios）的Viewport<br>二、缩放</p>\n<ul>\n<li>visual viewport（度量/视口）<br>= 窗口缩放 scalce，让手机页面可以看到多少</li>\n<li>layout viewport（布局）<br>负责渲染底层页面</li>\n</ul>\n<p><strong>最常用移动web viewport设置</strong></p>\n<p>【布局viewport】=【设备宽度】=【度量viewport】</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//常见viewport设置</div><div class=\"line\">&lt;meta name=&quot;viewport&quot; </div><div class=\"line\">content=&quot;width=device-width, //根据设备调整width</div><div class=\"line\">initial-scale=1, //比例为1</div><div class=\"line\">user-scalable=no&quot; //不允许用户缩放</div><div class=\"line\"></div><div class=\"line\">//在开发调试过程中，可以通过JS代码获得当前layout和visual的值</div><div class=\"line\">document.body.clientWidth //获得layout viewport值</div><div class=\"line\">window.innerWidth //获得visual viewport值</div></pre></td></tr></table></figure>\n<h3 id=\"设计移动Web\"><a href=\"#设计移动Web\" class=\"headerlink\" title=\"设计移动Web\"></a>设计移动Web</h3><ul>\n<li>方案一：根据设备的实际宽度来设计（常用）<br>手机宽320 px，我们就拿320 px设计</li>\n<li>方案二：1px=1dp<br>缩放0.5（initial-scale=0.5）。根据设备的物理像素 dp 等于抽象像素 px 来设计。1像素边框和高清图片都不需要额外处理。</li>\n</ul>\n<hr>\n<h1 id=\"移动web特别样式\"><a href=\"#移动web特别样式\" class=\"headerlink\" title=\"移动web特别样式\"></a>移动web特别样式</h1><hr>\n<h3 id=\"一像素边框\"><a href=\"#一像素边框\" class=\"headerlink\" title=\"一像素边框\"></a>一像素边框</h3><p>比如想让border的线更细些，我们虽然会设置成border：1px；但在是retina屏幕下，1px使用2dp渲染。使之看起来有2px，那我们就用border：0.5px咯。但很可惜，这种语法只在ios8以上的情况下有用，所以不是好方案。<br>这时我们就常用到scaleY(0.5),大致代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">.scale&#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">&#125;</div><div class=\"line\">.scale:after&#123;</div><div class=\"line\">    content:&quot;&quot;;</div><div class=\"line\">    position: absolute;</div><div class=\"line\">    bottom:0px;</div><div class=\"line\">    left:0px;</div><div class=\"line\">    right:0px;</div><div class=\"line\">    border-bottom:1px solid #ddd;</div><div class=\"line\">    -webkit-transform:scaleY(.5);</div><div class=\"line\">    -webkit-transform-origin:0 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"相对单位-rem\"><a href=\"#相对单位-rem\" class=\"headerlink\" title=\"相对单位 rem\"></a>相对单位 rem</h3><ul>\n<li><p>为了适应各大屏幕的手机，px略显固定,不能根据尺寸的大小而改变，使用相对单位更能体验页面兼容性</p>\n<ul>\n<li><p>em：是根据父节点的font-size为相对单位<br>但em在多层嵌套下，变得非常难以操作</p>\n</li>\n<li><p>rem：是根据html的font-size为相对单位<br>rem更加能作为全局统一设置的度量（但在实际产品交互体验上还需考量是否使用）</p>\n</li>\n</ul>\n</li>\n<li><p>引出另一个问题rem的基值设置多少好？<br>回归我们的目的：为了适应各大手机屏幕<br>rem = screen.width/20<br>有时我们也会看到在业界中会用如下方案：</p>\n<blockquote>\n<p>将<code>scale</code>设置为<code>1/dpr</code> , 而<code>&lt;html&gt;</code>的<code>font-size</code>计算为<code>screen.width * dpr / &gt;10</code>,然后再以<code>less</code>将UE图上得到的尺寸透明转换为对应的<code>rem</code>值。</p>\n</blockquote>\n</li>\n</ul>\n<p>关于这一方案的实现，推荐大家看看这篇文章： [数学方法解释 dpr/scale/rem 三者的关系][2]。</p>\n<ul>\n<li><p>iphone5上的rem基值为32px，渲染一张64 <em> 64px的div，则用2rem </em> 2rem去渲染。换算公式非常简单：<br>width：px/rem基值<br>height：px/rem基值</p>\n</li>\n<li><p>不使用rem的情况：font-size</p>\n<ul>\n<li>一般来说font-size是不应该使用rem等相对单位的。因为字体的大小是趋向于阅读的实用性，并不适合与排版布局。</li>\n<li>同理趋向于一些固定的元素的特性。我们不使用rem而改为使用px去确保在不同屏幕上表现一致（和rem的目的相反）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"多行文本溢出···\"><a href=\"#多行文本溢出···\" class=\"headerlink\" title=\"多行文本溢出···\"></a>多行文本溢出···</h3><p>单行文本溢出，对title类的使用非常多，<br>而多行文本类，在详情介绍则用的比较多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">//单行文本溢出...</div><div class=\"line\">.inaline &#123;</div><div class=\"line\">    overflow: hidden;</div><div class=\"line\">    white-space: nowrap;</div><div class=\"line\">    text-flow: ellipsis;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//多行文本溢出...</div><div class=\"line\">.intwoline &#123;</div><div class=\"line\">    display: -webkit-box !important;</div><div class=\"line\">    overflow: hidden;</div><div class=\"line\">    </div><div class=\"line\">    text-overflow: ellipsis;</div><div class=\"line\">    word-break: break-all; </div><div class=\"line\">    </div><div class=\"line\">    -webkit-box-orient: vertical;</div><div class=\"line\">    -webkit-line-clamp: 2; //关键属性，限制行数</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大概就是这些了，写的比较乱。如有错误欢迎指正。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj1teca4v0001ib1ca3d74q20","tag_id":"cj1teca540003ib1cxsd7dnj7","_id":"cj1teca60000cib1ch1fg10rs"},{"post_id":"cj1teca4v0001ib1ca3d74q20","tag_id":"cj1teca5s0007ib1ctvpd7vsn","_id":"cj1teca64000eib1cfi95ecv7"},{"post_id":"cj1teca500002ib1csry0zhvk","tag_id":"cj1teca540003ib1cxsd7dnj7","_id":"cj1teca6f000kib1c92icc3yg"},{"post_id":"cj1teca500002ib1csry0zhvk","tag_id":"cj1teca64000fib1cjs1pxo1k","_id":"cj1teca6l000mib1cayhk4fcu"},{"post_id":"cj1teca6d000jib1c7flgmh6p","tag_id":"cj1teca540003ib1cxsd7dnj7","_id":"cj1teca6o000pib1ctb289d61"},{"post_id":"cj1teca6d000jib1c7flgmh6p","tag_id":"cj1teca5s0007ib1ctvpd7vsn","_id":"cj1teca6o000qib1coc7iwr4u"},{"post_id":"cj1teca5h0005ib1c0jh0rwvk","tag_id":"cj1teca540003ib1cxsd7dnj7","_id":"cj1teca6p000sib1c1pg3skhg"},{"post_id":"cj1teca5h0005ib1c0jh0rwvk","tag_id":"cj1teca5s0007ib1ctvpd7vsn","_id":"cj1teca6p000tib1c8sj8q2y3"},{"post_id":"cj1teca61000dib1ckjrjjngq","tag_id":"cj1teca6l000nib1cyuspox0p","_id":"cj1teca6q000uib1ckmzzkxdn"},{"post_id":"cj1teca6f000lib1c0111ecjx","tag_id":"cj1teca6o000rib1c90tw12yt","_id":"cj1teca6q000vib1cz4diz2sj"},{"post_id":"cj1teca5y000bib1c6tnmqzcx","tag_id":"cj1temdrc0000wu1cfkifozu7","_id":"cj1temdsm0001wu1cg1ml1x26"}],"Tag":[{"name":"css","_id":"cj1teca540003ib1cxsd7dnj7"},{"name":"布局","_id":"cj1teca5s0007ib1ctvpd7vsn"},{"name":"盒模型","_id":"cj1teca64000fib1cjs1pxo1k"},{"name":"JavaScript CORS","_id":"cj1teca6l000nib1cyuspox0p"},{"name":"resume","_id":"cj1teca6o000rib1c90tw12yt"},{"name":"JavaScript","_id":"cj1temdrc0000wu1cfkifozu7"}]}}